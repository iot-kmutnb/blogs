<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/arduino/avr_gcc_part-1/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>การเขียนโปรแกรมภาษา C สำหรับ AVR (ATmega328P): ตอนที่ 1 - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#c-avr-atmega328p-1" class="nav-link">การเขียนโปรแกรมภาษา C สำหรับ AVR (ATmega328P): ตอนที่ 1</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#avr" class="nav-link">&#9655; ไมโครคอนโทรลเลอร์: AVR</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#atmega328p" class="nav-link">&#9655; ไมโครคอนโทรลเลอร์: ATmega328P</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cc" class="nav-link">&#9655; ซอฟต์แวร์สำหรับการเขียนโปรแกรมภาษา C/C++</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#c-avr-gcc-toolchain" class="nav-link">&#9655; การคอมไพล์โค้ดภาษา C โดยใช้ AVR-GCC Toolchain</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#avr-gdb" class="nav-link">&#9655; การดีบักโปรแกรมโดยใช้ AVR-GDB</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#avr_1" class="nav-link">&#9655; การใช้งานหน่วยความจำของ AVR โดยคอมไพเลอร์</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#microchip-studio-ide" class="nav-link">&#9655; การใช้ซอฟต์แวร์ Microchip Studio IDE</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#wokwi-avr-simulator" class="nav-link">&#9655; การใช้งาน Wokwi AVR Simulator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="c-avr-atmega328p-1">การเขียนโปรแกรมภาษา C สำหรับ AVR (ATmega328P): ตอนที่ 1<a class="headerlink" href="#c-avr-atmega328p-1" title="Permanent link">#</a></h1>
<p><strong>Keywords</strong>: <em>Atmel AVR MCU</em>, <em>ATmega328P</em>, 
<em>Bare-metal C Programming</em>, <em>AVR-GCC</em>, <em>Microchip Studio IDE</em></p>
<ul>
<li><a href="#avr">ไมโครคอนโทรลเลอร์ <strong>AVR</strong></a></li>
<li><a href="#atmega328p">ไมโครคอนโทรลเลอร์ <strong>ATmega328P</strong></a></li>
<li><a href="#cc">ซอฟต์แวร์สำหรับการเขียนโปรแกรมภาษา <strong>C/C++</strong></a></li>
<li><a href="#c-avr-gcc-toolchain">การคอมไพล์โค้ดภาษา <strong>C</strong> โดยใช้ <strong>AVR-GCC Toolchain</strong></a></li>
<li><a href="#avr-gdb">การดีบักโปรแกรมโดยใช้ <strong>AVR-GDB</strong></a></li>
<li><a href="#avr_1">การใช้งานหน่วยความจำของ <strong>AVR</strong> โดยคอมไพเลอร์</a></li>
<li><a href="#microchip-studio-ide">การใช้ซอฟต์แวร์ <strong>Microchip Studio IDE</strong></a></li>
<li><a href="#wokwi-avr-simulator">การใช้งาน <strong>Wokwi AVR Simulator</strong></a></li>
</ul>
<hr />
<h2 id="avr">&#9655; <strong>ไมโครคอนโทรลเลอร์: AVR</strong><a class="headerlink" href="#avr" title="Permanent link">#</a></h2>
<p>ชิปไมโครคอนโทรลเลอร์ขนาด 8 บิต ของบริษัท <strong>Atmel</strong> มีซีพียูแบบ <strong>RISC</strong> ทำงานตามสถาปัตยกรรมที่เรียกว่า 
<a href="https://en.wikipedia.org/wiki/AVR_microcontrollers"><strong>AVR</strong></a> 
ซึ่งเป็นผลงานการออกแบบโดยสองนักศึกษาที่สถาบันเทคโนโลยีแห่งนอร์เวย์ในปีค.ศ. 1984 และทั้งสองได้ร่วมก่อตั้งบริษัท 
ต่อมาในปีค.ศ. 2016 บริษัท <a href="https://en.wikipedia.org/wiki/Atmel"><strong>Atmel</strong></a>
ได้ถูกควบรวมกิจการโดยบริษัท <strong>Microchip Technology Inc.</strong></p>
<p>ไมโครคอนโทรลเลอร์ <strong>AVR</strong> ของ <strong>Atmel</strong> ได้รับความนิยมในอดีตที่ผ่านมา สาเหตุหนึ่งอาจเป็นเพราะว่า 
ได้มีการเลือกใช้ชิปไมโครคอนโทรลเลอร์ของบริษัทนี้ เป็นตัวประมวลผลหลักของบอร์ด
<a href="https://www.arduino.cc/"><strong>Arduino</strong></a> 
ซึ่งได้รับความนิยมอย่างมาก เช่น <strong>Arduino Uno / Nano / MEGA2560</strong> เป็นต้น</p>
<p>ไมโครคอนโทรลเลอร์ ที่ทำงานตามสถาปัตยกรรม <strong>8-bit AVR</strong> แบ่งออกได้หลายตระกูลดังนี้</p>
<ul>
<li><strong>tinyAVR</strong> &rarr; <strong>tinyAVR 0-series / 1-series / 2-series</strong></li>
<li><strong>megaAVR</strong> &rarr; <strong>megaAVR 0-series</strong></li>
<li><strong>XMEGA</strong></li>
<li><strong>AVR-Dx</strong> &rarr; <strong>AVR-DA / AVR-DB</strong></li>
</ul>
<p>นอกจากไมโครคอนโทรลเลอร์ 8 บิต <strong>AVR</strong> ทางบริษัท <strong>Atmel</strong> ก็ได้พัฒนาชิปไมโครคอนโทรลเลอร์ 32 บิต ในอดีต 
เช่น ตระกูล <strong>AVR32</strong> และชิป 32 บิต ที่ใช้ซีพียูตระกูล <strong>ARM Cortex-M Series</strong> เช่น
<strong>ATSAM3X8E</strong> และ <strong>ATSAMD21</strong> ที่ได้นำมาใช้สำหรับบอร์ด <strong>Arduino</strong> เช่นกัน</p>
<p><img alt="" src="../avr/images/avr_mcu_selection.png" /></p>
<p>รูป: <strong>Atmel MCU Families</strong> (Source: Atmel/Microchip)</p>
<p><img alt="" src="../avr/images/mega_avr_0_series.png" /></p>
<p>รูป: ชิปไมโครคอนโทรลเลอร์ที่เป็นสมาชิกในตระกูล  <strong>megaAVR (0-Series)</strong></p>
<p><img alt="" src="../avr/images/avr_da_db_mcu_devices.png" /></p>
<p>รูป:  ชิปไมโครคอนโทรลเลอร์ที่เป็นสมาชิกในตระกูล <strong>AVR-DA/DB</strong> ซึ่งถือว่าเป็นตระกูลใหม่ล่าสุด เริ่มจำหน่ายในปีค.ศ. 2020
(Source: Atmel/Microchip)</p>
<p><img alt="" src="../avr/images/avr_mega_new.png" /></p>
<p>รูป: ตารางเปรียบเทียบ <strong>megaAVR (0-Series) MCUs</strong> (Source: Atmel/Microchip)</p>
<p>จากเอกสาร <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/30010135E.pdf">"<strong>AVR Microcontrollers Peripheral Integration</strong>"</a>
จะเห็นได้ว่า ในตารางมีการเปรียบเทียบความแตกต่างของคุณสมบัติและองค์ประกอบภายในของไมโครคอนโทรลเลอร์
ที่เป็นสมาชิกแต่ละตระกูลไว้เป็นตัวอย่าง เช่น <strong>ATtiny</strong>, <strong>ATmega</strong>, <strong>ATxmega</strong></p>
<p><img alt="" src="../avr/images/avr_mcu_table-1.png" /></p>
<p>รูป: ตารางเปรียบเทียบ <strong>AVR MCUs</strong> (Source: Atmel/Microchip)</p>
<p>&nbsp;</p>
<p><strong>ข้อสังเกต:</strong> บอร์ด <strong>Arduino</strong> รุ่นใหม่ ๆ เกือบทั้งหมดได้เลือกใช้ชิปไมโครคอนโทรลเลอร์ 32 บิต 
แต่ก็ยังมีบางรุ่นที่ใช้ตัวประมวลผลแบบ 8 บิต คือ 
บอร์ด <a href="https://docs.arduino.cc/hardware/uno-wifi-rev2"><strong>Arduino Uno WiFi rev2</strong></a> และ 
<a href="https://docs.arduino.cc/hardware/nano-every"><strong>Ardunio Nano Every</strong></a>
ซึ่งใช้ชิป <a href="https://www.microchipdirect.com/product/search/all/ATMEGA4809"><strong>ATMEGA4809 (megaAVR 0-series)</strong></a> เป็นตัวประมวลผลหลัก</p>
<p>&nbsp;</p>
<hr />
<h2 id="atmega328p">&#9655; <strong>ไมโครคอนโทรลเลอร์: ATmega328P</strong><a class="headerlink" href="#atmega328p" title="Permanent link">#</a></h2>
<p>ดังที่ได้กล่าวไปแล้ว บอร์ด  <strong>Arduino Uno</strong> หรือ <strong>Nano</strong> มีชิปไมโครคอนโทรลเลอร์รุ่น <strong>ATmega328P</strong>
เป็นตัวประมวลผลหลักของบอร์ด และถือว่า เป็นบอร์ดไมโครคอนโทรลเลอร์ที่ยังคงหาซื้อมาใช้งานได้ในยุคปัจจุบัน และราคาไม่แพง เหมาะสำหรับผู้เริ่มต้น 
และเนื่องจากมีการทำงานที่ไม่ซับซ้อน จึงไม่ยากเกินไปสำหรับการเรียนการเขียนโปรแกรมแบบ <strong>Bare-metal</strong> โดยใช้ภาษา <strong>C</strong></p>
<p>ลองมาดูคุณสมบัติของ <strong>ATmega328P</strong> ซึ่งเป็นสมาชิกในตระกูล <strong>ATmega</strong> ดังนี้</p>
<ul>
<li>ทำคำสั่งตามสถาปัตยกรรมแบบ  <strong>RISC</strong> </li>
<li>มีการจัดการหน่วยความจำภายในตามสถาปัตยกรรมแบบที่เรียกว่า <strong>Modified Harvard Architecture</strong>
(แยกหน่วยความจำสำหรับ <strong>Data Memory</strong> และ <strong>Program Memory</strong> 
และมีการใช้งานบัสสำหรับหน่วยความจำทั้งสองประเภท 
แต่สามารถเข้าถึงข้อมูลในหน่วยความจำสำหรับ <strong>Program Memory</strong> เช่น เขียนหรืออ่านข้อมูลได้)</li>
<li>มีชุดคำสั่ง 131  คำสั่ง ซึ่งคำสั่งส่วนใหญ่ใช้เวลาในการทำคำสั่ง  1 ไซเคิล (<strong>CPU Cycle</strong>)</li>
<li>มีวงจรตัวคูณ (<strong>8x8-bit Hardware Multiplier</strong>) โดยใช้เวลาในการคำนวณ 2 ไซเคิล</li>
<li>ทำงานด้วยความถี่ <strong>16MHz</strong> (max.) ที่แรงดันไฟเลี้ยง <strong>+5V</strong></li>
<li>หน่วยความจำภายใน แบ่งเป็น 3 ชนิด<ul>
<li><strong>Flash</strong>: 32KB</li>
<li><strong>SRAM</strong>: 2KB</li>
<li><strong>EEPROM</strong>: 1KB</li>
</ul>
</li>
<li>มีวงจรตัวนับ <strong>Timer / Counter</strong> ทั้ง 8 บิต และ 16 บิต<ul>
<li>8-bit: <strong>TIMER0</strong>, <strong>TIMER2</strong></li>
<li>16-bit: <strong>TIMER1</strong></li>
</ul>
</li>
<li>สามารถสร้างสัญญาณ <strong>PWM</strong> (<strong>Pulse Width Modulation</strong>)
โดยใช้วงจร <strong>Timer / Counter</strong> ในโหมด <strong>PWM</strong> ได้สูงสุด 6 ช่องเอาต์พุต</li>
<li>มีวงจร <strong>ADC</strong> (<strong>Analog-to-Digital Converter</strong>) ที่มีอินพุต 8 ช่องสัญญาณ และมีขนาดข้อมูลที่ได้ 10 บิต</li>
<li>มีวงจร <strong>USART</strong> 1 ชุด</li>
<li>มีวงจรสำหรับสื่อสารข้อมูลแบบบัส <strong>SPI</strong> และ <strong>I2C</strong> อย่างละ 1 ชุด ทำงานได้ในโหมด
<strong>Master</strong> หรือ <strong>Slave</strong></li>
<li>มีวงจรเปรียบเทียบแรงดันแบบแอนะล็อก (<strong>On-chip Analog Comparator</strong>) 1 ชุด</li>
<li>มีวงจรภายในสำหรับสร้างความถี่ (<strong>On-chip Oscillator</strong>) ได้ <strong>8MHz</strong> </li>
<li>มีวงจร <strong>WDT</strong> (<strong>Watchdog Timer</strong>)</li>
<li>มีโหมดการทำงานเลือได้ 6 โหมด สำหรับประหยัดพลังงาน (<strong>Sleep Modes</strong>) นอกเหนือจากภาวะปรกติ
ยกตัวอย่างเช่น <strong>Idle</strong>, <strong>Power-save</strong>, <strong>Power-down</strong> เป็นต้น</li>
<li>ทำงานด้วยแรงดันไฟเลี้ยง ได้ในช่วง <strong>+2.7V</strong> ถึง <strong>+5.5V</strong></li>
<li>จำนวนขา  <strong>I/O</strong> ที่ใช้งานได้คือ  23 ขา  สำหรับตัวถังของไอซีแบบ ** 32-pin TQFP<strong>
โดยแบ่งออกเป็นพอร์ตขนาด 8 บิต ได้แก่ </strong>PORTA<strong>, </strong>PORTB<strong>, </strong>PORTC<strong>, </strong>PORTD**</li>
</ul>
<p>การศึกษาฟังก์ชันการทำงานต่าง ๆ ของไมโครคอนโทรลเลอร์ในระดับฮาร์ดแวร์ จะต้องอาศัยการทำความเข้าใจรายละเอียดในเอกสารที่เรียกว่า <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf"><strong>Datasheet</strong></a> ของไมโครคอนโทรลเลอร์จากผู้ผลิต</p>
<p>&nbsp;</p>
<hr />
<h2 id="cc">&#9655; <strong>ซอฟต์แวร์สำหรับการเขียนโปรแกรมภาษา C/C++</strong><a class="headerlink" href="#cc" title="Permanent link">#</a></h2>
<p>ในการเขียนโปรแกรมสำหรับ <strong>AVR MCU</strong> โดยเลือกใช้ชิป <strong>ATmega328P</strong>
เราสามารถเลือกใช้คอมไพเลอร์ <strong>GCC-AVR</strong> ซึ่งเป็น <strong>Open Source</strong>
และใช้ร่วมกับซอฟต์แวร์ที่เป็น <strong>IDE</strong> (<em>Integrated Development Environment</em>)
เช่น <a href="https://www.arduino.cc/en/software"><strong>Arduino IDE</strong></a> หรือ 
<a href="https://www.microchip.com/en-us/tools-resources/develop/microchip-studio"><strong>Microchip Studio IDE</strong></a> </p>
<p><img alt="" src="../avr/images/microchip_studio_ide_atmega328p.png" /></p>
<p>รูป:  <strong>Microchip Studio IDE</strong> สาธิตการเขียนโค้ดภาษา <strong>C</strong> และใช้คำสั่งจากไลบรารี
<strong>avr-libc</strong> สำหรับ <strong>ATmega328P</strong></p>
<p><img alt="" src="../avr/images/avr_arduino_ide_atmega328p.png" /></p>
<p>รูป:  <strong>Arduino IDE</strong> และการเขียนโค้ดในไฟล์ <code>main.c</code> แทนการเขียนโค้ดในไฟล์  <strong>Arduino Sketch (.ino)</strong> </p>
<p>&nbsp;</p>
<p>ข้อดีของการใช้ซอฟต์แวร์ <strong>Microchip Studio IDE</strong> (หรือเดิมชื่อ <strong>Atmel Studio 7 IDE</strong>)
เพื่อการเรียนรู้การเขียนโค้ดภาษา <strong>C/C++</strong> คือ
ความสามารถในการรันคำสั่งของโปรแกรมที่ได้จากการคอมไพล์โค้ดสำหรับ <strong>AVR MCU</strong> 
ดังนั้นผู้ใช้สามารถดีบักโปรแกรมได้โดยใช้ตัวจำลองการทำงาน (<strong>Simulator-based Debugger</strong>) 
เช่น สั่งให้ทำคำสั่งแล้วหยุดชั่วคราวได้ เพื่อดูการเปลี่ยนแปลงรีจิสเตอร์ภายในของไมโครคอนโทรลเลอร์</p>
<p>&nbsp;</p>
<p><strong>คำแนะนำ:</strong> แม้ว่าซอฟต์แวร์ <strong>Microchip Studio IDE</strong> ยังมีการอัปเดตเป็นระยะ ๆ โดยบริษัท <strong>Microchip</strong>
แต่บริษัทก็มีซอฟต์แวร์ <strong>MPLAB-X IDE</strong> เป็นอีกหนึ่งทางเลือก และได้พัฒนาให้รองรับการใช้งานสำหรับไมโครคอนโทรลเลอร์ของ <strong>Atmel</strong> เช่น ตระกูล <strong>AVR</strong> (8 บิต) และ <strong>SAM</strong> (32 บิต) เป็นต้น</p>
<p><img alt="" src="../avr/images/mplabx_avr-10.png" /></p>
<p>รูป:  <strong>MPLAB-X Desktop IDE (v6.0.0)</strong> สาธิตการเขียนโค้ดภาษา <strong>C</strong> สำหรับ <strong>AVR MCU</strong></p>
<p>&nbsp;</p>
<p>ข้อดีของการใช้ซอฟต์แวร์ <strong>Arduino IDE</strong> แม้ว่าจะไม่สามารถจำลองการทำงานของโค้ดได้
แต่ก็มีความสะดวกและง่ายในการใช้งาน 
การอัปโหลดไฟล์โปรแกรมที่ได้จากขั้นตอนการคอมไพล์โค้ดไปยังบอร์ด <strong>Arduino</strong> ผ่านสาย <strong>USB</strong> ก็ทำได้ง่าย 
(ชิป <strong>ATmega328P</strong> ต้องมีการใส่เฟิร์มแวร์ที่มีขนาดเล็ก เรียกว่า <strong>Arduino Bootloader</strong>
ในหน่วยความจำภายใน <strong>Flash</strong> เอาไว้แล้ว และใช้งานร่วมกับโปรแกรม <strong>avrdude</strong>)</p>
<p>ซอฟต์แวร์ที่เป็นประเภท <strong>IDE</strong> เหล่านี้ มีการเรียกใช้งานโปรแกรมของ 
<a href="https://github.com/arduino/toolchain-avr"><strong>AVR-GCC Toolchain</strong></a> 
หรือ  <strong>Atmel AVR GNU Toolchain</strong> ที่ทำงานแบบ <strong>CLI</strong> (<em>Command Line Interface</em>) 
โดยทั่วไปแล้ว ก็ประกอบไปด้วยโปรแกรมต่าง ๆ ดังนี้ ซึ่งโดยทั่วไปแล้ว ผู้ใช้จะไม่ได้เรียกใช้งานโปรแกรมเหล่านี้โดยตรง
แต่จะทำงานในลักษณะเบื้องหลังให้กับซอฟต์แวร์ที่เป็น <strong>IDE</strong>  </p>
<ul>
<li>C/C++ cross compiler: <a href="https://gcc.gnu.org/wiki/avr-gcc"><code>avr-gcc</code></a></li>
<li>Assembler, linker, debugger: <a href="https://en.wikipedia.org/wiki/GNU_Binutils"><code>binutils</code></a></li>
<li>Standard C libraries: <a href="https://www.nongnu.org/avr-libc/user-manual/index.html"><code>avr-libc</code></a></li>
<li>AVR Flash programmer: <a href="https://www.nongnu.org/avrdude/"><code>avrdude</code></a></li>
</ul>
<p>ในการเขียนโปรแกรมภาษา <strong>C</strong> สำหรับ <strong>AVR</strong> เราสามารถใช้ฟังก์ชันต่าง ๆ ที่มีอยู่ในไลบรารี <a href="https://www.nongnu.org/avr-libc/user-manual/modules.html"><strong>avr-libc 2.0.0</strong></a> ซึ่งมีการแบ่งกลุ่มในการใช้งาน เช่น</p>
<ul>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/group__avr__io.html"><code>&lt;avr/io.h&gt;</code></a>: AVR device-specific IO definitions</li>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/group__util__delay.html"><code>&lt;util/delay.h&gt;</code></a>:  functions for busy-wait delay loops</li>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html"><code>&lt;avr/interrupt.h&gt;</code></a>: AVR interrupts</li>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/group__avr__watchdog.html"><code>&lt;avr/wdt.h&gt;</code></a>: Watchdog timer handling</li>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/group__avr__power.html"><code>&lt;avr/power.h&gt;</code></a>: Power Reduction Management</li>
</ul>
<hr />
<h2 id="c-avr-gcc-toolchain">&#9655; <strong>การคอมไพล์โค้ดภาษา C โดยใช้ AVR-GCC Toolchain</strong><a class="headerlink" href="#c-avr-gcc-toolchain" title="Permanent link">#</a></h2>
<p>หากใช้ระบบปฏิบัติการ <strong>Linux</strong> เช่น <strong>Ubuntu</strong> หรือใช้งาน <strong>Windows</strong> 
ร่วมกับ <a href="https://docs.microsoft.com/en-us/windows/wsl/install"><strong>WSL2</strong></a>
(<em>Windows Subsystem for Linux</em>)
ก็สามารถทำคำสั่งใน <strong>Terminal</strong> เพื่อติดตั้ง <strong>AVR-GCC Toolchain</strong> ได้ดังนี้</p>
<pre><code class="language-bash">$ sudo apt-get install binutils-avr gcc-avr gdb-avr avr-libc avrdude
</code></pre>
<p>&nbsp;</p>
<p><strong>ตัวอย่างโค้ด</strong>: <code>main.c</code> สาธิตการเขียนโปรแกรมเพื่อทำให้วงจร <strong>LED</strong> ที่ต่อเข้ากับขา <strong>PORTB5 (PB5)</strong>
บนบอร์ด <strong>Arduino Uno</strong> หรือ <strong>Nano</strong> กระพริบได้</p>
<pre><code class="language-c++">#define F_CPU   16000000UL // set the CPU speed to 16MHz

#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;   // for _delay_ms();

#define BLINK_DELAY_MS  500 /* in msec */

int main (void) {
    // Set pin 5 of PORTB (PORTB5 pin) for output.
    DDRB |= _BV(DDB5);
    // Output low at PORTB5 pin.
    PORTB &amp;= ~_BV(PORTB5);
    // Enter an endless loop.
    while (1) {
        // Toggle output.
        PORTB ^= _BV(PORTB5);
        // Call delay_ms().
        _delay_ms( BLINK_DELAY_MS );
    } //end while
}
</code></pre>
<p>&nbsp;</p>
<p>ตัวอย่างการทำคำสั่งเพื่อคอมไพล์โค้ดในไฟล์ <code>main.c</code> ให้เป็นไฟล์ <code>main.elf</code> และเป็น <code>main.hex</code> ตามลำดับ</p>
<pre><code class="language-bash"># Set the target device (use ATmega328p).
$ TARGET_MCU=atmega328p

# Compile the source code file (main.c) into an object file,
# optimize for size (-Os) and enable all warnings (-Wall).
$ avr-gcc -g -Wall -Os -mmcu=${TARGET_MCU} -c main.c

# Link the object file and libraries into an ELF file
# and also generate a linker map file.
$ avr-gcc -g -mmcu=${TARGET_MCU} -Wl,-Map,avr.map -lc -lm -o main.elf main.o

# Convert the ELF file into a .hex file (Intel hex file).
$ avr-objcopy -j .text -j .data -O ihex main.elf main.hex
</code></pre>
<p><img alt="" src="../avr/images/avr-gcc_build_ubuntu.png" /></p>
<p>รูป: สาธิตการทำคำสั่งใน <strong>Linux Terminal</strong> </p>
<p>สำหรับผู้ใช้ <strong>Windows</strong> หากได้เคยติดตั้งใช้งานซอฟต์แวร์ <strong>Arduino IDE</strong> ไว้แล้ว 
จะเห็นว่า มีไดเรกทอรีต่าง ๆ ที่เก็บโปรแกรมคำสั่งสำหรับ <strong>AVR-GCC Toolchain</strong> อยู่ภายใต้ </p>
<p><code>C:\Users\%USERNAME%\AppData\Local\Arduino15\packages\arduino\tools</code> </p>
<p>มีไดเรกทอรีย่อย เช่น <code>avr-gcc</code> และ <code>avrdude</code> และให้สังเกตไดเรกทอรีย่อยที่อยู่ภายใน</p>
<p>หากต้องการลองทำคำสั่งแบบ <strong>CLI</strong> สำหรับ <strong>Windows</strong> ก็มีตัวอย่างดังนี้ ซึ่งจะต้องมีการกำหนดหรืออัปเดทตัวแปร <code>PATH</code>
ของระบบ สำหรับการเรียกใช้โปรแกรม  (<em> หมายเลขเวอร์ชันอาจมีการเปลี่ยนแปลงได้ ขึ้นอยู่กับอัปเดทล่าสุด </em>)</p>
<pre><code class="language-powershell">set ARDUINO_TOOLS=C:\Users\%USERNAME%\AppData\Local\Arduino15\packages\arduino\tools
set AVR_GCC=%ARDUINO_TOOLS%\avr-gcc\7.3.0-atmel3.6.1-arduino7\bin
set AVRDUDE=%ARDUINO_TOOLS%\avrdude\6.3.0-arduino17\bin
set PATH=%PATH%;%AVR_GCC%;%AVRDUDE%
</code></pre>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/avr_gcc_build_windows-1.png" /></p>
<p>รูป: สาธิตการทำคำสั่งใน <strong>Windows Command Terminal</strong></p>
<p>&nbsp;</p>
<pre><code class="language-powershell"># set target MCU
&gt; set TARGET_MCU=atmega328p

# compile the source code file (main.c) into an object file
# optimize for size, enable all warnings
&gt; avr-gcc -g -Wall -Os -mmcu=%TARGET_MCU% -c main.c

# link the object file and libraries into an ELF file
&gt; avr-gcc -g -mmcu=%TARGET_MCU% -Wl,-Map,avr.map -lc -lm -o main.elf main.o

# convert the ELF file into a .hex file (Intel hex file)
&gt; avr-objcopy -j .text -j .data -O ihex main.elf main.hex
</code></pre>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/avr_gcc_build_windows-2.png" /></p>
<p>รูป: สาธิตการทำคำสั่งใน <strong>Windows Command Terminal</strong> คอมไพล์โค้ด <code>main.c</code> ให้เป็นไฟล์ <code>main.hex</code></p>
<p>&nbsp;</p>
<p>ลองทำคำสั่ง <code>avrdude</code> ซึ่งจะปรากฎข้อความเอาต์พุตเป็นตัวอย่างดังนี้</p>
<pre><code>&gt;avrdude
Usage: avrdude [options]
Options:
  -p &lt;partno&gt;                Required. Specify AVR device.
  -b &lt;baudrate&gt;              Override RS-232 baud rate.
  -B &lt;bitclock&gt;              Specify JTAG/STK500v2 bit clock period (us).
  -C &lt;config-file&gt;           Specify location of configuration file.
  -c &lt;programmer&gt;            Specify programmer type.
  -D                         Disable auto erase for flash memory
  -i &lt;delay&gt;                 ISP Clock Delay [in microseconds]
  -P &lt;port&gt;                  Specify connection port.
  -F                         Override invalid signature check.
  -e                         Perform a chip erase.
  -O                         Perform RC oscillator calibration (see AVR053).
  -U &lt;memtype&gt;:r|w|v:&lt;filename&gt;[:format]
                             Memory operation specification.
                             Multiple -U options are allowed, each request
                             is performed in the order specified.
  -n                         Do not write anything to the device.
  -V                         Do not verify.
  -u                         Disable safemode, default when running from a script.
  -s                         Silent safemode operation, will not ask you if
                             fuses should be changed back.
  -t                         Enter terminal mode.
  -E &lt;exitspec&gt;[,&lt;exitspec&gt;] List programmer exit specifications.
  -x &lt;extended_param&gt;        Pass &lt;extended_param&gt; to programmer.
  -y                         Count # erase cycles in EEPROM.
  -Y &lt;number&gt;                Initialize erase cycle # in EEPROM.
  -v                         Verbose output. -v -v for more.
  -q                         Quell progress output. -q -q for less.
  -l logfile                 Use logfile rather than stderr for diagnostics.
  -?                         Display this usage.

avrdude version 6.3-20190619, URL: &lt;http://savannah.nongnu.org/projects/avrdude/&gt;
</code></pre>
<p>&nbsp;</p>
<p>เมื่อได้เชื่อมต่อบอร์ด <strong>Arduino</strong> กับคอมพิวเตอร์ผู้ใช้แล้ว ลองทำคำสั่งต่อไปนี้ (สังเกต: หมายเลขพอร์ตอนุกรม) </p>
<pre><code class="language-powershell">&gt; avrdude -C %AVRDUDE%/../etc/avrdude.conf -v -p atmega328p -c arduino ^
  -b 115200 -P COM9 -D -Uflash:w:main.hex:i
</code></pre>
<p>&nbsp;</p>
<p>จากตัวอย่างการทำคำสั่ง <code>avrdude</code> จะเห็นว่า มีการกำหนดค่าต่าง ๆ ในการใช้งานดังนี้</p>
<ul>
<li><code>-C &lt;config-file&gt;</code> ระบุไฟล์ <strong>Configuration file</strong> สำหรับการทำงานของโปรแกรม</li>
<li><code>-p &lt;part-number&gt;</code> ระบุชื่ออุปกรณ์ (<strong>Part Number</strong>) สำหรับชิปเป้าหมาย เช่น <code>atmega328p</code></li>
<li><code>-c &lt;programmer&gt;</code> ระบุวิธีการอัปโหลดไฟล์สำหรับไมโครคอนโทรลเลอร์ เช่น ถ้าเป็น <code>arduino</code> หมายถึง วิธีสื่อสารกับ <strong>Arduino bootloader</strong> ในชิปไมโครคอนโทรลเลอร์ และเชื่อมต่อผ่านทางพอร์ตอนุกรม <strong>Serial</strong></li>
<li><code>-b &lt;baudrate&gt;</code> กำหนดค่า <strong>Baudrate</strong> เช่น 115200 สำหรับเชื่อมต่อกับ <strong>Arduino bootloader</strong> </li>
<li><code>-P &lt;port&gt;</code> เลือกพอร์ตอนุกรมที่ตรงกับบอร์ดไมโครคอนโทรเลอร์ที่เชื่อมต่ออยู่กับคอมพิวเตอร์ผู้ใช้ เช่น <code>COM9</code> ในตัวอย่าง</li>
<li><code>-D</code> ไม่ทำการลบข้อมูลในหน่วยความจำแฟลซโดยอัตโนมัติ </li>
<li><code>-U</code> ทำคำสั่งเขียนหน่วยความจำ เช่น เขียนข้อมูลจากไฟล์ <code>main.hex</code> (Intel hex format)
ไปยังหน่วยความจำแฟลซภายในชิปไมโครคอนโทรลเลอร์  </li>
</ul>
<p><img alt="" src="../avr/images/avr_gcc_build_windows-3.png" /></p>
<p>รูป: สาธิตการทำคำสั่งใน <strong>Windows Command Terminal</strong> เรียกใช้โปรแกรม <code>avrdude</code> 
เพื่ออัปโหลดไฟล์ <code>main.hex</code> ไปยังบอร์ด <strong>Arduino Nano 3.0</strong> ที่เชื่อมต่อกับคอมพิวเตอร์ผู้ใช้
ผ่านทาง <strong>USB-to-Serial / Virtual COM port</strong> หมายเลข <code>COM9</code></p>
<p>&nbsp;</p>
<hr />
<h2 id="avr-gdb">&#9655; <strong>การดีบักโปรแกรมโดยใช้ AVR-GDB</strong><a class="headerlink" href="#avr-gdb" title="Permanent link">#</a></h2>
<p>เริ่มต้นด้วยโค้ดตัวอย่างสำหรับสาธิตการดีบักการทำงานด้วยโปรแกรม <strong>AVR-GDB</strong> ดังนี้
(แตกต่างจากตัวอย่างโค้ดเดิม คือ มีการเพิ่มตัวแปรภายนอก <code>counter</code> และไม่มีการเรียกใช้ฟังก์ชันสำหรับหน่วงเวลา)</p>
<pre><code class="language-c++">#define F_CPU   16000000UL // set the CPU speed to 16MHz
#include &lt;avr/io.h&gt;

// global variable
uint16_t counter = 0;

int main (void) {
  // set pin 5 of PORTB for output*
  DDRB |= _BV(DDB5);
  // Output low at PORTB5 pin.
  PORTB &amp;= ~_BV(PORTB5);
  while(1)  {
    // Increment counter by 1.
    counter += 1;
    // Toggle output.
    PORTB ^= _BV(PORTB5);
  } //end while
}
</code></pre>
<p>&nbsp;</p>
<p>ทำคำสั่งเพื่อคอมไพล์โค้ดในไฟล์ <code>main.c</code> เป็นไฟล์ <code>main.elf</code></p>
<pre><code class="language-bash">$ avr-gcc -g -Wall -Os -mmcu=atmega328p main.c \
  -Wl,-Map,main.map -lc -lm -o main.elf
</code></pre>
<p>เรียกใช้โปรแกรม <code>avr-gdb</code> สำหรับไฟล์ <code>main.elf</code> </p>
<pre><code class="language-bash">$ avr-gdb ./main.elf
GNU gdb (GDB) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
...
Reading symbols from ./main.elf...done.
(gdb) 
</code></pre>
<p>&nbsp;</p>
<p>จากนั้นทำคำสั่ง <code>target sim</code> เพื่อทำให้ตัวจำลองการทำงาน <strong>Simulator</strong> เริ่มทำงาน
และทำคำสั่ง <code>load</code> เพื่อโหลดโปรแกรม <code>main.elf</code> และพร้อมทำงานเริ่มต้นที่แอดเดรส <code>0x0</code> </p>
<pre><code class="language-plain">(gdb) target sim
Connected to the simulator.
(gdb) load
Loading section .text, size 0xba lma 0x0
Start address 0x0
Transfer rate: 1488 bits in &lt;1 sec.
</code></pre>
<p>&nbsp;</p>
<p>ทำคำสั่ง <code>set listsize &lt;lines&gt;</code> เพื่อกำหนดจำนวนบรรทัดของโค้ดที่ต้องการจะแสดงผลในแต่ละครั้ง
เมื่อทำคำสั่ง <code>list</code> เพื่อดูบางส่วนของโค้ดในโปรแกรมหลัก</p>
<p>หากทำคำสั่ง <code>list &lt;func-name&gt;</code> จะแสดงโค้ดที่เกี่ยวข้องกับฟังก์ชันตามชื่อฟังก์ชันที่ระบุไว้ 
เช่น ฟังก์ชัน <code>main</code></p>
<pre><code class="language-plain">(gdb) set listsize 10
(gdb) list main
4       // global variable
5       uint16_t counter = 0;
6
7       int main (void) {
8           // set pin 5 of PORTB for output*
9           DDRB |= _BV(DDB5);
10          // Output low at PORTB5 pin.
11          PORTB &amp;= ~_BV(PORTB5);
12          while(1)  {
13             // Increment counter by 1.
(gdb)
</code></pre>
<p>&nbsp;</p>
<p>หรือแสดงโค้ดตามช่วงของเลขบรรทัดที่ระบุ เช่น จากบรรทัดที่ 7 ไปจนถึง 20</p>
<pre><code class="language-plain">(gdb) list 7,20
7       int main (void) {
8           // set pin 5 of PORTB for output*
9           DDRB |= _BV(DDB5);
10          // Output low at PORTB5 pin.
11          PORTB &amp;= ~_BV(PORTB5);
12          while(1)  {
13             // Increment counter by 1.
14             counter += 1;
15             // Toggle output.
16             PORTB ^= _BV(PORTB5);
17          } //end while
18      }
19
</code></pre>
<p>&nbsp;</p>
<p>ถัดไปเป็นการทำคำสั่ง <code>break &lt;line-number&gt;</code> เพื่อกำหนดให้
ประโยคคำสั่งในโค้ดตามหมายเลขบรรทัดที่ระบุเป็นตำแหน่งของ <strong>Breakpoint</strong>
เมื่อสั่งให้รันโปรแกรมต่อไป หากมาถึงบรรทัดดังกล่าว จะหยุดการรันโปรแกรมโดยอัตโนมัติ</p>
<p>คำสั่งสำหรับการรันโปรแกรมคือ <code>run</code> และถ้ามีการหยุดชั่วคราวแล้วต้องการรันโค้ดในประโยคคำสั่งถัดไป 
ให้ทำคำสั่ง <code>next</code> หรือทำคำสั่ง <code>continue</code> ไปจนกว่าจะถึงตำแหน่งถัดไปที่เป็น <strong>Breakpoint</strong></p>
<pre><code class="language-plain">(gdb) break 14
Breakpoint 1 at 0x96: file main.c, line 14.
(gdb) run
Starting program: /home/ubuntu/AVR/main.elf

Breakpoint 1, main () at main.c:14
14             counter += 1;
(gdb) next
16             PORTB ^= _BV(PORTB5);
</code></pre>
<p>&nbsp;</p>
<p>ถ้าต้องการแสดงค่าในขณะนั้นของตัวแปรหรือรีจิสเตอร์ในโปรแกรม ให้ใช้คำสั่ง <code>print</code> </p>
<pre><code class="language-plain">(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
(gdb) print /u counter
$1 = 2
</code></pre>
<p>&nbsp;</p>
<p>จากตัวอย่างจะเห็นได้ว่า มีการกำหนดให้บรรทัดที่ 14 เป็นตำแหน่งของ <strong>Breakpoint</strong> และ
เมื่อทำคำสั่ง <code>continue</code>หลายครั้ง ค่าตัวของตัวแปร  <code>counter</code> 
(แสดงผลเป็นเลขจำนวนเต็มแบบ <code>unsigned</code>) จะเพิ่มขึ้น</p>
<pre><code class="language-plain">(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
(gdb) print /x PORTB
$2 = 0x20
(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
(gdb) print /x PORTB
$3 = 0x0
</code></pre>
<p>&nbsp;</p>
<p>เมื่อทำคำสั่ง <code>continue</code> หลายครั้ง ก็จะเห็นได้ว่า ค่าของรีจิสเตอร์ <strong>PORTB</strong> (แสดงผลในเลขฐานสิบหก) มีการเปลี่ยนแปลง เช่นกัน</p>
<p>ถ้าต้องการให้แสดงค่าของตัวแปรหรือรีจิสเตอร์ของไมโครคอนโทรลเลอร์โดยอัตโนมัติ เมื่อมีการหยุดโดย <strong>Breakpoint</strong> 
ให้ทำคำสั่ง <code>display</code> ตามรูปแบบต่อไปนี้ เช่น ดูค่าของตัวแปร <code>counter</code> และรีจิสเตอร์ <code>PORTB</code></p>
<pre><code class="language-plain">(gdb) set PORTB = 0x0
(gdb) display /x PORTB
1: /x PORTB = 0x0
(gdb) display /u counter
2: /u counter = 0

(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
1: /x PORTB = 0x20
2: /u counter = 1

(gdb) continue
Continuing.

Breakpoint 1, main () at main.c:14
14             counter += 1;
1: /x PORTB = 0x0
2: /u counter = 2
(gdb)
</code></pre>
<p>&nbsp;</p>
<p>หากต้องการจบการทำงานของ <strong>AVR-GDB</strong> ให้กดปุ่ม <code>Ctrl+C</code> </p>
<p><strong>คำแนะนำ:</strong> คำสั่งที่เกี่ยวข้องกับ <strong>AVR-GDB</strong> สามารถศึกษาเพิ่มได้จาก 
<a href="https://blog.wokwi.com/gdb-avr-arduino-cheatsheet/"><strong>"Arduino/AVR GDB Cheat Sheet by Uri Shaked"</strong></a> (<a href="../avr/Arduino_AVR%20GDB_Cheat_Sheet.pdf">pdf</a>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="avr_1">&#9655; <strong>การใช้งานหน่วยความจำของ AVR โดยคอมไพเลอร์</strong><a class="headerlink" href="#avr_1" title="Permanent link">#</a></h2>
<p>หน่วยความจำภายในของชิป <strong>AVR</strong> แบ่งเป็นหน่วยความจำแบบแฟลช (<strong>Flash Memory</strong>)
หน่วยความจำแบบ <strong>SRAM</strong> และหน่วยความจำแบบ <strong>EEPROM</strong> </p>
<p>หน่วยความจำแบบ <strong>SRAM</strong> ของ <strong>AVR</strong> แบ่งเป็น 2 กรณี คือ หน่วยความจำภายใน (<strong>On-chip SRAM</strong>)
และอาจมีหน่วยความจำภายนอก (<strong>External SRAM</strong>) สำหรับชิปบางรุ่น
และสามารถจำแนกได้ตามรูปแบบการใช้งานสำหรับข้อมูลและตัวแปร ดังนี้</p>
<ul>
<li>ตัวแปรภายนอก  (<strong>Global Variables</strong>) ทั้งแบบที่มีการกำหนดค่าเริ่มต้น และแบบไม่มีการกำหนดค่าเริ่มต้นเมื่อประกาศใช้ตัวแปร
และตัวแปรภายในฟังก์ชัน  (<strong>Local Variables</strong>) ที่ได้ประกาศเป็น <code>static</code> </li>
<li>ตัวแปรที่ใช้หน่วยความจำแบบ <strong>Heap</strong>  เมื่อใช้คำสั่ง <code>malloc()</code> และ <code>free()</code> เป็นต้น</li>
<li>ตัวแปรที่ใช้หน่วยความจำแบบ <strong>Stack</strong> เช่น ตัวแปรภายในฟังก์ชัน รวมถึงการเรียกใช้ฟังก์ชัน เป็นต้น</li>
</ul>
<p>ตัวแปรภายนอกและตัวแปรภายในแบบ <code>static</code> (ที่ไม่ใช่ <strong>Automatic Variables</strong>)
จะถูกสร้างขึ้นก่อนการเริ่มต้นทำงานของฟังก์ชัน <code>main()</code>
ตัวแปรประเภทนี้ จะไม่ใช้หน่วยความจำแบบ <strong>Stack</strong> หรือ รีจิสเตอร์ของซีพียู
แต่จะใช้หน่วยความจำแยกไว้ (ซึ่งก็เป็นส่วนหนึ่งของ <strong>SRAM</strong>) แบ่งเป็นสองส่วน</p>
<ul>
<li><code>.data</code> สำหรับตัวแปรที่มีการกำหนดค่าเริ่มต้นไม่เท่ากับ 0 (<strong>non-zero initialized</strong>) 
เมื่อประกาศใช้ตัวแปร หน่วยความจำสำหรับตัวแปรประเภทนี้ จะได้ค่าคงที่หรือค่าเริ่มต้นจากข้อมูลที่เก็บอยู่ในหน่วยความจำแฟลช
และการจัดการในส่วนนี้เป็นหน้าที่ของ <strong>C Startup Code</strong></li>
<li><code>.bss</code> สำหรับตัวแปรที่มีการกำหนดค่าเริ่มต้นเท่ากับ 0 หรือ ไม่มีการกำหนดค่าเริ่มต้นให้ (<strong>unintialized</strong>) 
เมื่อประกาศใช้ตัวแปร  และตัวแปรประเภทนี้ จะถูกกำหนดค่าเริ่มต้นโดยคอมไพเลอร์ให้มีค่าเป็น 0 โดยอัตโนมัติ</li>
</ul>
<p>ตัวแปรสองประเภทนี้ จะเข้าถึงได้โดยการระบุแอดเดรสของตัวแปรในหน่วยความจำ 
ซึ่งคอมไพเลอร์จะทราบตำแหน่งหรือแอดเดรสเหล่านี้เมื่อทำขั้นตอนคอมไพล์สำหรับชิป <strong>AVR</strong></p>
<p><strong>C Startup Code</strong> เป็นโค้ดที่ทำหน้าที่เริ่มต้นก่อนส่งต่อให้ฟังก์ชัน <code>main()</code>
นอกจากการกำหนดค่าเริ่มต้นให้หน่วยความจำในส่วนที่เป็น <code>.data</code> และ <code>.bss</code>
แล้วยังมีหน้าที่อีก เช่น</p>
<ul>
<li>กำหนดค่าเริ่มต้นให้รีจิสเตอร์ที่เป็น <strong>Stack Pointer (SP)</strong> ถ้าเป็น <strong>AVR</strong> ก็จะเริ่มที่แอดเดรสสูงสุด
(<code>RAMEND</code>)
และเมื่อมีการใช้งาน <strong>Stack</strong> ด้วยคำสั่ง <code>push</code> ค่าของ <strong>SP</strong> จะลดลง และเพิ่มขึ้นเมื่อทำคำสั่ง <code>pop</code></li>
<li>ตั้งค่าเริ่มต้นการทำงานของซีพียู และวงจรภายในต่าง ๆ ที่เกี่ยวข้อง</li>
</ul>
<p>การคอมไพล์โค้ดด้วย <code>avr-gcc</code> จะได้ไฟล์โปรแกรมแบบไบนารี  <code>.elf</code> แต่จะต้องมีการแปลงให้เป็นไฟล์ <code>.hex</code> อีกขั้นตอนหนึ่ง
จึงจะนำไปใช้กับชิปไมโครคอนโทรลเลอร์ได้ ไฟล์โปรแกรม <code>.elf</code> ภายในมีการแบ่งออกเป็นส่วนต่าง ๆ และสามส่วนที่สำคัญและเกี่ยวข้องกับการใช้งานหน่วยความจำของ <strong>AVR</strong> ได้แก่</p>
<ul>
<li><code>.text</code> (<strong>Program Code</strong>) เป็นส่วนที่เก็บคำสั่งต่าง ๆ ของโปรแกรม และจะถูกนำไปเขียนลงในหน่วยความจำแฟลชของชิป <strong>AVR</strong>
ขนาดของส่วนนี้เป็นตัวระบุว่า มีขนาดของโปรแกรมกี่ไบต์</li>
<li><code>.data</code> เป็นส่วนที่เกี่ยวข้องกับการใช้งานตัวแปรภายนอกและตัวแปรภายในแบบ <code>static</code> ที่มีการกำหนดค่าเริ่มต้น
บางกรณีก็มีการจำแนกย่อยออกเป็น <code>.rodata</code> สำหรับข้อมูลที่อ่านได้เท่านั้น (<strong>read-only</strong>)</li>
<li><code>.bss</code> เป็นส่วนที่เกี่ยวข้องกับการใช้งานตัวแปรภายนอกและตัวแปรภายในแบบ <code>static</code> ที่ไม่มีการกำหนดค่าเริ่มต้น</li>
</ul>
<p>ขนาดและความต้องการใช้หน่วยความจำในแต่ละส่วน สามารถทราบได้โดยทำคำสั่ง <code>avr-size</code></p>
<p>ตัวอย่างโค้ดสำหรับการสาธิต</p>
<pre><code>#include &lt;inttypes.h&gt;

// .data sections (non-zero initialized global variables)
const uint32_t MAX_VALUE = (-1);
uint8_t arr[] __attribute__((aligned(4))) = {1,2,3};

// .bss section (uninitialized or zero-initialized global variables)
uint16_t counter = 0;
char     sbuf[8];

uint16_t inc() {
  // A static local variable, but initialized with 0
  static uint16_t cnt = 0;
  return ++cnt;
}

int main() {
  uint16_t ret_val = inc();
  (void)ret_val; // Suppress the compiler warning for unused variables.
  return ret_val;
}
</code></pre>
<p>จากตัวอย่างโค้ด สามารถระบุตัวแปรภายนอกและตัวแปรภายในแบบ <code>static</code> ได้ดังนี้</p>
<ul>
<li><code>MAX_VALUE</code> (4 ไบต์) เป็นตัวแปรภายนอกที่มีการกำหนดค่าเริ่มต้น
(และเป็น <code>const</code> ด้วย เปลี่ยนแปลงค่าไม่ได้อีก) ดังนั้นจึงอยู่ใน <code>.data</code></li>
<li><code>arr</code> (4 ไบต์) เป็นตัวแปรภายนอกซึ่งเป็นอาร์เรย์ของข้อมูลแบบ <code>uint8_t</code> 
และมีการกำหนดค่าเริ่มต้นด้วยข้อมูล 3 ตัว <code>{1,2,3}</code> ให้เป็นค่าเริ่มต้น แต่มีการใช้คำสั่ง
<code>__attribute__((aligned(4)))</code> โดยระบุว่า คอมไพเลอร์จะต้องใช้หน่วยความจำสำหรับอาร์เรย์
ที่มีขนาดหารด้วย 4 ลงตัว ดังนั้นตัวแปรนี้จึงใช้หน่วยความจำ 4 ไบต์ และอยู่ใน <code>.data</code></li>
<li><code>counter</code> (2 ไบต์)  เป็นตัวแปรภายนอก มีค่าเป็นต้นเป็น 0 ตัวแปรนี้จะอยู่ใน <code>.bss</code></li>
<li><code>sbuf[8]</code> (8 ไบต์) เป็นตัวแปรภายนอกแบบอาร์เรย์ ไม่ได้กำหนดค่าเริ่มต้น  ตัวแปรนี้จะอยู่ใน <code>.bss</code></li>
<li><code>cnt</code> (2 ไบต์) เป็นตัวแปรภายในแบบ <code>static</code> อยู่ในฟังก์ชัน <code>inc()</code> 
แต่มีค่าเป็นต้นเป็น 0 ตัวแปรนี้จะอยู่ใน <code>.bss</code></li>
<li><code>ret_val</code> (2 ไบต์) เป็นตัวแปรภายในฟังก์ชัน <code>main()</code>
และมีการกำหนดค่าเริ่มต้นโดยใช้ค่าที่ได้จากการเรียกใช้ฟังก์ชัน <code>inc()</code>
แต่เนื่องจากเป็นตัวแปรภายในและไม่ใช่ <code>static</code> จึงไม่ได้อยู่ใน <code>.data</code> และ <code>.bss</code>
โดยทั่วไปแล้ว ก็จะใช้รีจิสเตอร์ของซีพียูสำหรับตัวแปรในลักษณะนี้</li>
</ul>
<p>ลองทำคำสั่ง</p>
<pre><code class="language-bash">$ avr-gcc -mmcu=atmega328p -std=gnu99 -Wall -Os main.c -o main.elf 
$ avr-size main.elf
</code></pre>
<p>จะได้เอาต์พุต</p>
<pre><code>   text    data     bss     dec     hex filename
    194       8      12     214      d6 main.elf
</code></pre>
<p>แต่ถ้าคอมไพล์โค้ดโดยไม่รวมส่วนที่เรียกว่า <strong>C Startup Code</strong> (การทำคำสั่งต่าง ๆ เมื่อโปรแกรมเริ่มต้นการทำงานก่อนส่งต่อให้ฟังก์ชัน <code>main</code>)
 ก็เพิ่ม <code>-nostartfiles</code> ในคำสั่ง</p>
<pre><code>$ avr-gcc -mmcu=atmega328p -std=gnu99 -Wall -Os main.c -nostartfiles -o main.elf 
$ avr-size main.elf
</code></pre>
<p>จะได้เอาต์พุตดังนี้</p>
<pre><code>   text    data     bss     dec     hex filename
     62       8      12      82      52 main.elf
</code></pre>
<p>ซึ่งจะเห็นได้ว่า ส่วนที่เป็น <code>.text</code> มีขนาดเล็กลง  เพราะตัดคำสั่งต่าง ๆ ของ <strong>C Startup Code</strong> ออกไป</p>
<p>แต่ถ้าใช้ <strong>Options</strong> เช่น <code>-Wl,--gc-sections</code> ก็จะทำให้คอมไพเลอร์ตัดตัวแปรที่ไม่มีการใช้งานออกไป</p>
<pre><code>$ avr-gcc -mmcu=atmega328p -std=gnu99 -Wall -Os main.c -Wl,--gc-sections -o main.elf 
$ avr-size main.elf
</code></pre>
<p>จะได้เอาต์พุตดังนี้</p>
<pre><code>   text    data     bss     dec     hex filename
    194       0       4     198      c6 main.elf
</code></pre>
<p>และจะเห็นได้ว่า ขนาดของ <code>.data</code> เป็น 0 ไบต์  และ <code>.bss</code> ลดลงเหลือ 4 ไบต์ (ตัวแปรใดที่มีการประกาศใช้
แต่ไม่ถูกอ้างอิง จะไม่มีอยู่จริงในหน่วยความจำ)</p>
<p><strong>ข้อสังเกต:</strong> ถ้าใช้คอมไพเลอร์ <strong>XC8 C/C++ Compiler</strong> ของ <strong>Microchip</strong> 
ก็จะมีรายละเอียดที่แตกต่างจากการใช้คอมไพเลอร์ <strong>avr-gcc</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="microchip-studio-ide">&#9655; <strong>การใช้ซอฟต์แวร์ Microchip Studio IDE</strong><a class="headerlink" href="#microchip-studio-ide" title="Permanent link">#</a></h2>
<p>ขั้นตอนการใช้งาน <a href="https://www.microchip.com/en-us/tools-resources/develop/microchip-studio"><strong>Microchip Studio IDE</strong></a> ในเบื้องต้น 
(ทดลองใช้เวอร์ชัน <strong>v7.0.2542</strong>) เพื่อเขียนโค้ดภาษา <strong>C/C++</strong> สำหรับ <strong>AVR MCU</strong> มีดังนี้</p>
<ol>
<li>สร้างโปรเจกต์ใหม่</li>
<li>ระบุชื่อโปรเจกต์ และ เลือกไดเรกทอรีสำหรับเก็บไฟล์ต่าง ๆ ของโปรเจกต์</li>
<li>เลือกไมโครคอนโทรลเลอร์ที่ต้องการใช้งาน</li>
<li>แก้ไขโค้ดในไฟล์ <code>main.c</code> หรือเพิ่มไฟล์ .c หรือ .h ในโปรเจกต์ (ถ้ามี)</li>
<li>ทำขั้นตอน <strong>Build Project</strong> เพื่อคอมไพล์โค้ด</li>
<li>ทำขั้นตอนดีบักการทำงานของโค้ดโดยใช้ <strong>Simulator</strong></li>
</ol>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-1.png" /></p>
<p>รูป: สร้างโปรเจกต์ใหม่ จากเมนูคำสั่ง <strong>New &gt; File &gt; Project...</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-2.png" /></p>
<p>รูป: เลือก <strong>GCC C Executable Project</strong> และตั้งชื่อโปรเจกต์</p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-3.png" /></p>
<p>รูป: เลือกไมโครคอนโทรลเลอร์ตระกูล <strong>ATmega &gt; ATmega328P</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-4.png" /></p>
<p>รูป: แก้ไขไฟล์ <code>main.c</code> ในโปรเจกต์ใหม่ เพื่อลองเขียนโค้ดตามตัวอย่าง 
แล้วทำขั้นตอน <strong>Build &gt; Build Solution</strong> เพื่อคอมไพล์โค้ดในโปรเจกต์</p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-5.png" /></p>
<p>รูป: ทำขั้นตอน <strong>Debug &gt; Start Debugging and Break</strong> 
เพื่อเริ่มต้นการดีบักโปรแกรมโดยใช้ <strong>Tool &gt; Simulator</strong> 
เมื่อเข้าสู่ <strong>Debug Session</strong> ให้หยุดที่คำสั่งแรกในฟังก์ชัน <code>main()</code></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-6.png" /></p>
<p>รูป: คลิกเลือกบรรทัดในโค้ดเพื่อใช้เป็นตำแหน่งของ <strong>Breakpoints</strong>
แล้วลองรันโปรแกรมต่อไป (<strong>Continue</strong>)</p>
<p>&nbsp;</p>
<p>จากรูปจะเห็นได้ว่า ผู้ใช้สามารถใช้ตัวจำลองการทำงาน (<strong>Simulator</strong>) รันโค้ดของโปรแกรมได้
ในหน้าต่าง <strong>Watch</strong> ผู้ใช้สามารถเพิ่มรายการสำหรับตัวแปร หรือ รีจิสเตอร์ของไมโครคอนโทรลเลอร์
เพื่อดูการเปลี่ยนแปลงค่าในขณะที่รันหรือดีบักโค้ดได้</p>
<p><img alt="" src="../avr/images/microchip_studio_avr-7.png" /></p>
<p>รูป: แสดงสถานะการทำงานของไมโครคอนโทรเลลอร์ เช่น 
<strong>Processor Status</strong> และ <strong>I/O</strong> เป็นต้น</p>
<p>&nbsp;</p>
<p>ข้อดีของการดีบักด้วย <strong>Simulator</strong> ได้แก่</p>
<ul>
<li>กำหนดหมายเลขบรรทัดในโค้ด ให้เป็นตำแหน่งของ <strong>Breakpoint</strong> เพื่อหยุดการทำงานชั่วคราว หากทำคำสั่งมาถึงตำแหน่งดังกล่าว</li>
<li>สามารถดูสถานะการทำงานภายในของไมโครคอนโทรลเลอร์ได้ เช่น ค่าของรีจิสเตอร์ต่าง ๆ ค่าของตัวแปรในหน่วยความจำ</li>
<li>สามารถกำหนดค่าความถี่ของซีพียู เช่น <strong>16MHz</strong> และดูค่าของ <strong>Stop Watch</strong> หรือ <strong>Cycle Counter</strong>
ในการจับเวลาการทำงานเมื่อทำคำสั่งต่าง ๆ ในโปรแกรมได้</li>
</ul>
<p>หากต้องการแปลงไฟล์ไบนารีที่ได้จากการคอมไพล์ซอร์สโค้ด ให้เป็นโค้ดภาษา <strong>AVR Assembly</strong>
ก็ทำได้ดังนี้</p>
<p><img alt="" src="../avr/images/microchip_studio_avr_disassembly-1.png" /></p>
<p>รูป: การเลือกเมนูเพื่อทำดูผลการแปลงไฟล์ <strong>Disassembly</strong></p>
<p><img alt="" src="../avr/images/microchip_studio_avr_disassembly-2.png" /></p>
<p>รูป: ตัวอย่างโค้ด (แสดงเฉพาะส่วนที่เป็นฟังก์ชัน <code>main</code>) ที่ได้จากการแปลงด้วยโปรแกรม <strong>AVR Disassembler</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="wokwi-avr-simulator">&#9655; <strong>การใช้งาน Wokwi AVR Simulator</strong><a class="headerlink" href="#wokwi-avr-simulator" title="Permanent link">#</a></h2>
<p><strong>Wokwi AVR Simulator</strong> เป็นซอฟต์แวร์อีกตัวเลือกหนึ่งที่เป็น <strong>Open Source</strong>
และใช้งานได้ฟรี เปิดเว็บเบราว์เซอร์ไปยัง <a href="https://wokwi.com/arduino/projects">https://wokwi.com/arduino/projects</a>
สำหรับเขียนโค้ดและดีบักการทำงานของบอร์ด <strong>Arduino</strong></p>
<p><img alt="" src="../avr/images/wokwi-avr-1.png" /></p>
<p>รูป: สร้างโปรเจกต์ใหม่ <strong>NEW PROJECT</strong> และเลือกบอร์ด <strong>Arduino</strong> อย่างเช่น <strong>Nano</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-2.png" /></p>
<p>รูป: สร้างไฟล์ใหม่ <strong>New file...</strong> ตั้งชื่อไฟล์ใหม่เป็น <code>main.c</code> 
และในไฟล์ <code>sketch.ino</code> ที่มีอยู่แล้ว ให้ลบโค้ดออก (ว่างเปล่า)</p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-3.png" /></p>
<p>รูป: การต่อวงจรเสมือนจริง  โดยเพิ่มอุปกรณ์ <strong>8-Channel Virtual Logic Analyzer</strong> ในวงจร</p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-4.png" /></p>
<p>รูป: การเชื่อมต่อขาสัญญาณตามรูปตัวอย่าง เพื่อบันทึกการเปลี่ยนแปลงที่ขา <strong>D13</strong> 
ของบอร์ด <strong>Arduino Nano</strong></p>
<p>&nbsp;</p>
<p>เมื่อ <strong>AVR Simulator</strong> เริ่มทำงาน จะมีการบันทึกการเปลี่ยนแปลงค่าลอจิก และเมื่อหยุดการจำลองการทำงาน
จะมีการดาวน์โหลดไฟล์  <code>wokwi-logic.vcd</code> มายังเครื่องคอมพิวเตอร์ของผู้ใช้โดยอัตโนมัติ
และใช้โปรแกรมอย่างเช่น <strong>GTKWave</strong> เปิดไฟล์ .vcd และแสดงข้อมูลเป็นรูปคลื่นสัญญาณ</p>
<p><img alt="" src="../avr/images/gtkwave-1.png" /></p>
<p>รูป: การใช้โปรแกรม <strong>GTKWave</strong> แสดงรูปคลื่นสัญญาณดิจิทัล และวัดความกว้างพัลส์ช่วงที่เป็น <strong>HIGH</strong>
เช่น ได้ความกว้าง <strong>313 ns</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/gtkwave-2.png" /></p>
<p>รูป: แสดงรูปคลื่นสัญญาณดิจิทัล และวัดความกว้างของคาบสัญญาณ 
เช่น ได้ความกว้างของคาบ <strong>625 ns = 10 cycles x (1/16MHz)</strong> 
หรือคิดเป็นความถี่เท่ากับ  <strong>1.6MHz</strong> </p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-5.png" /></p>
<p>รูป: เรียกใช้งาน <strong>Web-based AVR-GDB (Debug Session)</strong> กดปุ่ม <strong>Fn + F1</strong>
แล้วพิมพ์ค้นหา <strong>gdb</strong> แล้วเลือกตามเมนูคำสั่ง จากนั้นจะเปิดหน้า <strong>Tab</strong> ใหม่ เพื่อเริ่มต้นใช้งาน <strong>Web GDB</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-6.png" /></p>
<p>รูป: เริ่มต้นใช้งาน <strong>WokWi Web GDB</strong></p>
<p>&nbsp;</p>
<p><img alt="" src="../avr/images/wokwi-avr-7.png" /></p>
<p>รูป: ตัวอย่างการทำคำสั่ง <strong>(gdb)</strong> </p>
<p>&nbsp;</p>
<hr />
<h2 id="_1">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้นำเสนอซอฟต์แวร์ ได้แก่ <strong>Arduino IDE</strong>, <strong>Microchip Studio IDE</strong> 
และ <strong>Wokwi Arduino Simulator</strong> ซึ่งเราสามารถนำมาใช้ในการเขียนโค้ดภาษา <strong>C/C++</strong>
สำหรับไมโครคอนโทรลเลอร์ <strong>AVR MCU</strong> เช่น <strong>ATmega328P</strong> (เป็นชิปที่ใช้กับบอร์ด <strong>Arduino Uno</strong>)
และสามารถดีบักการทำงานของโค้ดได้ด้วย โดยใช้วิธีการจำลองการทำงาน เมื่อใช้โปรแกรมอย่างเช่น
<strong>AVR GDB Debugger</strong>, <strong>Microchip Studio IDE</strong> 
หรือ <strong>Wokwi AVR Simulator (Web-based)</strong></p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2022-01-17 | Last Updated: 2023-02-11</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
