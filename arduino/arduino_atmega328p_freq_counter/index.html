<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/arduino/arduino_atmega328p_freq_counter/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบด้วย Arduino - ATmega328P - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#arduino-atmega328p" class="nav-link">การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบด้วย Arduino - ATmega328P</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">&#9655; การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบ</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#1" class="nav-link">&#9655; ตัวอย่างโค้ดที่ 1</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#2" class="nav-link">&#9655; ตัวอย่างโค้ดที่ 2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="arduino-atmega328p">การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบด้วย Arduino - ATmega328P<a class="headerlink" href="#arduino-atmega328p" title="Permanent link">#</a></h1>
<p><strong>Keywords</strong>: <em>Arduino</em>, <em>ATmega328P</em>, <em>Frequency Measurement</em></p>
<hr />
<h2 id="_1">&#9655;  <strong>การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบ</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้กล่าวถึง การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบ (<strong>Frequency Measurement</strong>) 
โดยใช้บอร์ดไมโครคอนโทรลเลอร์ <strong>Arduino Uno / Nano</strong></p>
<p>การวัดความถี่ของสัญญาณดิจิทัลแบบมีคาบ (<strong>Periodic Digital Signal</strong>) 
โดยใช้บอร์ดไมโครคอนโทรลเลอร์ <strong>Arduino</strong> สามารถทำได้หลายวิธี และขอกล่าวถึงสองวิธี </p>
<ul>
<li>วิธีแรกเป็นการวัดความกว้างของคาบ (<strong>Period</strong>) ซึ่งเป็นระยะห่างเชิงเวลาของขอบสัญญาณ 
เช่น เมื่อเกิดขอบขาขึ้นถัดกันสองครั้ง (<strong>Two Consecutive Rising Edges</strong>)
โดยเปิดใช้งาน <strong>External Interrupt</strong> เพื่อคอยตรวจดูว่า มีขอบขาขึ้นของสัญญาณหรือไม่ 
และบันทึกเวลาเมื่อเกิดขอบขาขึ้นของสัญญาณแต่ละครั้ง แล้วหาผลต่างค่าเวลาทั้งสองเหตุการณ์ดังกล่าว ก็จะได้คาบเวลา
ดังนั้นไมโครคอนโทรลเลอร์จะต้องมีระบบฐานเวลาที่ใช้วงจรตัวนับ  (<strong>Timer/Counter</strong>) 
เช่น มีความละเอียดในการจับเวลา 1 ไมโครวินาที เป็นต้น
การวัดความกว้างของคาบ จะทำเพียงครั้งเดียวหรือวัดค่าสำหรับหลายคาบ แล้วนำมาหาค่าเฉลี่ยก็ได้
ถ้าในช่วงเวลาดังกล่าว สัญญาณมีคาบหรือความถี่คงที่ จากนั้นเมื่อได้ความกว้างของคาบ ก็สามารถคำนวณความถี่ของสัญญาณอินพุตได้</li>
<li>วิธีที่สองคือ การใช้สัญญาณที่มีคาบนั้น เป็นสัญญาณอินพุตและป้อนให้วงจรตัวนับ (<strong>Timer/Counter</strong>) 
ที่อยู่ภายในไมโครคอนโทรลเลอร์ แล้วนำค่าของตัวนับที่ได้ในช่วงเวลาที่กำหนดไว้ (ช่วงที่จับเวลา) 
มาคำนวณเป็นความถี่ได้ ระยะเวลาในการนับจะถูกกำหนดโดยวงจรตัวนับอีกตัวหนึ่งของไมโครคอนโทรลเลอร์</li>
</ul>
<p>ในการตั้งค่าใช้งานสำหรับวงจรตัวนับที่อยู่ภายใน <strong>ATmega328P</strong> 
ไม่มีคำสั่งของ <strong>Arduino API</strong> ไว้ให้ใช้งาน ดังนั้นผู้ใช้จะต้องกำหนดค่าในรีจิสเตอร์ต่าง ๆ 
ของวงจร <strong>Timers</strong> ที่เกี่ยวข้อง ให้ถูกต้อง</p>
<p>ความแตกต่างระหว่าง <strong>Timer</strong> กับ <strong>Counter</strong></p>
<ul>
<li><strong>Timer</strong> เป็นวงจรตัวนับที่มีการเพิ่มค่าขึ้นด้วยอัตราคงที่ เช่น ทำงานตามจังหวะของสัญญาณ <strong>Clock</strong> ที่มีความถี่คงที่</li>
<li><strong>Counter</strong> เป็นวงจรตัวนับมีการเพิ่มค่าขึ้นอยู่กับเหตุการณ์หรือเงื่อนไขที่เกิดขึ้นตามที่ได้กำหนดไว้
เช่น นับจำนวนพัลส์ แต่ถ้าการเกิดพัลส์มีอัตราคงที่ <strong>Counter</strong> ก็จะทำงานเหมือน <strong>Timer</strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="1">&#9655; <strong>ตัวอย่างโค้ดที่ 1</strong><a class="headerlink" href="#1" title="Permanent link">#</a></h2>
<p>โค้ด <strong>Arduino Sketch</strong> ต่อไปนี้ สาธิตการวัดความกว้างของคาบสัญญาณอินพุตที่ป้อนเข้าขา 
<strong>D2</strong> ของ <strong>Arduino Uno / Nano</strong> ซึ่งสามารถเปิดใช้งานอินเทอร์รัพท์ภายนอกได้ที่ขาดังกล่าว</p>
<p>เมื่อเกิดเหตุการณ์ขอบขาขึ้นของสัญญาณอินพุตที่ขา <strong>D2</strong>
จะทำให้เกิดอินเทอร์รัพท์จากภายนอก (<strong>External Interrupt</strong>) แล้วให้ฟังก์ชัน <strong>ISR</strong> 
ที่เกี่ยวข้องทำหน้าที่อ่านค่าของตัวนับ <strong>Timer1</strong> ภายในชิป <strong>ATmega328P</strong> ที่ถูกใช้เป็นตัวสร้างฐานเวลา</p>
<p>วงจรตัวนับ <strong>Timer1</strong> จะถูกตั้งค่าให้มีความละเอียดในการนับ 0.5 ไมโครวินาที (&mu;sec) 
ซึ่งใช้ตัวหารความถี่เท่ากับ 8 (จากความถี่ <strong>16MHz</strong> ของ <strong>CPU</strong> ดังนั้น <strong>16MHz/8 = 2MHz</strong> 
เป็นความถี่ในการนับ หรือ มีคาบเวลาเท่ากับ <strong>0.5 usec</strong>)</p>
<p>ในการจับเวลาของขอบขาขึ้นแต่ละครั้ง จะต้องบันทึกเวลาสองครั้ง และมีระยะเวลาห่างกันทั้งหมดเท่ากับ 4 คาบ 
แล้วนำค่าที่บันทึกได้ มาคำนวณผลต่างแล้วหาร 4 และคูณด้วย 0.5 ไมโครวินาที (หรือ หารด้วย 8 เพียงครั้งเดียว)
จึงจะได้เป็นคาบเวลา (เฉลี่ย) ในหน่วยเป็นไมโครวินาที</p>
<p>วิธีการวัดคาบเวลาหรือความถี่ในลักษณะนี้ สามารถวัดสัญญาณที่มีความถี่ไม่เกิน <strong>100kHz</strong> (โดยประมาณ) 
หรือมีคาบ 10 ไมโครวินาที เนื่องจากถ้าใช้ความถี่สูงมาก ฟังก์ชัน <strong>ISR</strong> จะตอบสนองต่ออินเทอร์รัพท์ได้ไม่ทัน
ค่าที่วัดจะมีความผิดพลาดสูงกว่า ในกรณีที่ใช้ความถี่ต่ำ</p>
<p>ในตัวอย่างนี้มีการสร้างสัญญาณ <strong>PWM</strong> โดยใช้วงจร <strong>Timer2</strong> (มีรีจิสเตอร์ตัวนับขนาด 8 บิต)
ให้เป็นเอาต์พุตที่ขา <strong>Arduino D11 / PB3</strong> แล้วนำไปป้อนให้ขา <strong>Arduino D2</strong>
เพื่อใช้เป็นสัญญาณทดสอบ หากไม่มีแหล่งกำเนิดสัญญาณภายนอก</p>
<p>ในตัวอย่างนี้ วงจร <strong>Timer2</strong> จะถูกตั้งค่าให้ทำงานในโหมด <strong>Fast PWM</strong> และตั้งค่าบิต
<strong>WGM2[2:0]="111"</strong> เมื่อค่าในรีจิสเตอร์ <strong>TCNT2</strong> มีการนับขึ้นจาก  <strong>0x00 (BOTTOM)</strong> 
มาได้เท่ากับค่าสูงสุดซึ่งระบุไว้ในรีจิสเตอร์ <strong>OCR2A (TOP)</strong> จะถูกรีเซตค่ากลับไปเริ่มต้นนับใหม่
และเหตุการณ์นี้เรียกว่า <strong>Compare Match</strong></p>
<p>นอกจากนั้นยังได้มีการกำหนดให้ค่าบิต <strong>COM2A[1:0]="01"</strong> ซึ่งเป็นการเปิดใช้งานขาสำหรับ
<strong>Output Compare Match A (OC2A)</strong> ที่ตรงกับขา <strong>PB3</strong>
และตั้งค่าให้มีการสลับค่าลอจิกที่ขาดังกล่าว  (<strong>Toggle OCR2A pin</strong>)
เมื่อเกิดเหตุการณ์ <strong>Compare Match</strong></p>
<p>ช่วงของความถี่ของสัญญาณ <strong>PWM</strong> (<script type="math/tex">f_{PWM}</script>)
ก็ขึ้นอยู่กับการตั้งค่าตัวหารความถี่ (<script type="math/tex">prescaler</script>) และให้ความถี่ของซีพียู
(<script type="math/tex">f_{CPU}</script>) เท่ากับ <strong>16MHz</strong> และมีเงื่อนไข ดังนี้</p>
<p>
<script type="math/tex; mode=display">  
   \frac{ f_{CPU} }{ prescaler \times f_{PWM} \times 2 } < 256
</script>
</p>
<p>ยกตัวอย่างเช่น ถ้าใช้ตัวหารความถี่เท่ากับ 8 ดังนั้น ความถี่ต่ำสุดของสัญญาณ <strong>PWM</strong> ที่เลือกใช้ได้ สามารถคำนวณได้ดังนี้</p>
<p>
<script type="math/tex; mode=display">
   f_{PWM}(min) = \frac{16\,MHz}{8 \times 256 \times 2} = 3906.25 \,Hz
</script>
</p>
<p>ข้อสังเกต: การทำงานของโค้ดตัวอย่างนี้ มีการปิดการทำงานของวงจร <strong>Timer0</strong> ชั่วคราว 
โดยปรกติแล้ว <strong>Arduino Sketch</strong> จะใช้ <strong>Timer0</strong> 
ในการสร้างฐานเวลาของระบบที่มีการเกิดอินเทอร์รัพท์ทุก ๆ 4 ไมโครวินาที และใช้กับคำสั่ง เช่น <code>micros()</code> 
และ <code>millis()</code></p>
<pre><code class="language-c++">#define FREQ_PIN     (2)   // Arduino D2 pin
#define PWM_PIN      (11)  // Arduino D11 pin

volatile uint16_t ovf_count  = 0;
volatile uint8_t  edge_count = 0;
volatile boolean  done   = false;
volatile uint32_t saved_ticks[2] = {0,0};

ISR(TIMER1_OVF_vect) { 
   ovf_count++; // Increment Timer1 overflow counter
}

// Initialize Timer1
void init_timer1() {
   uint8_t SREG_tmp = SREG;  // Save the status register
   ovf_count = 0;            // Reset overflow counter
   cli();                    // Disable interrupts
   TIMSK1 = 0;
   TCNT1  = 0;               // Reset Timer1 count register
   TCCR1A = 0;
   TCCR1B = 0;
   TIFR1 |= _BV(TOV1);       // Clear Timer1 overflow flag
   // Use Timer1 in Normal mode, f_CPU/8: 16MHz/8=2MHz =&gt; 0.5usec step
   TIMSK1 |= (1&lt;&lt;TOIE1);     // Enable Timer1 overflow interrupt
   TCCR1B |= (1&lt;&lt;CS11);      // Start Timer1 
   SREG = SREG_tmp;          // Restore the status register
}

void ext_isr() { // ISR for External Interrupt
  static uint32_t saved_value;
  uint32_t tickcount = get_tickcount();
  if (!done) {
    if (edge_count==1) {
      saved_ticks[0] = tickcount;
    }
    else if (edge_count==5) {
      saved_ticks[1] = tickcount;
      done = true;
    }
    edge_count++; // Increment the rising-edge counter
  }
}

// Get the current value of Timer1 counter (with 0.5usec precision)
uint32_t get_tickcount() { 
   // Save the SREG register
   uint8_t SREG_tmp = SREG;
   // Disable global interrupt
   cli();
   // Read the current value of TCNT1 register of Timer1 
   uint16_t count_value = TCNT1;
   // In normal operation the Timer/Counter Overflow Flag (TOV1)
   // will be set in the same clock cycle as the TCNT1 becomes zero.
   if ( TIFR1 &amp; _BV(TOV1) ) { // Check Timer1 overflow flag
      TIFR1 |= _BV(TOV1);     // Clear overflow flag
      ++ovf_count;            // Increment the overflow counter
   }
   // Calculate Timer1 tick count
   uint32_t ticks = ovf_count;
   ticks = ((ticks &lt;&lt; 16) + count_value);
   // Restore the SREG register
   SREG = SREG_tmp;
   return ticks;
}

void measure( uint32_t *period, uint32_t *freq ) {
  // Save the current values of TCCR0A/B
  uint8_t TCCR0A_tmp = TCCR0A;
  uint8_t TCCR0B_tmp = TCCR0B;
  uint32_t tick_diff;
  // Set TCCR0A/B registers to 0 (disable Timer0)
  TCCR0A = 0;
  TCCR0B = 0;
  edge_count = 0;
  done = false;
  ovf_count = 0;
  // Wait until the done flag is set.
  while (!done){}
  tick_diff = saved_ticks[1] - saved_ticks[0];
  // Restore the saved values of TCCR0A/B
  TCCR0A = TCCR0A_tmp;
  TCCR0B = TCCR0B_tmp;
  *period = 10*tick_diff/8;
  *period -= 25*(*period)/10000; // Correction
  *freq = 100*1000000ul/(*period);
}

void set_timer2_prescaler( uint16_t prescaler ) {
  uint8_t bits = 0;  // CS[2:0] bits
  switch (prescaler) {
    case 1:    bits = 1; break; // 0b001
    case 8:    bits = 2; break; // 0b010
    case 32:   bits = 3; break; // 0b011
    case 64:   bits = 4; break; // 0b100
    case 128:  bits = 5; break; // 0b101
    case 256:  bits = 6; break; // 0b110
    case 1024: bits = 7; break; // 0b111
    default:   break; // Timer stopped
  }
  TCCR2B &amp;= ~(_BV(CS22) | _BV(CS21) | _BV(CS20));
  if (bits &amp; 1)  { TCCR2B |= _BV(CS20); }
  if (bits &amp; 2)  { TCCR2B |= _BV(CS21); }
  if (bits &amp; 4)  { TCCR2B |= _BV(CS22); }
}

void init_timer2_pwm( uint16_t prescaler, uint8_t max_value ) {
  DDRB |= _BV(DDB3); // Set direction of PB3 pin to output.
  // Use Fast PWM (non-inverting) with 50% duty cycle
  // Enable Timer2 OC2A output for PWM
  // WGM2[2:0]  = &quot;111&quot; =&gt; BOTTOM=0, TOP=OCR2A
  // COM2A[1:0] = &quot;01&quot;  =&gt; Toggle OC2A on compare match.
  TCCR2A = _BV(WGM21) | _BV(WGM20) | _BV(COM2A0); 
  TCCR2B = _BV(WGM22);
  set_timer2_prescaler( prescaler );
  OCR2A  = max_value; // Set the MAX value for period
}

void setup() {
  Serial.begin( 115200 );
  Serial.println( &quot;Frequency Measurement with Arduino Board&quot; );
  init_timer1();
  // freq. = 16MHz/(8*10)/2  = 100kHz
  // freq. = 16MHz/(8*256)/2 = 3906.Hz
  // Use Timer2 to create a PWM signal, frequency of 100kHz
  init_timer2_pwm( 8, 10-1 );
  delay(100);
  // Enable the external interrupt
  attachInterrupt( digitalPinToInterrupt(FREQ_PIN), 
                   ext_isr, RISING );
}

void loop() {
  static char sbuf[40];
  uint32_t period, freq;
  // Measure the period and frequency of the input signal
  measure( &amp;period, &amp;freq ); 
  // The period value must be divided by 10.
  sprintf( sbuf, &quot;Period = %lu.%1u us, &quot;, 
           period/10, period%10 );
  Serial.print( sbuf );
  // The frequency value must be divided by 10.
  sprintf( sbuf, &quot;Freq. = %lu.%1u Hz&quot;, 
           freq/10, freq%10 );
  Serial.println( sbuf );
  delay(1000);
}
</code></pre>
<p><img alt="" src="wokwi_freq_100khz_sim.png" /></p>
<p>รูป: ตัวอย่างการจำลองการทำงานของโค้ดด้วย <strong>Wokwi Simulator</strong> สำหรับความถี่ <strong>PWM</strong>
เท่ากับ <strong>100kHz</strong> (มีคาบเท่ากับ 10 ไมโครวินาที)</p>
<p><img alt="" src="freq_100khz_sim.png" /></p>
<p>รูป: การแสดงสัญญาณเอาต์พุตที่มีการบันทึกได้จากการใช้ <strong>Virtual Logic Analyzer</strong> 
ของ <strong>Wokwi Simulator</strong></p>
<p><img alt="" src="arduino_test-1.png" /></p>
<p>รูป: ตัวอย่างการทดสอบกับอุปกรณ์จริง (ความถี่ของสัญญาณ <strong>PWM=100kHz</strong>) </p>
<p><img alt="" src="arduino_test-2.png" /></p>
<p>รูป: ตัวอย่างการทดสอบกับอุปกรณ์จริง (สร้างสัญญาณภายนอกโดยใช้ <strong>Function Generator</strong> ความถี่ <strong>125kHz</strong>) </p>
<p><img alt="" src="arduino_test-3.png" /></p>
<p>รูป: ตัวอย่างการทดสอบกับอุปกรณ์จริง (สร้างสัญญาณภายนอกโดยใช้ <strong>Function Generator</strong> ความถี่ <strong>50Hz</strong>) </p>
<p>&nbsp;</p>
<hr />
<h2 id="2">&#9655; <strong>ตัวอย่างโค้ดที่ 2</strong><a class="headerlink" href="#2" title="Permanent link">#</a></h2>
<p>ตัวอย่างนี้สาธิตการใช้วงจร <strong>Timer1</strong> โดยมีการใช้สัญญาณดิจิทัล-อินพุตจากภายนอกมาเป็นสัญญาณ
<strong>Clock</strong> สำหรับกำหนดจังหวะการนับของวงจรดังกล่าว และมีการเปิดใช้งานวงจร <strong>Timer2</strong>
ซึ่งทำให้เกิดอินเทอร์รัพท์ทุก ๆ 1 มิลลิวินาที เพื่อกำหนดช่วงเวลาในการนับของวงจร <strong>Timer1</strong>
เช่น กำหนดช่วงเวลาเท่ากับ 1000 มิลลิวินาที สำหรับการนับจำนวนพัลส์ที่เกิดขึ้นกับสัญญาณอินพุตของ <strong>Timer1</strong>
เมื่อได้จำนวนพัลส์ (เก็บค่าไว้ในตัวแปร <code>pulse_count</code>) ที่เกิดขึ้นในช่วง 1000 มิลลิวินาที
ก็จะถูกนำไปคำนวณเป็นความถี่ (หน่วยเป็น <strong>Hz</strong>)</p>
<p>รีจิสเตอร์ตัวนับของ <strong>Timer1</strong> มีขนาด 16 บิต และถ้านับด้วยความถี่สูง ก็มีโอกาสที่จะเกิด
<strong>Overflow</strong> ได้ ดังนั้นจึงตัองมีการตรวจสอบและบันทึกจำนวนครั้งของเหตุการณ์ดังกล่าวที่เกิดขึ้น
(เก็บค่าไว้ในตัวแปร <code>ovf_count</code>)</p>
<p>ในตัวอย่างนี ยังได้มีการสร้างสัญญาณ <strong>PWM</strong> ที่มีเอาต์พุตออกที่ขา <strong>D6</strong> (ใช้วงจร <strong>Timer0</strong>)
โดยใช้คำสั่ง `analogWrite(...) แล้วนำไปป้อนเป็นอินพุตให้ขา <strong>D5</strong> ในกรณีที่ไม่มีสัญญาณทดสอบจากภายนอก</p>
<pre><code class="language-c++">#define  FREQ_PIN (5)  // Arduino D5 pin (T1 pin)

volatile uint16_t ovf_count  = 0;
volatile uint32_t pulse_count = 0;
volatile uint16_t interval_tick_count = 0;
volatile boolean  done = false;

void start_timers( uint16_t msec ) {
  uint8_t SREG_tmp = SREG; // Save the SREG value
  done = false;
  ovf_count = 0;
  interval_tick_count = msec; 

  cli(); // Disable global interrupt  
  // Disable Timer1
  TCCR1A = 0;  // Reset Timer1 control register A
  TCCR1B = 0;  // Reset Timer1 control register B 
  TCNT1  = 0;  // Reset Timer1 counter value to 0
  TIFR1 |= (1&lt;&lt;TOV1);    // Clear Timer/Counter 1 overflow flag
  TIMSK1 &amp;= ~(1&lt;&lt;TOIE1); // Disable Timer1 Overflow Interrupt 

  // Disable Timer2
  TCCR2A = 0;  // Reset Timer2 control register A
  TCCR2B = 0;  // Reset Timer2 control register B  
  TCNT2 = 0;   // Reset Timer2 counter value to 0

  // Setup Timer2
  // Set Timer2 prescaler = 128 -&gt; 16MHz/128 = 125kHz
  TCCR2B |= (1&lt;&lt;CS22) | (1&lt;&lt;CS20); 
  // Use Timer2 in CTC (Clear Timer on Compare Match) mode 
  // -&gt; WGM22=0, WGM21=1, WGM20=0
  // Note that in CTC mode the counter is automatically cleared to zero
  // when the counter value (TCNT2) matches the OCR2A.
  OCR2A  = 125-1; // -&gt; 16MHz/128/125 = 1kHz or 1msec timing interval
  TIMSK2 |= (1&lt;&lt;OCIE2A); // Enable Timer2 Output Compare Match A Interrupt

  // Setup Timer1 and use external clock source (rising edge) on T1 pin
  // Timer1 will be used to count events on the T1 pin (Arduino D5 pin).
  // It will operate in normal mode (WGM1[3:0]=&quot;0000&quot;), no interrupt.
  TCCR1B |= (1&lt;&lt;CS12) | (1&lt;&lt;CS11) | (1&lt;&lt;CS10); // Start Timer1
  TCCR2A |= (1&lt;&lt;WGM21);  // Start Timer2 in CTC mode
  SREG = SREG_tmp;       // Restore the SREG value
}

ISR(TIMER2_COMPA_vect) { // for Timer2 Output Compare Match A Interrupt
  pulse_count = TCNT1;
  if ( TIFR1 &amp; (1&lt;&lt;TOV1) ) { // Check overflow
     TIFR1 |= (1&lt;&lt;TOV1);     // Clear Timer/Counter 1 overflow flag
     ovf_count++;            // Increment Timer1 overflow count
  }
  if (interval_tick_count-- == 0) {  // Timeout
     TCCR1A = 0;  // Reset Timer1 control register A
     TCCR1B = 0;  // Reset Timer1 control register B 
     TCCR2A = 0;  // Reset Timer2 control register A
     TCCR2B = 0;  // Reset Timer2 control register B 
     pulse_count = ((uint32_t)ovf_count &lt;&lt; 16) + pulse_count; 
     done = true;
  }
}

uint32_t measure() {
  start_timers( 1000 /*msec*/ ); // Start Timer1/Timer2
  while( !done ) {} // Wait until the done flag is set
  return pulse_count; // pulses per second (Hz)
}

void setup() {
  Serial.begin( 115200 );
  Serial.println( &quot;Arduino Frequency Measurement&quot; );
   // Create a PWM signal (50% duty cycle) on Arduino D6 pin
   // Default PWM frequency = 16 Mhz/64/256 = 976.56Hz
  analogWrite( 6, 127 );
  delay(100);
}

void loop() {
  static char sbuf[40];
  uint32_t freq = measure();
  sprintf( sbuf, &quot;Freq. = %lu Hz&quot;, freq );
  Serial.println( sbuf );
  delay(10);
}
</code></pre>
<p><img alt="" src="wokwi_pwm_sim.png" /></p>
<p>รูป: การจำลองการทำงานด้วย <strong>Wokwi Simulator</strong></p>
<p><img alt="" src="pwm_oscilloscope.png" /></p>
<p>รูป: การวัดสัญญาณเอาต์พุต <strong>PWM</strong> ที่ขา <strong>D6</strong> โดยใช้เครื่องออสซิลโลสโคป</p>
<p><img alt="" src="arduino_test-4.png" /></p>
<p>รูป: ตัวอย่างการทดสอบกับอุปกรณ์จริง (วัดความถี่ของสัญญาณ <strong>PWM</strong> ที่ขา <strong>D6</strong>)</p>
<p><img alt="" src="wave_logic_analyzer_pwm_d6_pin.png" /></p>
<p>รูป: ตัวอย่างการวัดสัญญาณด้วย <strong>USB Logic Analyzer</strong> และแสดงผลด้วยซอฟต์แวร์ <strong>PulseView</strong>
(วัดคาบได้ประมาณ <strong>1022.67 usec</strong> และความถี่ประมาณ<strong>977.83 Hz</strong>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="_2">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_2" title="Permanent link">#</a></h2>
<p>บทความนี้ได้นำเสนอตัวอย่างโค้ด <strong>Arduino Sketch</strong> และวิธีการวัดความถี่หรือคาบของสัญญาณ โดยใช้สองวิธีที่แตกต่างกัน
ซึ่งมีการเปิดใช้งานวงจรตัวนับ (<strong>Timers</strong>) ที่อยู่ภายในชิป <strong>ATmega328P</strong>
และมีการสร้างสัญญาณ <strong>PWM</strong> เพื่อใช้เป็นสัญญาณทดสอบ หากไม่มีอุปกรณ์ที่สามารถสร้างสัญญาณทดสอบจากภายนอก</p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2023-04-08 | Last Revision: 2023-05-05</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
