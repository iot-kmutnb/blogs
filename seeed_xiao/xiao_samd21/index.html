<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/seeed_xiao/xiao_samd21/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>การเขียนโปรแกรม Arduino สำหรับบอร์ดไมโครคอนโทรลเลอร์ Seeeduino XIAO (SAMD21) - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#arduino-seeeduino-xiao-samd21" class="nav-link">การเขียนโปรแกรม Arduino สำหรับบอร์ดไมโครคอนโทรลเลอร์ Seeeduino XIAO (SAMD21)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#seeed-studio-xiao" class="nav-link">&#9655; Seeed Studio XIAO</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#arduino-ide" class="nav-link">&#9655; การเขียนโปรแกรมด้วย Arduino IDE</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#digital-output-pwm-output" class="nav-link">&#9655; โค้ดตัวอย่าง: Digital Output / PWM Output</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#push-button-digital-input-sampling" class="nav-link">&#9655; โค้ดตัวอย่าง: Push Button &amp; Digital Input Sampling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#analog-input-reading-adc" class="nav-link">&#9655; โค้ดตัวอย่าง: Analog Input Reading (ADC)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#analog-output-dac-and-analog-input-adc" class="nav-link">&#9655; โค้ดตัวอย่าง: Analog Output (DAC) and Analog Input (ADC)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#i2c-master-bh1750-light-sensor-reading" class="nav-link">&#9655; โค้ดตัวอย่าง: I2C Master &amp; BH1750 Light Sensor Reading</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#external-interrupt-rotary-encoder-switch" class="nav-link">&#9655; โค้ดตัวอย่าง: External Interrupt &amp; Rotary Encoder Switch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hc-sr04p-ultrasonic-distance-sensor" class="nav-link">&#9655; โค้ดตัวอย่าง: HC-SR04P Ultrasonic Distance Sensor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="arduino-seeeduino-xiao-samd21">การเขียนโปรแกรม Arduino สำหรับบอร์ดไมโครคอนโทรลเลอร์ Seeeduino XIAO (SAMD21)<a class="headerlink" href="#arduino-seeeduino-xiao-samd21" title="Permanent link">#</a></h1>
<hr />
<h2 id="seeed-studio-xiao">&#9655; <strong>Seeed Studio XIAO</strong><a class="headerlink" href="#seeed-studio-xiao" title="Permanent link">#</a></h2>
<p>บทความนี้กล่าวถึง การใช้งานและการเขียนโปรแกรม <strong>Arduino</strong> สำหรับบอร์ดไมโครคอนโทรลเลอร์ในตระกูล 
<strong>XIAO</strong> ที่ใช้ชิป <strong>SAMD21</strong></p>
<p>บอร์ดในตระกูล <strong>XIAO</strong> ของบริษัท <strong>Seeed Studio</strong> จากประเทศจีน มีขนาดเล็ก
และมีการเลือกใช้ชิปไมโครคอนโทรลเลอร์ 32 บิต หลายแบบ เช่น </p>
<ul>
<li><strong>SAMD21 (Arm Cortex-M0+)</strong></li>
<li><strong>RP2040 (Arm Cortex-M0+, Dual-Core)</strong></li>
<li><strong>nRF52840 (Arm Cortex-M4F)</strong></li>
<li><strong>ESP32-C3 (RISC-V)</strong></li>
<li><strong>ESP32-S3 (Xtensa LX7)</strong></li>
</ul>
<p>บอร์ดในตระกูล <strong>XIAO</strong> มีลักษณะเหมือนกันคือ</p>
<ul>
<li>บอร์ดมีขนาดเล็ก (<strong>Small Form Factor</strong>) มีขนาดโดยประมาณ <strong>22 x 18 mm.</strong></li>
<li>สามารถนำไปบัดกรีขา <strong>Pin Header</strong> และเสียบขาลงบนเบรดบอร์ดได้ง่าย</li>
<li>มีคอนเนกเตอร์สำหรับ <strong>USB</strong> แบบ <strong>Type-C</strong></li>
<li>ไม่มีชิป <strong>USB-to-Serial Bridge</strong> 
เนื่องจากชิปไมโครคอนโทรลเลอร์ตามที่ได้กล่าวไป รองรับการใช้งาน <strong>Native USB 2.0</strong></li>
<li>บอร์ดบางรุ่น มีวงจรชาร์จแบตเตอรีลิเธียม (<strong>Single-cell Lithium Battery Charger</strong>) 
บางรุ่นก็มี <strong>RGB LED</strong> อยู่บนบอร์ดด้วย</li>
</ul>
<p><img alt="" src="xiao_samd21_pinout.png" /></p>
<p>รูป: แผนผังแสดงตำแหน่งของขาต่าง ๆ บนบอร์ด <strong>XIAO SAMD21</strong> (Source: SeeedStudio)</p>
<p>บอร์ดรุ่นแรกในตระกูล <strong>XIAO</strong> คือ
<a href="https://wiki.seeedstudio.com/Seeeduino-XIAO/"><strong>Seeeduino XIAO SAMD21</strong></a> 
มีคุณสมบัติดังนี้</p>
<ul>
<li>ทางบริษัทได้เปิดตัวบอร์ดในช่วงปลายปี ค.ศ. <strong>2019</strong> <ul>
<li>แต่มีข้อสังเกตว่า ชิป <strong>SAMD21</strong> มีการใช้งานมาตั้งแต่ปี <strong>2012</strong>  และหลายปีที่ผ่านมา
ก็มีบอร์ดไมโครคอนโทรลเลอร์ที่ใช้ชิปดังกล่าวออกมาสู่ตลาด
เช่น บอร์ด <strong>Arduino MKR Family</strong>, <strong>Adafruit Feather M0</strong>, 
<strong>Adafruit Circuit Playground</strong> เป็นต้น
และชิปรุ่นนี้ได้รับความนิยมน้อยลงในปัจจุบันเมื่อเปรียบเทียบกับชิปไมโครคอนโทรลเลอร์รุ่นใหม่ ๆ </li>
</ul>
</li>
<li>มีราคาประมาณ <strong>$US 5</strong> (ประมาณ THB 250.00 จากการสำรวจสินค้าบนเว็บไซต์ในประเทศไทย)</li>
<li>ใช้ชิปไมโครคอนโทรลเลอร์ <strong>Atmel/Microchip AT-SAMD21G18-MU</strong><ul>
<li>ภายในมีตัวประมวลผล <strong>32-bit ARM Cortex M0+ (48MHz)</strong> </li>
<li>มีหน่วยความจำภายใน <strong>256KB Flash</strong> และ <strong>32KB SRAM</strong> </li>
<li>เน้นการทำงานแบบใช้พลังงานต่ำ (<strong>Low-Power Application</strong>)</li>
</ul>
</li>
<li>มีขา <strong>GPIO</strong> ใช้เป็นขาดิจิทัลได้ ทำงานที่ระดับแรงดันสำหรับลอจิกไม่เกิน <strong>VCC=3.3V</strong> <ul>
<li><strong>Digital I/O: D0 ~ D10 pins</strong></li>
</ul>
</li>
<li>ภายในชิปมีวงจร <strong>12-bit, 350ksps ADC (Analog-to-Digital Converter)</strong>
  และ <strong>10-bit, 350 ksps DAC (Digital-to-Analog Converter)</strong><ul>
<li><strong>ADC Input: A0 ~ A10 pins</strong>
รับอินพุตในช่วง <strong>0V ~ 3.3V</strong> และให้ค่าตัวเลขในช่วง <strong>0 ~ 4095</strong></li>
<li><strong>DAC Output</strong> จำนวน 1 ขา (<strong>A0/D0 pin</strong>) 
ใช้ค่าตัวเลขในช่วง <strong>0 ~ 1023</strong> และมีแรงดันไฟฟ้าเอาต์พุตในช่วง <strong>0V ~ 3.3V</strong></li>
</ul>
</li>
<li>มีวงจรแปลงและควบคุมระดับแรงดันไฟฟ้าจากขา <strong>5V (VIN)</strong> ให้เป็น <strong>3.3V</strong><ul>
<li>ใช้ไอซี <strong>XC6206P33MR LDO Voltage Regulator</strong></li>
</ul>
</li>
<li>มีขาเชื่อมต่อกับวงจรภายนอกสำหรับ <strong>I2C</strong>, <strong>SPI</strong> และ <strong>SPI</strong> อย่างละหนึ่งชุด ได้แก่<ul>
<li><strong>I2C: D5=SCL, D4=SDA pins</strong></li>
<li><strong>UART: D6=TX, D7=RX pins</strong></li>
<li><strong>SPI: D7=SS, D8=SCK, D9=MISO, D10=MOSI pins</strong></li>
</ul>
</li>
<li>มี <strong>LED</strong> บนบอร์ดดังนี้<ul>
<li><strong>Power LED (Green)</strong> </li>
<li><strong>User LED (Orange): D13 pin</strong></li>
<li><strong>Tx &amp; Rx LEDs (Blue): D11 &amp; D12 pins</strong>
ถ้ามีการรับหรือส่งข้อมูลผ่าน <strong>Serial</strong> จะเห็นสังเกตเห็นการกระพริบของ <strong>LED</strong> สีน้ำเงิน</li>
</ul>
</li>
<li>มีขาอยู่ด้านล่างของบอร์ดเป็นแบบ <strong>Soldering Pads</strong> สำหรับ <strong>SWD Interface</strong><ul>
<li>มี 4 จุด ได้แก่ <strong>SWCLK, SWDIO, RESET, GND</strong> ตามลำดับ</li>
</ul>
</li>
<li>มีการติดตั้งเฟิร์มแวร์ <a href="https://github.com/Seeed-Studio/ArduinoCore-samd/tree/master/bootloaders/XIAOM0"><strong>Arduino-Compatible USB-Serial /
UF2 Bootloader</strong></a> มาให้แล้ว <ul>
<li>ใช้วิธีลากไฟล์เฟิร์มแวร์ <strong>.uf2</strong> ไปยังไดร์ฟ (ชื่อ <code>Arduino</code>) เพื่ออัปโหลดเฟิร์มแวร์</li>
<li>ถ้าเป็นไฟล์ <strong>.hex / .bin</strong> จะต้องมีการแปลงให้เป็นไฟล์ <strong>.uf2</strong> ก่อนนำไปใช้</li>
</ul>
</li>
<li>ข้อจำกัดในการใช้งานบอร์ด <strong>XIAO</strong> มีดังนี้<ul>
<li>เหมาะสำหรับผู้ใช้ต้องการใช้บอร์ดขนาดเล็ก และมีจำนวนขา <strong>I/O</strong> ไม่มาก</li>
<li>ไม่มีวงจร <strong>WiFi / BLE</strong> สำหรับการสื่อสารข้อมูลแบบไร้สาย</li>
<li>ไม่มีปุ่มกด <strong>RESET</strong> อยู่บนบอร์ด หากต้องการรีเซต หรือ เข้าสู่โหมด <strong>Bootloader</strong> 
จะต้องใช้ปลายสายไฟสองด้านสัมผัสที่ <strong>Soldering Pads</strong> บนบอร์ด 
สำหรับขา <strong>RESET</strong> และ <strong>GND</strong> การสัมผัสสองครั้งในระยะเวลาสั้น ๆ เป็นเหมือนการกดปุ่มรีเซตแบบ <strong>Double Click</strong>
ซึ่งจะทำให้ชิปไมโครคอนโทรลเลอร์เข้าสู่ <strong>Bootloader Mode</strong></li>
</ul>
</li>
<li>เมื่ออยู่ในโหมด <strong>Bootloader</strong> จะมองเห็นพอร์ต <strong>Serial</strong> ได้เช่นกัน และถ้ามีการใช้ <code>SerialUSB</code>
ในการเขียนโค้ด <strong>Arduino</strong> เพื่อเปิดใช้งาน <strong>USB CDC</strong> ก็จะมองเห็นพอร์ต <strong>Serial</strong> ได้ แต่มีหมายเลขพอร์ตต่างกันได้</li>
</ul>
<p><img alt="" src="xiao_soldering_pads.png" /></p>
<p>รูป: ตำแหน่งของ <strong>Soldering Pads</strong> ที่อยู่ด้านล่าง (<strong>Bottom Side</strong>)
ของบอร์ด <strong>XIAO</strong> เวอร์ชันเก่า และ เวอร์ชันใหม่ (Source: SeeedStudio)</p>
<p><img alt="" src="xiao_reset_pads.png" /></p>
<p>รูป: การรีเซตบอร์ด หรือการทำให้เข้าสู่โหมด <strong>Bootloader</strong> โดยการเชื่อมต่อระหว่างขา <strong>Reset Pad</strong> 
และ <strong>GND Pad</strong> (Source: SeeedStudio) </p>
<p>&nbsp;</p>
<p><img alt="" src="samd21_uf2_drive.png" /></p>
<p>รูป: การมองเห็นไดร์ฟในระบบปฏิบัติการ <strong>Windows 10</strong> เมื่อเชื่อมต่อกับบอร์ด <strong>XIAO</strong>
ที่อยู่ในโหมด <strong>UF2 Bootloader</strong></p>
<p>ตัวเลือกสำหรับการเขียนโปรแกรมได้แก่</p>
<ul>
<li>การใช้ซอฟต์แวร์ <a href="https://www.microchip.com/en-us/tools-resources/develop/microchip-studio"><strong>Microchip Studio IDE</strong></a> สำหรับภาษา <strong>C/C++</strong></li>
<li>การเขียนโปรแกรม <strong>Arduino Sketch</strong> ด้วย <a href="https://www.arduino.cc/en/software"><strong>Arduino IDE</strong></a></li>
<li>ภาษาอื่นเป็นตัวเลือก เช่น <ul>
<li><a href="https://wiki.seeedstudio.com/Seeeduino-XIAO-CircuitPython/"><strong>Adafruit CircuitPython - XIAO</strong></a></li>
<li><a href="https://micropython.org/download/SEEED_XIAO/"><strong>MicroPython - XIAO</strong></a></li>
<li><a href="https://github.com/atsamd-rs/atsamd/tree/master/boards"><strong>Embedded Rust for SAMD21 / D51</strong></a></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="arduino-ide">&#9655; <strong>การเขียนโปรแกรมด้วย Arduino IDE</strong><a class="headerlink" href="#arduino-ide" title="Permanent link">#</a></h2>
<p>ถัดไปเป็นขั้นตอนการติดตั้ง  <a href="https://github.com/Seeed-Studio/ArduinoCore-samd"><strong>Arduino Core for SAMD21 / D51</strong></a> 
สำหรับบอร์ด <strong>SeeedStudio XIAO</strong> เพื่อนำมาใช้กับซอฟต์แวร์ <strong>Arduino IDE v2.0.0</strong></p>
<p>เปิดใช้งาน <strong>Arduino IDE v2.0</strong> แล้วไปที่เมนู <strong>File &gt; Preferences</strong>
เพิ่มรายการ <strong>URL</strong> ลงในช่องข้อความ <strong>"Additional Boards Manager URLs"</strong> ดังต่อไปนี้
แล้วกดปุ่ม <strong>OK</strong></p>
<p><code>https://files.seeedstudio.com/arduino/package_seeeduino_boards_index.json</code></p>
<p>จากนั้นคลิกเลือกไอคอนทางซ้ายมือสำหรับ <strong>BOARD MANAGER</strong> แล้วค้นหาด้วยคำว่า
<strong>"Seeed SAMD"</strong> แล้วคลิกเลือกติดตั้งเวอร์ชันล่าสุด  (ทดลองใช้ <strong>v1.8.3</strong>)
โดยกดปุ่ม <strong>INSTALL</strong></p>
<p><img alt="" src="arduino_xiao_samd21_core.png" /></p>
<p>รูป: การติดตั้ง <strong>Arduino Core</strong> สำหรับ <strong>SeeedStudio XIAO SAMD21</strong></p>
<p>&nbsp;</p>
<p>ถัดไปให้เชื่อมต่อระหว่างคอมพิวเตอร์ผู้ใช้กับบอร์ด <strong>XIAO</strong> ด้วยสาย <strong>USB</strong>
หากเป็นการใช้งานครั้งแรก แนะนำให้เริ่มต้นด้วยการทำงานบอร์ด <strong>XIAO</strong> เข้าสู่โหมด <strong>Bootloader</strong>
ตามวิธีการที่ได้กล่าวถึงไปแล้ว จากนั้นจะมองเห็นหมายเลขพอร์ตอนุกรม
และเลือกบอร์ด <strong>Seeeduino XIAO</strong></p>
<p><img alt="" src="samd21_select_port.png" /></p>
<p>รูป: การเลือกหมายเลขพอร์ตที่เชื่อมต่อกับ <strong>XIAO SAMD21</strong> ใน <strong>Arduino IDE v2.0</strong></p>
<p>&nbsp;</p>
<p>ในส่วนถัดไปของบทความนี้ มีตัวอย่างโค้ด <strong>Arduino Sketches</strong> สาธิตและทดลองใช้งานบอร์ด <strong>XIAO</strong> มีดังนี้</p>
<ul>
<li><strong>Digital Output / PWM Output</strong>: 
สร้างสัญญาณเอาต์พุตแบบดิจิทัล และ <strong>PWM</strong>
สำหรับวงจร <strong>LEDs</strong></li>
<li><strong>Push Button &amp; Digital Input Sampling</strong>: 
อ่านอินพุตดิจิทัล และตรวจสอบสถานะการกดปุ่ม</li>
<li><strong>Analog Input Reading (ADC)</strong>: 
อ่านอินพุตแอนะล็อกโดยใช้วงจร <strong>ADC</strong> ภายในชิป <strong>SAMD21</strong></li>
<li><strong>Analog Output (DAC) and Analog Input (ADC)</strong>: 
สร้างสัญญาณแอนะล็อกเอาต์พุตโดยใช้วงจร <strong>DAC</strong> ภายในชิป และอ่านสัญญาณดังกล่าวเป็นอินพุตด้วย <strong>ADC</strong></li>
<li><strong>I2C Master &amp; BH1750 Light Sensor Reading</strong>: 
อ่านข้อมูลจากโมดูลเซนเซอร์วัดความเข้มแสง <strong>BH1750</strong> และเชื่อมต่อด้วยบัส <strong>I2C</strong></li>
<li><strong>External Interrupt &amp; Rotary Encoder Switch</strong>:
อ่านค่าอินพุตดิจิทัลและตรวจสอบการหมุนปุ่มของโมดูล <strong>Rotary Encoder</strong> เพื่อเพิ่มหรือลดค่าตัวนับ
และสาธิตการใช้งานอินเทอร์รัพท์ภายนอก</li>
<li><strong>HC-SR04P Ultrasonic Distance Sensor</strong>: 
อ่านค่าระยะห่างจากวัตถุกีดขวางโดยใช้โมดูลเซนเซอร์อัลตราโซนิก <strong>HC-SR04P</strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="digital-output-pwm-output">&#9655; <strong>โค้ดตัวอย่าง: Digital Output / PWM Output</strong><a class="headerlink" href="#digital-output-pwm-output" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างแรกเป็นการทดสอบการทำงานของบอร์ด <strong>Seeeduino XIAO</strong>
โดยทำให้ <strong>LED</strong> 2 ดวง (ขา <strong>D11</strong> และ <strong>D12</strong>) ที่อยู่บนบอร์ด
เกิดการกระพริบหลายครั้งในช่วงเวลาหนึ่ง โดยใช้คำสั่ง <code>digitalWrite()</code>
กำหนดสถานะเอาต์พุต และมีการสร้างสัญญาณ <strong>PWM</strong> โดยใช้คำสั่ง <code>analogWrite(...)</code>
ของ <strong>Arduino API</strong>
เพื่อใช้ในการปรับความสว่างของ <strong>LED</strong> (ขา <strong>D12</strong>) และมีการเปลี่ยนค่าไปทุก ๆ 4 มิลลิวินาที</p>
<p>ในโค้ดตัวอย่างมีการใช้คำสั่ง <code>analogWriteResolution(...)</code> 
เพื่อกำหนดจำนวนบิตที่ต้องการใช้และอยู่ในช่วง <strong>8 .. 12 บิต</strong>
จำนวนบิตนี้จะเป็นตัวกำหนดช่วงของค่าตัวเลขที่จะนำไปใช้กับคำสั่ง <code>analogWrite(...)</code> ถ้าเป็น 12 บิต
ก็ใช้ตัวเลขในช่วง <strong>0 .. 4095</strong> สำหรับการตั้งค่า <strong>PWM Duty Cycle</strong> แต่ถ้าเป็น 8 บิต 
ก็จะมีค่าอยู่ในช่วง  <strong>0 .. 255</strong> เป็นต้น</p>
<p>ในตัวอย่างนี้ได้กำหนดให้ค่า <strong>PWM Duty Cycle</strong> เพิ่มขึ้นไปจนถึงค่าสูงสุด <strong>4095</strong> แล้วลดลงไปจนถึง <strong>0</strong>
ดังนั้นจะเห็นว่า  <strong>LED</strong> มีความสว่างเพิ่มขึ้นจนสูงสุดแล้วจึงลดลง แล้วเกิดขึ้นซ้ำไปเรื่อย ๆ</p>
<p><strong>Arduino Sketch: Dual-LED Blink &amp; PWM-based LED Fading</strong></p>
<pre><code class="language-cpp">// Target board: Seeeduino XIAO SAMD21
#define PWM_LED_PIN  (13)  // D13 pin (onboard Orange USER LED, active-low)
#define TX_LED_PIN   (12)  // D12 pin (onboard Blue TX LED, activew-low)
#define RX_LED_PIN   (11)  // D11 pin (onboard Blue RX LED, active-low)

#define LED_ON          (0)
#define LED_OFF         (1)
#define TIMEOUT_MS      (4000)
#define PWM_RESOLUTION  (12)

const int COUNTER_MAX = (1&lt;&lt;PWM_RESOLUTION);
int counter = COUNTER_MAX-1;
uint32_t ts; // timestamp

void toggle_leds( int n=10 ) {
   int state = 1;
   for ( int i=0; i &lt; n; i++ ) {
     state = !state;
     digitalWrite( TX_LED_PIN, !state );
     digitalWrite( RX_LED_PIN, state  );
     delay( 100 );
   }
   digitalWrite( TX_LED_PIN, LED_OFF ); 
   digitalWrite( RX_LED_PIN, LED_OFF );  
}

String getSketchName( const char *fullpath ) {
  String str = fullpath;
  int pos = str.lastIndexOf(&quot;\\&quot;);
  if (pos &gt;= 0) {
    return str.substring(pos+1, str.length());
  }
  return str;
}

// Note: Serial is the same as SerialUSB.
void setup() {
   // Start the SerialUSB interface
   // Note: Serial is the same as SerialUSB.
   Serial.begin( 1000000);  // can be any value (ignored)
   // Wait for Arduino Serial Monitor to open.
   while ( !Serial );
   Serial.println( F(&quot;SAMD21 - Seeeduino XIAO board.&quot;) );
   Serial.print( F(&quot;Arduino Sketch: &quot;) );
   Serial.println( getSketchName( __FILE__ ) );
   Serial.println( F(&quot;Build time: &quot; __DATE__ &quot; &quot; __TIME__ ) );
   Serial.flush();
   // Show the CPU clock frequency (in MHz)
   Serial.printf( &quot;CPU clock: %lu MHz\r\n&quot;, 
                  (uint32_t)(SystemCoreClock/1e6) );
   Serial.flush();

   // Set pin directions for LED outputs
   pinMode( TX_LED_PIN, OUTPUT );
   pinMode( RX_LED_PIN, OUTPUT );
   pinMode( PWM_LED_PIN, OUTPUT );
   // Toggle onboard TX/RX LEDs.
   toggle_leds( 20 );

   // Set PWM resolution bits
   analogWriteResolution( PWM_RESOLUTION ); 
   analogWrite( PWM_LED_PIN, counter );
   ts = millis();
}

#define PWM_UPDATE_INTERVAL_MS  (4)

void loop() {
  uint32_t t_now = millis();
  if ( (t_now - ts) &gt;= PWM_UPDATE_INTERVAL_MS ) { 
     ts = t_now;      // Update the last PWM update timestamp
     counter += 8; // Increment counter
     if ( counter &gt;= (2*COUNTER_MAX) ) {
       counter = 0;
     }
     int brightness = (counter &gt;= COUNTER_MAX) ?  
                 (2*COUNTER_MAX - 1 - counter) : counter; 
     // Update the PWM duty cycle
     analogWrite( PWM_LED_PIN, brightness );  
  }
  yield();
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="push-button-digital-input-sampling">&#9655; <strong>โค้ดตัวอย่าง: Push Button &amp; Digital Input Sampling</strong><a class="headerlink" href="#push-button-digital-input-sampling" title="Permanent link">#</a></h2>
<p>ตัวอย่างโค้ดถัดไปสาธิตการตรวจสอบการเปลี่ยนแปลงสถานะของอินพุต-ดิจิทัลที่ได้จากการต่อวงจรปุ่มกดภายนอก
(<strong>Push Button</strong>) และทำงานแบบ <strong>Active-Low</strong>
(เปิดใช้งานตัวต้านทานภายในแบบ <strong>Internal PullUp</strong>) โดยเลือกใช้ขา <strong>D2</strong> ของบอร์ด <strong>XIAO</strong> </p>
<p>การอ่านค่าบิตจากขาอินพุต จะใช้คำสั่ง <code>digitalRead(...)</code> ทุก ๆ 5 มิลลิวินาที แล้วนำไปเก็บไว้ในตัวแปร
<code>btn_bits</code> ขนาด 8 บิต โดยการเลื่อนบิตข้อมูลเดิมไปทางซ้ายหนึ่งตำแหน่ง และเขียนค่าบิตใหม่ลงในตำแหน่งบิต <strong>LSB</strong>
จากนั้นจะมีการตรวจสอบค่าของตัวแปร ดูว่ามีการเปลี่ยนแปลงจากค่าเริ่มต้นคือ <code>0xFF</code> ไปเป็น <code>0xF0</code> แล้วหรือไม่
ถ้ามีค่าดังกล่าว ก็หมายความว่า จากการอ่านพุตหลายครั้งตามลำดับ ได้ค่าลอจิกเป็น <strong>0 (Low)</strong> ซึ่งเกิดจากการกดปุ่ม</p>
<pre><code class="language-cpp">#define BTN_PIN  (2)   // use D2 pin
#define LED_PIN  (12)  // use D12 pin (onboard)

void setup() {
  Serial.begin(1000000);
  while (!Serial);
  pinMode( LED_PIN, OUTPUT );
  pinMode( BTN_PIN, INPUT_PULLUP );
}

#define SAMPLING_MSEC  (5)

void loop() {
  static uint32_t ts_saved = 0, ts_now;
  static uint32_t ts_last_event = 0;
  static uint32_t btn_count = 0;
  static uint8_t  btn_bits = 0xff;

  ts_now = millis();
  if ( (ts_now - ts_saved) &gt;= SAMPLING_MSEC ) { // periodic input sampling
    // Save the timestamp for the next periodic sampling.
    ts_saved = ts_now; 
    // Update input bit patterns.
    btn_bits = (btn_bits&lt;&lt;1) | digitalRead(BTN_PIN);
    if ( btn_bits == 0xF0) { // A falling edge was detected.
      // Toggle the LED status.
      digitalWrite( LED_PIN, !digitalRead( LED_PIN) );
      Serial.printf( &quot;Button press: #%lu (%lu msec)\r\n&quot;, 
                      ++btn_count, (ts_now-ts_last_event) );
      // Update the timestamp of the last LED toggle action.
      ts_last_event = ts_now;
    }
  }
}
</code></pre>
<p><img alt="" src="samd21_button_press_output.png" /></p>
<p>รูป: ข้อความเอาต์พุตใน <strong>Arduino Serial Monitor</strong> จากการทดลอง เมื่อมีการกดปุ่มหลายครั้ง</p>
<p>&nbsp;</p>
<hr />
<h2 id="analog-input-reading-adc">&#9655; <strong>โค้ดตัวอย่าง:  Analog Input Reading (ADC)</strong><a class="headerlink" href="#analog-input-reading-adc" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นการเขียนโค้ด เพื่ออ่านค่าสัญญาณแอนะล็อกด้วยคำสั่ง <code>analogRead(...)</code>
ของ <strong>Arduino API</strong> 
จำนวน 3 ช่อง ตามลำดับ โดยเลือกใช้ขา <strong>A1, A2, A3</strong> 
และเลือกใช้ขนาดข้อมูล 12 บิต (<strong>0..4095</strong>) สำหรับการแปลงค่าโดยวงจร <strong>ADC</strong> ภายในชิป <strong>SAMD21</strong></p>
<p><strong>Arduino Sketch: 3-Channel Analog Input Readings</strong></p>
<pre><code class="language-cpp">const int SENSOR_PINS[] = {A1,A2, A3}; // Analog input pins
const size_t NUM_PINS = sizeof(SENSOR_PINS)/sizeof(int);
void setup() {
   Serial.begin(1000000);
   while (!Serial); 
   delay(100);
   analogReadResolution(12);
}

void loop() {
  static uint16_t values[ NUM_PINS ];
  // Read analog input channels
  for ( int i=0; i &lt; NUM_PINS; i++ ) {
    values[i] = analogRead( SENSOR_PINS[i] );
  }
  // Send analog input values to SerialUSB
  for ( int i=0; i &lt; NUM_PINS; i++ ) {
    Serial.printf( &quot;AIN%d: %u%s&quot;, i, values[i], 
                   (i &lt; (NUM_PINS-1) ? &quot;,&quot; : &quot;\r\n&quot;) );
  }
  Serial.flush();
  delay(100);
}
</code></pre>
<p>ในการป้อนสัญญาณแอนะล็อกเป็นอินพุต อาจใช้วิธีต่อวงจรแบ่งแรงดัน (<strong>Voltage Divider</strong>)
โดยใช้ตัวต้านทาน 4 ตัว นำมาต่ออนุกรมกัน แล้วเลือกวัดแรงดันไฟฟ้าที่อยู่ระหว่าง <strong>0V</strong> กับ <strong>3.3V</strong> 
ซึ่งมี 3 ตำแหน่งที่แตกต่างกัน และควรจะได้ค่าตัวเลขคงที่ แต่ในทางปฏิบัติจะมีความคลาดเคลื่อนเกิดขึ้นในการวัดค่าด้วย <strong>ADC</strong></p>
<p><img alt="" src="xiao_voltage_dividers.jpg" /></p>
<p>รูป: วงจรแบ่งแรงดันที่ใช้ตัวต้านทาน <strong>100&Omega;</strong> จำนวน 3 ตัว และ <strong>4.7k&Omega;</strong> อีก 1 ตัว นำมาต่ออนุกรมกัน</p>
<p><img alt="" src="samd21_3x_analog_read-1.png" /></p>
<p>รูป:  การแสดงกราฟจากข้อมูลที่อ่านจากขาแอนะล็อก 3 ช่องอินพุต (จากวงจรแบ่งแรงดัน) 
โดยใช้ <strong>Arduino Serial Plotter</strong> </p>
<p>หากมีโมดูลเซนเซอร์ที่ให้เอาต์พุตแบบแอนะล็อก 
และมีระดับแรงดันไฟฟ้าอยู่ในช่วง <strong>0V..3.3V</strong> ก็สามารถนำมาใช้ได้เช่นกัน
เช่น <strong>TEMT6000 Analog Light Sensor</strong> ซึ่งให้แรงดันเอาต์พุตขึ้นอยู่กับสภาพแสงแวดล้อม</p>
<p><img alt="" src="xiao_temt6000_sensors.jpg" /></p>
<p>รูป:  โมดูลเซนเซอร์แสง <strong>TEMT6000</strong> สำหรับทดลองอ่านค่าแอนะล็อก 3 ช่องสัญญาณ</p>
<p><img alt="" src="samd21_3x_analog_read-2.png" /></p>
<p>รูป:  การแสดงกราฟจากข้อมูลที่อ่านจากขาแอนะล็อก 3 ช่องอินพุต (จากโมดูลเซนเซอร์แสง <strong>TEMT6000</strong>) </p>
<p>&nbsp;</p>
<hr />
<h2 id="analog-output-dac-and-analog-input-adc">&#9655; <strong>โค้ดตัวอย่าง: Analog Output (DAC) and Analog Input (ADC)</strong><a class="headerlink" href="#analog-output-dac-and-analog-input-adc" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นตัวอย่างการเขียนโค้ดเพื่อสร้างสัญญาณแอนะล็อก 
โดยใช้วงจร  <strong>DAC</strong> ที่อยู่ภายในชิป <strong>SAMD21</strong> ดังนั้นจึงต้องเลือกใช้ขา
<strong>A0</strong> และไม่ใช่การสร้างสัญญาณ <strong>PWM</strong> เหมือนขาอื่น <strong>A1 ~ A10</strong></p>
<p>เมื่อนำสัญญาณนี้มาใช้เป็นอินพุตสำหรับวงจร <strong>ADC</strong> โดยการเชื่อมต่อด้วยลวดสายไฟ (<strong>Jumper Wire</strong>) หนึ่งเส้น
และทำได้ง่าย โดยใช้คำสั่ง <code>analogWrite(...)</code> และ <code>analogRead(...)</code>
ของ <strong>Arduino API</strong> ตามลำดับ</p>
<p>ในตัวอย่างนี้ได้กำหนดจำนวนบิตที่จะใช้กับ <strong>DAC</strong> และ <strong>ADC</strong> โดยใช้คำสั่ง
<code>analogWriteResolution(...)</code> และ <code>analogReadResolution(...)</code> ตามลำดับ</p>
<p>เมื่อกำหนดค่าเอาต์พุตให้ <strong>DAC</strong> แล้ว ก็เว้นระยะเวลาก่อนอ่านค่าอินพุตแล้วแปลงให้เป็นค่าตัวเลขสำหรับแรงดันไฟฟ้า
ในหน่วยเป็นมิลลิโวลต์ เมื่อใช้แรงดันอ้างอิง <strong>3.3V</strong> หรือ <strong>3300mV</strong></p>
<p><strong>Arduino Sketch: DAC - ADC Loopback</strong></p>
<pre><code class="language-cpp">#define ANALOG_OUT_PIN  (A0)  // use DAC output (PA02 pin)
#define ANALOG_IN_PIN   (A1)
#define ADC_RESOLUTION  (12)
#define DAC_RESOLUTION  (10)
#define ADC_MAX         (1UL &lt;&lt; ADC_RESOLUTION)
#define DAC_MAX         (1UL &lt;&lt; DAC_RESOLUTION)
#define VREF_MV         (3300UL)

void setup() {
   // Start the SerialUSB interface
   Serial.begin(1000000); 
   // Wait for Arduino Serial Monitor to open.
   while ( !Serial );
   Serial.println( F(&quot;SAMD21 - Seeeduino XIAO board.&quot;) );
   Serial.flush();
   // Set ADC and DAC resolution
   analogWriteResolution( DAC_RESOLUTION );
   analogReadResolution( ADC_RESOLUTION );
   delay(10);
}

void loop() {
  static uint32_t dac_value = 0;
  static uint32_t adc_value = 0;
  // Write DAC output.
  analogWrite( ANALOG_OUT_PIN, dac_value );
  // Read ADC input.
  adc_value = analogRead( ANALOG_IN_PIN );
  // Display ADC and DAC values (converted to millivolts)
  Serial.printf( &quot;DAC:%u,ADC:%u\r\n&quot;, 
       (dac_value*VREF_MV)/DAC_MAX, (adc_value*VREF_MV)/ADC_MAX );
  Serial.flush();
  dac_value = (dac_value+1) % DAC_MAX;
  if (dac_value%100 == 0) {
    delay(2000);
  }
}
</code></pre>
<p>ข้อมูลที่ถูกส่งออกมาทาง <strong>Serial</strong> ในแต่ละบรรทัดจะมีสองค่าคือ <strong>DAC</strong> และ <strong>ADC</strong>
โดยแปลงให้เป็นค่าแรงดันไฟฟ้าเมื่อใช้แรงดันอ้างอิง <strong>VREF</strong> เท่ากับ <strong>3300mV</strong></p>
<p><img alt="" src="dac_adc_plot-1.png" /></p>
<p><img alt="" src="dac_adc_plot-2.png" /></p>
<p>รูป:  ตัวอย่างการแสดงกราฟจากข้อมูลที่ได้รับใน <strong>Arduino Serial Plotter</strong></p>
<p>จากรูปกราฟ แกนตั้งมีหน่วยเป็น <strong>mV</strong> มีค่าไม่เกิน <strong>3300</strong> และแกนนอนเป็นตัวเลขลำดับข้อมูลที่ถูกส่งออกมาแต่ละบรรทัด
ค่าตัวเลขสำหรับ <strong>DAC</strong> เป็นระดับแรงดันเอาต์พุตที่วงจร <strong>DAC</strong> จะต้องสร้างเอาต์พุตออกมา
และค่าตัวเลข <strong>ADC</strong> เป็นระดับแรงดันอินพุตที่วัดได้ด้วยวงจร <strong>ADC</strong> </p>
<p>หากจะลองสร้างชุดข้อมูลตามรูปคลื่นไซน์ (<strong>Sine Wave</strong>) เช่น มีจำนวนข้อมูล (<code>N_SAMPLES</code>)
เท่ากับ 50 ก็มีตัวอย่างดังนี้</p>
<p><strong>Arduino Sketch: DAC - ADC Loopback (Sine Wave)</strong></p>
<pre><code class="language-cpp">#define ANALOG_OUT_PIN  (A0)  // DAC output pin
#define ANALOG_IN_PIN   (A1)  // ADC input pin
#define ADC_RESOLUTION  (12)
#define DAC_RESOLUTION  (10)
#define ADC_MAX         (1UL &lt;&lt; ADC_RESOLUTION)
#define DAC_MAX         (1UL &lt;&lt; DAC_RESOLUTION)
#define VREF_MV         (3300UL)

#define N_SAMPLES       (50)
uint16_t SINE_TABLE[N_SAMPLES] = {0};

void setup() {
  // Start the SerialUSB interface
  Serial.begin(1000000); 
  // Wait for Arduino Serial Monitor to open.
  while ( !Serial );
  Serial.println( F(&quot;SAMD21 - Seeeduino XIAO board.&quot;) );
  Serial.flush();
  // Set ADC and DAC resolution
  analogWriteResolution( DAC_RESOLUTION );
  analogReadResolution( ADC_RESOLUTION );
  delay(10);

  // Computes a sine table for one period
  uint32_t value;
  for ( int i=0; i &lt; N_SAMPLES; i++ ) {
    value = DAC_MAX*(1+sin(2*M_PI*i/N_SAMPLES))/2;
    if (value &gt;= DAC_MAX) {
      value = DAC_MAX-1;
    }
    SINE_TABLE[i] = value;  
  }
}

void loop() {
  static uint32_t adc_value = 0;
  static uint32_t dac_value = 0;
  for ( int i=0; i &lt; N_SAMPLES; i++ ) {
    dac_value = SINE_TABLE[ i ];
    // Write DAC output.
    analogWrite( ANALOG_OUT_PIN, dac_value );
    // Read ADC input.
    adc_value = analogRead( ANALOG_IN_PIN );
    // Display ADC and DAC values (converted to millivolts).
    Serial.printf( &quot;DAC:%u,ADC:%u\r\n&quot;, 
                   (dac_value*VREF_MV)/DAC_MAX,
                   (adc_value*VREF_MV)/ADC_MAX );
  }
  Serial.flush();
  delay(2000);
}
</code></pre>
<p><img alt="" src="dac_adc_plot-3.png" /></p>
<p>รูป:  ตัวอย่างการแสดงกราฟจากข้อมูลที่ได้รับและแสดงให้เห็นรูปคลื่นไซน์</p>
<p>ข้อสังเกต: <strong>Arduino IDE 1.8.x</strong> จะแสดงผลใน <strong>Serial Plotter</strong>
ได้คราวละ 500 จุด (<strong>Data Points</strong>) แต่สำหรับ <strong>IDE 2.0.0</strong> จะได้แค่ 50 จุด</p>
<p>&nbsp;</p>
<hr />
<h2 id="i2c-master-bh1750-light-sensor-reading">&#9655; <strong>โค้ดตัวอย่าง: I2C Master &amp; BH1750 Light Sensor Reading</strong><a class="headerlink" href="#i2c-master-bh1750-light-sensor-reading" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นการทดลองใช้งานบัส <strong>I2C</strong> โดยใช้ขา <strong>D5=SCL / D4=SDA pins</strong>
และเขียนโปรแกรมโดยใช้คำสั่งของไลบรารี <code>Wire.h</code> ของ  <strong>Arduino API</strong> 
เพื่อใช้ในการเชื่อมต่อและอ่านค่าจากโมดูลเซนเซอร์ <strong>BH1750 Light Sensor</strong> </p>
<p>การตั้งค่าและอ่านข้อมูลจาก <strong>BH1750</strong> จะใช้ไลบรารีจาก 
<a href="https://github.com/claws/BH1750"><code>https://github.com/claws/BH1750</code></a>
ดังนั้นจะต้องมีการติดตั้งไลบรารีนี้ใน <strong>Arduino IDE</strong> ก่อน</p>
<p><img alt="" src="samd21_bh1750_lib_install.png" /></p>
<p>รูป: การค้นหาและติดตั้งไลบรารีสำหรับนำมาใช้งานกับโมดูล <strong>BH1750</strong></p>
<p><strong>Arduino Sketch: BH1750 Reading</strong></p>
<pre><code class="language-cpp">// Date: 2022-10-23
// Target board: Seeeduino XIAO SAMD21
#include &lt;Wire.h&gt;
#include &lt;BH1750.h&gt; // https://github.com/claws/BH1750 (version 1.3.0)

// Set the I2C address for the BH1750 device
#define BH1750_ADDR  (0x23) // 0x23 or 0x5c

// Create a BH1750 instance.
BH1750 bh1750;

String getSketchName( const char *fullpath ) {
  String str = fullpath;
  int pos = str.lastIndexOf(&quot;\\&quot;);
  if (pos &gt;= 0) {
    return str.substring(pos+1, str.length());
  }
  return str;
}

void setup() {
  // Start the SerialUSB interface
  Serial.begin(115200); 
  // Wait for Arduino Serial Monitor to open.
  while (!Serial); 
  Serial.println( F(&quot;SAMD21 - Seeeduino XIAO board.&quot;) );
  Serial.print( F(&quot;Arduino Sketch: &quot;) );
  Serial.println( getSketchName( __FILE__ ) );
  Serial.println( F(&quot;Build time: &quot; __DATE__ &quot; &quot; __TIME__ &quot;\n&quot;) );
  Serial.flush();

  // Start the I2C device (in master mode) 
  Wire.begin();
  // Set I2C clock speed to 100kHz
  Wire.setClock( 100000 );
  // Scan I2C slave devices.
  i2c_scan();

  // Set operating mode for BH1750: 
  // - 1 Lux resolution
  // - 120 ms measurement time
  // - continuous measurement mode
  bh1750.begin( BH1750::CONTINUOUS_HIGH_RES_MODE, BH1750_ADDR, NULL );
}

#define LINE_SEP  &quot;--------------------&quot;

void i2c_scan() {
  char sbuf[32];
  int n_devices = 0;
  Serial.println( F(&quot;Scanning I2C bus...&quot;) );
  Serial.print( &quot;   &quot; );
  for ( uint8_t col=0; col &lt; 16; col++ ) {
    sprintf( sbuf, &quot;%3x&quot;, col );
    Serial.print( sbuf );
  }
  Serial.println( &quot;&quot; );
  uint8_t addr=0;
  for( uint8_t row=0; row &lt; 8; row++ ) {
    sprintf( sbuf, &quot;%02x:&quot;, row &lt;&lt; 4 );
    Serial.print( sbuf );
    for ( uint8_t col=0; col &lt; 16; col++ ) {
      if ( row==0 &amp;&amp; addr&lt;=1 ) {
        Serial.print(&quot;   &quot;);
      } else {
        Wire.beginTransmission( addr );
        if ( Wire.endTransmission() &gt; 0 ) {
          Serial.print( &quot; --&quot; );
        } else {
          sprintf( sbuf, &quot; %2x&quot;, addr );
          Serial.print( sbuf );
          n_devices++;
        }
      }
      addr++;
    }
    Serial.println( &quot;&quot; );
  }
  Serial.println( F(LINE_SEP LINE_SEP LINE_SEP LINE_SEP) );
  Serial.flush();
}

void read_bh1750() {
  while ( !bh1750.measurementReady() ) {
    delay(10);
  }
  // Read a value from the BH1750 sensor.
  float lux = bh1750.readLightLevel();
  Serial.print( &quot;Light (Lux): &quot; );
  Serial.println( lux, 1 ); // only 1 digit after the decimal point}

void loop() {
  read_bh1750(); // read sensor value
  delay(100);
}
</code></pre>
<p><img alt="" src="samd21_i2c_bh1750_serial_output-1.png" /></p>
<p>รูป: ข้อความเอาต์พุตที่ได้รับใน <strong>Arduino Serial Monitor</strong>
แสดงหมายเลขแอดเดรส <code>0x23</code> ของอุปกรณ์ <strong>BH1750</strong> ที่เชื่อมต่อกับบัส <strong>I2C</strong></p>
<p><img alt="" src="samd21_bh1750_serial_plot.png" /></p>
<p>รูป:  ตัวอย่างการแสดงกราฟจากข้อมูลที่ได้รับใน <strong>Arduino Serial Plotter</strong>
(แกนตั้งมีหน่วยเป็น <strong>Lux</strong> สำหรับความเข้มแสงที่วัดได้จากเซนเซอร์ <strong>BH1750</strong>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="external-interrupt-rotary-encoder-switch">&#9655; <strong>โค้ดตัวอย่าง: External Interrupt &amp; Rotary Encoder Switch</strong><a class="headerlink" href="#external-interrupt-rotary-encoder-switch" title="Permanent link">#</a></h2>
<p>โมดูล <strong>Rotary Encoder</strong> เป็นอุปกรณ์ที่สร้างสัญญาณดิจิทัลแบบพัลส์ และมี 2 ช่อง (<strong>A</strong> และ <strong>B</strong>)
โดยปรกติสัญญาณทั้งสองจะมีสถานะลอจิกเป็น <strong>High</strong> แต่เมื่อใช้มือหมุนในทิศทางทวนหรือตามเข็มนาฬิกา
จะเกิดการเปลี่ยนแปลงลอจิกที่ช่องสัญญาณ <strong>A</strong> และ <strong>B</strong> ในลักษณะพัลส์
แต่การเปลี่ยนแปลงของแต่ละช่องจะเกิดขึ้นไม่พร้อมกัน จำนวนพัลส์ที่เกิดขึ้นจะขึ้นอยู่กับตำแหน่งเชิงมุมที่เปลี่ยนไป 
อุปกรณ์ประเภทนี้สามารถนำมาใช้สร้างสัญญาณอินพุต-ดิจิทัลให้ไมโครคอนโทรลเลอร์</p>
<p>โค้ดตัวอย่างต่อไปนี้ สาธิตการตรวจสอบการเกิดสัญญาณพัลส์ที่ช่องสัญญาณ <strong>A</strong> และ <strong>B</strong>
และระบุทิศทางการหมุน ซึ่งจะทำให้ค่าของตัวนับ <code>encoder_count</code> เพิ่มขึ้นหรือลดลงตามทิศทางการหมุน</p>
<p>หลักการทำงานคือ การตรวจสอบการเปลี่ยนแปลงโดยใช้อินเทอร์รัพท์ภายนอก 
ทั้งขอบขาขึ้นและขอบขาลง และใช้คำสั่ง <code>attachInterrupt(...)</code> ของ <strong>Arduino API</strong>
สำหรับอินเทอร์รัพท์จากภายนอก (<strong>External Interrupt</strong>) ที่ขาสัญญาณ <strong>A</strong> </p>
<p>เมื่อเกิดอินเทอร์รัพท์ที่ช่องสัญญาณ <strong>A</strong> ในแต่ละครั้ง ฟังก์ชันที่ทำหน้าที่เป็น 
<strong>ISR</strong> (<em>Interrupt Service Routine</em>)
จะทำงานและตรวจสอบดูว่า มีสัญญาณพัลส์แบบ <strong>Low</strong> ที่ช่อง <strong>A</strong> เกิดขึ้น 
และมีความกว้างไม่ต่ำกว่าค่าที่กำหนดไว้หรือไม่ (เช่น 20 มิลลิวินาที)</p>
<p>ถ้าเงื่อนไขดังกล่าวเป็นจริง ให้ถือว่ามีการเปลี่ยนตำแหน่งไปหนึ่งตำแหน่ง สถานะของสัญญาณช่อง <strong>B</strong> ในขณะนั้น 
จะถูกใช้ในการระบุทิศทางการเปลี่ยนแปลงที่เกิดขึ้น (เพิ่มขึ้นหรือลดลงทีละ 1)</p>
<p>โมดูล <strong>Rotary Encoder</strong> ที่ได้นำมาทดลองใช้งาน สามารถใช้แรงดันไฟเลี้ยง <strong>VCC=+3.3V</strong> ได้
มีขาสัญญาณ <strong>S1</strong>, <strong>S2</strong> และ <strong>KEY</strong> (ปุ่มกด) และนำไปต่อเข้ากับขา
<strong>D10</strong>, <strong>D9</strong> และ <strong>D8</strong> ของบอร์ด <strong>XIAO</strong> ตามลำดับ
ถ้ามีการกดปุ่มม <strong>KEY</strong> จะทำให้เกิดการรีเซตค่าของตัวนับ  <code>encoder_count</code> ให้มีค่าเป็น 0</p>
<p><strong>Arduino Sketch: Rotary Encoder Inputs</strong></p>
<pre><code class="language-cpp">#define PIN_A    (10) // S1
#define PIN_B    (9)  // S2
#define PIN_KEY  (8)  // KEY
#define MIN_PULSE_MS (20)

volatile int32_t encoder_count = 0;
volatile uint32_t last_time = 0;

void isr_pin_key() {
  encoder_count = 0; // reset counter
}

void isr_pin_a() { // ISR function
  // Read current time in msec.
  uint32_t now = millis();
  // Read value from input A.
  int a = digitalRead( PIN_A );
  // Read value from input B.
  int b = digitalRead( PIN_B );
  if ( (now - last_time) &gt;= MIN_PULSE_MS ) {
    if (a==0) { // A is low
      // Update encoder counter.
      encoder_count += b ? -1 : 1;
    }
  }
  last_time = now;
}

void setup() {
  SerialUSB.begin(1000000);
  while(!Serial);
  // Use PIN_A and PIN_B as digital input with internal pullup enabled.
  pinMode( PIN_A, INPUT_PULLUP );
  pinMode( PIN_B, INPUT_PULLUP );
  pinMode( PIN_KEY, INPUT_PULLUP );
  // Enable external interrupt on PIN_A.
  attachInterrupt( PIN_A, isr_pin_a, CHANGE );
  // Enable external interrupt on PIN_KEY.
  attachInterrupt( PIN_KEY, isr_pin_key, RISING );
}

#define UPDATE_INTERVAL_MS (5)

void loop() {
  static int32_t  saved_count = 0;
  static uint32_t ts_saved = 0;
  if ( millis() - ts_saved &gt;= UPDATE_INTERVAL_MS ) { // check every 5 msec
    ts_saved = millis();
    if ( saved_count != encoder_count ) { // Encoder counter was changed.
      saved_count = encoder_count;
      Serial.printf( &quot;Count: %d\r\n&quot;, saved_count );
    }
  }
}
</code></pre>
<p><img alt="" src="samd21_rotary_encoder_output.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุตแสดงการเปลี่ยนค่าของตัวนับเมื่อทดลองหมุนปุ่มของโมดูล <strong>Rotary Encoder</strong></p>
<p><img alt="" src="xiao_rotary_encoder_demo.jpg" /></p>
<p>รูป: การต่อวงจรทดลองใช้งานโมดูล <strong>Rotary Encoder</strong> บนเบรดบอร์ด</p>
<p>&nbsp;</p>
<hr />
<h2 id="hc-sr04p-ultrasonic-distance-sensor">&#9655; <strong>โค้ดตัวอย่าง: HC-SR04P Ultrasonic Distance Sensor</strong><a class="headerlink" href="#hc-sr04p-ultrasonic-distance-sensor" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นการอ่านค่าจากโมดูลเซนเซอร์ <strong>HC-SR04</strong>
เพื่อใช้ในการวัดระยะห่างจากวัตถุกีดขวางด้วยคลื่นเสียงอัลตราโซนิก
การวัดค่าจะเริ่มต้นด้วยการสร้างสัญญาณพัลส์ที่ขา <strong>TRIG</strong> ของโมดูล
ที่มีความกว้างอย่างน้อย <strong>10 usec</strong> (10 ไมโครวินาที) และจะเกิดสัญญาณเอาต์พุตที่ขา
<strong>ECHO</strong> ของโมดูล โดยเปลี่ยนจาก <strong>LOW</strong> เป็น <strong>HIGH</strong> แล้วเปลี่ยนกลับเป็น <strong>LOW</strong>
ความกว้างช่วงที่เป็น <strong>HIGH</strong> ของสัญญาณพัลส์ตอบกลับมานั้น
จะใช้ในการคำนวณระยะเวลาเดินทางของคลื่นเสียงในอากาศในทิศทางไปและสะท้อนกลับมา</p>
<p>การวัดความกว้างของสัญญาณพัลส์ จะใช้วิธีการตรวจสอบเหตุการณ์ภายนอก (<strong>External Interrupt</strong>)
ที่ขา <strong>ECHO</strong> และสร้างอินเทอร์รัพท์ เมื่อมีการเปลี่ยนแปลงของลอจิกที่ขาสัญญาณ <strong>ECHO</strong> 
จะมีการจับเวลาและบันทึกตัวเลข (ไมโครวินาที) โดยฟังก์ชันที่ทำหน้าที่เป็น <strong>ISR</strong>
แบ่งเป็นสองเหตุกาณ์ต่อเนื่องกับคือ ขอบขาขึ้น (<strong>Rising Edge</strong>) และขอบขาลง (<strong>Falling Edge</strong>)
ตามลำดับ และนำไปคำนวณค่าผลต่าง จะได้เป็นความกว้างของพัลส์</p>
<p>ในโค้ดตัวอย่างนี้ ได้เลือกใช้ขา <strong>D9 / D10</strong> ของบอร์ด <strong>XIAO</strong> สำหรับนำไปต่อกับขาสัญญาณ
<strong>ECHO / TRIG</strong> ของโมดูล <strong>HC-SR04P</strong> (เป็นรุ่นที่สามารถใช้แรงดันไฟเลี้ยง <strong>VCC=+3.3</strong> ได้)</p>
<p><strong>Arduino Sketch: HC-SR04P Sensor Reading</strong></p>
<pre><code class="language-cpp">#define ECHO_PIN      (9)   // D9 pin
#define TRIG_PIN      (10)  // D10 pin

#define SOUND_SPEED   (342)
#define US_TO_CM(t)   ((SOUND_SPEED*t)/20000.0f)

void setup() {
  pinMode( ECHO_PIN, INPUT );
  pinMode( TRIG_PIN, OUTPUT );
  Serial.begin( 1000000 );
  while (!Serial);
  Serial.println( F(&quot;XIAO SAMD21 + HC-SR04 Ultrasonic Sensor Demo&quot;) );
  Serial.flush();
  digitalWrite( TRIG_PIN, LOW );
  delay(100);
}

volatile uint32_t timestamps[2] = {0,0};

void echo_isr() { // ISR code executed from SRAM
  uint32_t t_now = micros(); // Get the current time (usec)
  if ( digitalRead( ECHO_PIN ) ) { // rising-edge event
     timestamps[0] = t_now; // Save the timestamp. 
  } else { // falling-edge event
     timestamps[1] = t_now; // Save the timestamp.
  }
}

uint32_t read_sensor() {
  // Clear timestamps for rising-edge and falling-edge events.
  timestamps[0] = timestamps[1] = 0;
  // Enable GPIO interrrupt on the Echo pin. 
  attachInterrupt( ECHO_PIN, echo_isr, CHANGE ); 
  // Create a short pulse on the Trigger pin.
  digitalWrite( TRIG_PIN, HIGH );
  delayMicroseconds( 10 );
  digitalWrite( TRIG_PIN, LOW );
  // Wait for 50 msec after the measurement was started.
  delay(50);
  // Disable the interrupt on the Echo pin.
  detachInterrupt( ECHO_PIN ); 
  // Check the timestamps for valid pulse width
  if ( timestamps[0] &lt; timestamps[1] ) {
     return (timestamps[1] - timestamps[0]);
  }
  return 0; // no pulse
}

#define T_USEC_MAX   (30000)

void loop() {
  uint32_t t_usec = read_sensor();
  if ( t_usec &gt; 0 ) {
    if (t_usec &gt; T_USEC_MAX ) { // value limit 
      t_usec = T_USEC_MAX;
    }
    Serial.printf( &quot;Distance [cm]: %.1f\r\n&quot;, US_TO_CM(t_usec) );
  }
  delay(100);
}
</code></pre>
<p><img alt="" src="xiao_hc_sr04_output.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุตแสดงการวัดค่าระยะห่างจากวัตถุกีดขวางโดยใช้โมดูล <strong>HC-SR04P</strong></p>
<p><img alt="" src="xio_hc_sr04p_demo.jpg" /></p>
<p>รูป: การต่อวงจรทดลองใช้งานโมดูล <strong>HC-SR04P</strong> บนเบรดบอร์ด</p>
<p>&nbsp;</p>
<hr />
<h2 id="_1">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้ได้นำเสนอการใช้งานบอร์ด <strong>Seeeduino XIAO - SAMD21</strong> ในเบื้องต้น
และมีโค้ดตัวอย่างสำหรับการเขียนโปรแกรมด้วย <strong>Arduino IDE</strong> เพื่อทดลองใช้กับบอร์ดไมโครคอนโทรลเลอร์ดังกล่าว</p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2022-10-24 | Last Updated: 2022-10-25</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
