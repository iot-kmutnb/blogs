<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="http://iot-kmutnb.github.com/blogs/electronics/rlc_circuits/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>วงจร RLC และการวิเคราะห์วงจรไฟฟ้า - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/julia.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#rlc" class="nav-link">วงจร RLC และการวิเคราะห์วงจรไฟฟ้า</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">&#9655; ทฤษฎีพื้นฐานในการวิเคราะห์วงจรไฟฟ้าพื้นฐาน</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#easyeda" class="nav-link">&#9655; การวาดวงจรและจำลองการทำงานด้วย EasyEDA</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#easyeda_1" class="nav-link">&#9655; การวิเคราะห์วงจรกระแสตรง และการจำลองการทำงานด้วย EasyEDA</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc" class="nav-link">&#9655; วงจร RC และการจำลองการทำงาน</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc_1" class="nav-link">&#9655; การจำลองการทำงานของวงจร RC: แหล่งจ่ายเป็นแบบขั้นบันไดและพัลส์</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc_2" class="nav-link">&#9655; การจำลองการทำงานของวงจร RC: แหล่งจ่ายเป็นรูปคลื่นไซน์</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc_3" class="nav-link">&#9655; การวิเคราะห์วงจร RC: แหล่งจ่ายเป็นรูปคลื่นไซน์</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc_4" class="nav-link">&#9655; การวิเคราะห์วงจร RC: แรงดันแบบขั้นบันได</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc-matlab" class="nav-link">&#9655; การวิเคราะห์วงจร RC ด้วย MATLAB</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rc-python" class="nav-link">&#9655; การวิเคราะห์วงจรอนุกรม RC ด้วย Python</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rlc_1" class="nav-link">&#9655; การวิเคราะห์วงจรอนุกรม RLC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="rlc">วงจร RLC และการวิเคราะห์วงจรไฟฟ้า<a class="headerlink" href="#rlc" title="Permanent link">#</a></h1>
<p>บทความนี้กล่าวถึง การวิเคราะห์วงจรพื้นฐานทางไฟฟ้าที่ประกอบด้วยตัวต้านทาน ตัวเก็บประจุ และตัวเหนี่ยวนำไฟฟ้า (เรียกว่า วงจร <strong>RLC</strong>) โดยใช้ซอฟต์แวร์ประเภททื่เรียกว่า <strong>EDA (<em>Electronics Design Automation</em>)</strong> ซึ่งในปัจจุบันมีให้เลือกใช้งานอยู่หลายตัวเลือก แต่บทความนี้นำเสนอตัวอย่างการใช้ซอฟต์แวร์ฟรีที่มีชื่อว่า <a href="https://easyeda.com/"><strong>EasyEDA</strong></a> ใช้งานได้ทั้งแบบ <strong>Online (Web-based)</strong> และ <strong>Desktop App</strong> (แต่ต้องสมัครสมาชิกเพื่อสร้างบัญชีผู้ใช้ก่อนเข้าใช้งาน) นอกจากนั้นแล้วยังมีตัวอย่างการใช้ซอฟต์แวร์และเขียนโค้ดด้วย <a href="https://matlab.mathworks.com/"><strong>MATLAB</strong></a> (แต่มีลิขสิทธิ์ในการใช้งานและค่าใช้จ่าย) หรือใช้ <strong>Python</strong> ซึ่งเป็น <strong>Open Source</strong> เพื่อเขียนโค้ดและช่วยวิเคราะห์การทำงานของวงจร <strong>RLC</strong></p>
<p><strong>Keywords:</strong> <em>RLC Circuits</em>, <em>Circuit Analysis</em>, <em>EasyEDA</em>, <em>MATLAB</em>, <em>Python</em></p>
<hr />
<h2 id="_1">&#9655; <strong>ทฤษฎีพื้นฐานในการวิเคราะห์วงจรไฟฟ้าพื้นฐาน</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>โดยทั่วไปแล้ว ในวงจรพื้นฐานทางไฟฟ้า (<strong>Basic Electrical Circuits</strong>) ถ้ามีตัวต้านทาน (<strong>Resistors</strong>) ตัวเก็บประจุ (<strong>Capacitors</strong>) และตัวเหนี่ยวนำไฟฟ้า (<strong>Inductors</strong>) เป็นองค์ประกอบของวงจร และเรียกวงจรประเภทนี้ว่า <strong>RLC</strong> นอกจากนั้นยังต้องมีแหล่งพลังงานไฟฟ้าในวงจร เช่น แบตเตอรี่ (<strong>Batteries</strong>) หรือ แหล่งจ่ายที่ให้แรงดันไฟฟ้าคงที่ (<strong>Constant Voltage Source</strong>) หรือกระแสคงที่  (<strong>Constant Current Source</strong>) เป็นต้น</p>
<p>เทคนิคสำหรับการวิเคราะห์วงจรที่ประกอบด้วย <strong>RLC</strong> เกี่ยวข้องกับทฤษฎีหรือกฎทางไฟฟ้าและฟิสิกส์ เช่น </p>
<ul>
<li>
<p>กฎของเคอร์ชอฟฟ์ (<strong>Kirchhoff's Circuit Laws</strong>) ซึ่งมี 2 ข้อ แบ่งเป็นกฎสำหรับแรงดันไฟฟ้า (<strong>KVL</strong>) และสำหรับกระแสไฟฟ้า (<strong>KCL</strong>) ตามลำดับ</p>
<ol>
<li><strong>KVL: Kirchoff's Voltage Law</strong>: <q>ผลรวมทางพีชคณิตของแรงดันไฟฟ้าภายในวงจรปิดใด ๆ หรือที่เรียกว่า เมช (<strong>Mesh</strong>) มีค่าเท่ากับศูนย์</q></li>
<li><strong>KCL: Kirchoff's Current Law</strong>: <q>ณ จุดใด ๆ ในวงจรไฟฟ้า หรือที่เรียกว่า โหนด  (<strong>Node</strong>) ผลรวมทางพีชคณิตของกระแสไฟฟ้าที่ไหลเข้าและไหลออก มีค่าเท่ากับศูนย์</q> หรือกล่าวได้ว่า  กระแสไฟฟ้าที่ไหลเข้าจุดใดจุดหนึ่งในวงจรไฟฟ้า จะเท่ากับกระแสไฟฟ้าที่ไหลออกจากจุดนั้น</li>
</ol>
</li>
<li>
<p>ความสัมพันธ์แบบเชิงเส้นระหว่างความต่างศักย์ไฟฟ้า หรือแรงดันไฟฟ้าตกคร่อม <script type="math/tex">V</script> และกระแสไฟฟ้า <script type="math/tex">I</script> ที่ไหลผ่านตัวนำไฟฟ้าที่มีค่าความต้านทาน <script type="math/tex">R</script> ซึ่งเป็นไปตามกฎของโอห์ม (<strong>Ohm's Law</strong>): <script type="math/tex; mode=display"> V = I \cdot R </script>
</p>
</li>
<li>
<p>ความสัมพันธ์ระหว่างแรงดันไฟฟ้าที่ขั้วทั้งสองของตัวเก็บประจุและกระแสที่ไหลเข้าหรือออก: </p>
<ul>
<li>ตัวเก็บประจุมีสองขั้วประกอบด้วยตัวนำไฟฟ้าที่ถูกแยกจากกันโดยมีสารไดอิเล็กทริก  (<strong>Dielectric</strong>) คั่นกลาง เช่น เซรามิก (<strong>Ceramic</strong>) แทนทาลัม (<strong>Tantalum</strong>) และวัสดุอื่น ๆ เป็นต้น</li>
<li>เมื่อป้อนแรงดันไฟฟ้าที่ขั้วทั้งสองของตัวเก็บประจุ จะทำให้เกิดสนามไฟฟ้าในตัวเก็บประจุและมีประจุไฟฟ้าสะสมไว้ภายในตัวเก็บประจุ และสามารถเก็บพลังงานไฟฟ้าได้เมื่อตัดการเชื่อมต่อจากวงจร</li>
<li>เมื่อมีกระแสไฟฟ้าไหล <script type="math/tex">i_C(t)</script> ในทิศทางเข้าหรือออกจากตัวเก็บประจุ จะทำให้แรงดันไฟฟ้าตกคร่อมที่ตัวเก็บประจุ <script type="math/tex">v_C(t)</script> เปลี่ยนแปลงตามเวลา เช่น ถ้ามีกระแสไหลเข้า ก็เป็นการชาร์จประจุไฟฟ้า ทำให้มีประจุไฟฟ้าเพิ่มขึ้น และแรงดันไฟฟ้าของตัวเก็บประจุเพิ่มขึ้น แต่ถ้ามีกระแสไหลออก ก็เป็นการคายประจุไฟฟ้า ทำให้ประจุไฟฟ้าลดลง และแรงดันไฟฟ้าของตัวเก็บประจุก็ลดลง</li>
<li>ปริมาณประจุไฟฟ้า <script type="math/tex">Q</script> (<strong>Charge</strong>) ที่ถูกเก็บอยู่ในตัวเก็บประจุกับแรงดันไฟฟ้าตกคร่อม <script type="math/tex">V</script> ณ เวลาใด ๆ มีความสัมพันธ์ดังนี้
<script type="math/tex; mode=display"> Q = C \cdot V </script>
โดยที่ <script type="math/tex">C</script> เป็นค่าของตัวเก็บประจุ (หน่วยเป็น <strong>Farad: F</strong>) ดังนั้นถ้าไม่มีประจุไฟฟ้าในตัวเก็บประจุ (มีประจุไฟฟ้าเป็นศูนย์) แรงดันไฟฟ้าจะเป็นศูนย์</li>
<li>ถ้ามีการเปลี่ยนแปลงประจุไฟฟ้าเกิดขึ้น (เพิ่มขึ้นหรือลดลง) จะต้องมีกระแสไหล
และอัตราการเปลี่ยนแปลงประจุในช่วงเวลาหนึ่ง (<script type="math/tex">\Delta t</script>) ก็จะเท่ากับปริมาณกระแส <script type="math/tex">I</script> ที่ไหลโดยเฉลี่ยในช่วงเวลานั้น
<script type="math/tex; mode=display"> I = \frac{\Delta Q}{\Delta t} 
= C \frac{\Delta V}{\Delta t} </script>
</li>
<li>ถ้าให้ <script type="math/tex">\Delta t \rightarrow 0</script> (เข้าใกล้ศูนย์) ก็สามารถเขียนให้อยู่ในรูปของสมการเชิงอนุพันธ์ได้ดังนี้
โดยที่ <script type="math/tex">i_C(t)</script> และ <script type="math/tex">v_C(t)</script> เป็นปริมาณทางไฟฟ้าที่ขึ้นอยู่กับตัวแปรอิสระ <script type="math/tex">t</script> (เวลา) 
<script type="math/tex; mode=display"> i_C(t) = C \frac{d v_C(t)}{dt}</script> หรือเขียนให้อยู่ในรูปของการอินทิเกรต
<script type="math/tex; mode=display"> v_C(t) = \frac{1}{C}\int_0^t i_C(\tau)d\tau + v_C(0),\; t \geq 0 </script>
</li>
</ul>
</li>
<li>
<p>ความสัมพันธ์ระหว่างแรงดันไฟฟ้าที่ขั้วทั้งสองของตัวเหนี่ยวนำไฟฟ้าและกระแสที่ไหล: </p>
<ul>
<li>เมื่อมีกระแสไฟฟ้าไหลผ่านขดลวดที่เป็นตัวนำไฟฟ้า หรือที่เรียกว่า "คอยล์" (<strong>Coil</strong>) จะทำให้เกิดสนามแม่เหล็ก (<strong>Magnetic Field</strong>) บริเวณรอบ ๆ ตัวนำไฟฟ้า ตัวอย่างอุปกรณ์ที่ใช้หลักการนี้ในการทำงาน ได้แก่ โซลีนอยด์ (<strong>Solenoid</strong>) และ ขดลวดในรีเลย์ เป็นต้น</li>
<li>ในสนามแม่เหล็กที่เกิดขึ้นรอบตัวนำไฟฟ้าที่มีกระแสไฟฟ้าไหล <script type="math/tex">I</script> (หน่วยเป็นแอมแปร์) จะมีเส้นแรงแม่เหล็ก หรือเรียกว่า ฟลักซ์แม่เหล็ก <script type="math/tex">\Phi</script> (<strong>Magnetic Flux</strong>) มีหน่วยเป็น "เวเบอร์" (<strong>Weber: Wb</strong>) และปริมาณฟลักซ์แม่เหล็กก็ขึ้นอยู่กับปริมาณกระแสไฟฟ้าที่ไหล </li>
<li>สนามแม่เหล็ก <script type="math/tex">B</script> มีหน่วยเป็น "เทสลา" (<strong>Testa: T</strong>) ซึ่งเป็นความหนาแน่นของฟลักซ์แม่เหล็ก (<strong>Magnetic Flux Density</strong>) หรือ ปริมาณเส้นแรงแม่เหล็กต่อหน่วยพื้นที่ตั้งฉากกับเส้นแรงแม่เหล็ก <script type="math/tex; mode=display"> B = \frac{\Phi}{A} </script>
</li>
<li>เมื่อมีกระแสไฟฟ้าไหล <script type="math/tex">I</script> ผ่านคอยล์ที่มีลักษณะเป็นทรงกระบอกและมีแกนอากาศ  (<strong>Air-Core Cylindrical Coil</strong>) มีความยาว <script type="math/tex"> l \gg r </script> ซึ่งเป็นรัศมีของคอยล์ และมีจำนวนรอบ (<strong>Turns</strong>) ของการพันขดลวด (<strong>Winding</strong>) เท่ากับ <script type="math/tex">N</script> สนามแม่เหล็ก <script type="math/tex">B</script> ที่เกิดขึ้นภายใน ณ จุดใดจุดหนึ่งในแกนกลางของคอยล์ สามารถคำนวณหาค่าประมาณได้ โดยใช้สูตรต่อไปนี้: 
<script type="math/tex; mode=display"> B = \mu_0 n I, \;\; n = \Big(\frac{N}{l}\Big) </script> 
โดยที่ <script type="math/tex">\mu_0 = 4\pi \times 10^{-7}\; [H/m]</script> ใช้สัญลักษณ์ <script type="math/tex">A</script> สำหรับพื้นที่หน้าตัดของคอยล์  และ <script type="math/tex">n</script> คือ จำนวนรอบของขดลวดต่อหน่วยความยาวของคอยล์ (<strong>Winding Density</strong>)</li>
<li>เมื่อมีกระแสไหลผ่านคอยล์จะเกิดฟลักซ์แม่เหล็ก ซึ่งจะได้มากหรือน้อย ก็ขึ้นอยู่กับค่าเหนี่ยวนำตัวเอง (<strong>Self-Inductance</strong>) ของคอยล์ </li>
<li>ความสัมพันธ์ระหว่างปริมาณกระแสไฟฟ้า  <script type="math/tex">I</script> ที่ไหลผ่านคอยล์ที่มีจำนวนรอบในการพันขดลวดเท่ากับ  <script type="math/tex">N</script> 
 และปริมาณเส้นแรงแม่เหล็กที่เชื่อมโยงขดลวดทั้งหมด (<strong>Magnetic Flux Linkage</strong>) ซึ่งเท่ากับ  <script type="math/tex">N \cdot \Phi</script> มีดังนี้
<script type="math/tex; mode=display"> N \cdot \Phi = L \cdot I</script>
</li>
<li>สัญลักษณ์ <strong>L</strong> คือ ค่าการเหนี่ยวนำ (<strong>Inductance</strong>) มีหน่วยเป็น "เฮนรี" (<strong>Henry: H</strong>)
และในกรณีของคอยล์แกนอากาศทรงกระบอก ก็สามารถคำนวณค่า (โดยประมาณ) สำหรับค่าเหนี่ยวนำตัวเอง <script type="math/tex">L</script> ได้ดังนี้
<script type="math/tex; mode=display"> L = \frac{N \cdot \Phi }{I} = \frac{ N \cdot (B \cdot A)}{I} </script>
<script type="math/tex; mode=display"> L = \frac{N \cdot (\mu_0 \frac{N}{l} I) \cdot A}{I} = \mu_0 N^2 \frac{A}{l} </script>
</li>
<li>หากใช้ขดลวดรูปทรงอื่น เช่น คอยล์รูปทรงทอรอยด์  (<strong>Toroidal Coil</strong>) จะมีวิธีการคำนวณค่า <script type="math/tex">L</script> แตกต่างกันไปจากคอยล์ทรงกระบอก และขึ้นอยู่กับวัสดุแกนกลางที่ไม่ใช่อากาศด้วย เช่น แกนเฟอร์ไรท์ (<strong>Ferrite Core</strong>)</li>
<li>หากกระแสไฟฟ้าที่ไหลผ่านขดลวดมีการเปลี่ยนแปลง จะทำให้ฟลักซ์แม่เหล็กเปลี่ยนแปลงตามในเชิงเวลา </li>
<li>หากมีการเปลี่ยนแปลงของฟลักซ์ภายในแกนกลางของคอยล์ที่มีจำนวนรอบของขดลวด <script type="math/tex">N</script> จะทำให้เกิดแรงดันไฟฟ้าเหนี่ยวนำในขดลวดนั้น (<strong>Self-Induced Voltage</strong>) หรือ มีแรงเคลื่อนไฟฟ้า (<strong>Electromotive Force : EMF</strong>) ตามกฎการเหนี่ยวนำแม่เหล็กไฟฟ้าของฟาราเดย์ (<strong>Faraday's Law of Induction</strong>) 
<script type="math/tex; mode=display"> EMF = -N \frac{\Delta \Phi}{\Delta t} = -L \frac{\Delta I}{\Delta t} </script>
</li>
<li>แรงดันไฟฟ้าเหนี่ยวนำเกิดขึ้นเพื่อต้านการเปลี่ยนแปลงของกระแสหรือฟลักซ์แม่เหล็ก (ดังนั้นจึงมีเครื่องหมายเป็นลบ) ตามกฎของเลนซ์ (<strong>Lenz's Law</strong>) ยกตัวอย่างเช่น หากมีกระแสไหลผ่านขดลวดมากขึ้น จะเกิดแรงดันไฟฟ้าเหนี่ยวนำเพื่อให้ต้านการเพิ่มขึ้นของกระแสดังกล่าว</li>
<li>ถ้าให้ <script type="math/tex">\Delta t \rightarrow 0</script> ก็สามารถเขียนให้อยู่ในรูปของสมการเชิงอนุพันธ์ได้ดังนี้
โดยที่ <script type="math/tex">v_L(t)</script> และ <script type="math/tex">i_L(t)</script> เป็นปริมาณทางไฟฟ้าสำหรับตัวเหนี่ยวนำที่ขึ้นอยู่กับตัวแปรอิสระ <script type="math/tex">t</script> (เวลา) 
<script type="math/tex; mode=display"> v_L(t) = L\frac{d i_L(t)}{dt}</script> หรือเขียนให้อยู่ในรูปของการอินทิเกรต
<script type="math/tex; mode=display"> i_L(t) = \frac{1}{L}\int_0^t v_L(\tau)d\tau + i_L(0), \; t \geq 0 </script>
</li>
</ul>
</li>
</ul>
<p><strong>เอกสารอ้างอิง:</strong> หนังสือฟิสิกส์ระดับมหาวิทยาลัยที่สามารถเปิดอ่านหรือดาวน์โหลดได้ฟรี  โดย <a href="https://openstax.org"><strong>OpenStax / Rice University</strong></a> เช่น เนื้อหาเกี่ยวกับแม่เหล็กและตัวเหนี่ยวนำจะอยู่ในบทที่ 11-14 ของหนังสือ <a href="https://openstax.org/details/books/university-physics-volume-2">"<strong>University Physics Volume 2</strong>"</a> </p>
<p>เมื่อได้ทำความเข้าใจหรือทบทวนทฤษฎีพื้นฐานเหล่านี้แล้ว ถัดไปเป็นตัวอย่างการวิเคราะห์วงจรไฟฟ้าพื้นฐาน</p>
<p>&nbsp;</p>
<hr />
<h2 id="easyeda">&#9655; <strong>การวาดวงจรและจำลองการทำงานด้วย EasyEDA</strong><a class="headerlink" href="#easyeda" title="Permanent link">#</a></h2>
<p>ผู้ใช้สามารถจำลองการทำงานของวงจรได้ (ใช้โปรแกรม <a href="https://www.analog.com/en/design-center/design-tools-and-calculators/ltspice-simulator.html"><strong>LTspice</strong></a> ที่ทำงานร่วมกับซอฟต์แวร์ <strong>EasyEDA</strong>)
ซึ่งมีรูปแบบหรือโหมดในการวิเคราะห์วงจร ให้เลือกหลายแบบดังนี้ (อ้างอิงจาก <a href="https://docs.easyeda.com/en/Simulation/Chapter8-Setting-up-Analyses/index.html"><strong>EasyEDA - Setting up Analyses</strong></a>)</p>
<ol>
<li><strong>DC op pnt</strong> (<code>.op</code>): Find the Quiescent DC Operating Point</li>
<li><strong>DC Transfer</strong> (<code>.tf</code>): Find the DC Small-Signal Transfer Function</li>
<li><strong>DC Sweep</strong> (<code>.dc</code>): Perform a DC-Sweep Analysis</li>
<li><strong>AC Analysis</strong> (<code>.ac</code>): Perform a Small-Signal AC (Frequency-Domain) Analysis</li>
<li><strong>Transient</strong> (<code>.tran</code>): Perform a Transient (Time-domain) Analysis</li>
</ol>
<p>ยกตัวอย่างเช่น  ถ้าต้องการดูว่า การเปลี่ยนระดับแรงดันไฟฟ้าในช่วงที่กำหนดไว้ของแหล่งจ่ายกระแสตรง จะส่งผลอย่างไรต่อวงจร เช่น ดูความสัมพันธ์ระหว่างแรงดันและกระแส (<strong>V-I Curve</strong>) ของไดโอด หรือ ทรานซิสเตอร์ ก็ให้ใช้โหมด <strong>DC Sweep</strong> </p>
<p>ถ้าต้องการดูว่า อินพุตของวงจร เช่น แหล่งจ่ายแรงดัน ที่มีการเปลี่ยนแปลงขนาดในช่วงแคบ ๆ (<strong>Small-Signal</strong>) จะส่งผลต่อการเปลี่ยนแปลงของเอาต์พุตของวงจรอย่างไร แล้วนำไปคำนวณหาอัตราส่วนระหว่างขนาดของเอาต์พุตเทียบกับอินพุต หรืออัตราการขยายของวงจร (<strong>DC Gain</strong>) ในกรณีนี้ให้เลือกโหมด <strong>DC Small-Signal Transfer Function</strong></p>
<p>หากต้องการดูผลตอบสนองในเชิงเวลาของวงจร ก็ให้เลือกใช้โหมด <strong>Transient</strong> หรือ ถ้าต้องการดูผลตอบสนองเชิงความถี่ของวงจรที่เกิดจากแหล่งจ่าย <strong>AC</strong> ในย่านความถี่ตามได้ที่กำหนดไว้ เช่น ดูค่าแอมพลิจูดและเฟสของสัญญาณ ก็จะใช้โหมดการวิเคราะห์ที่เรียกว่า <strong>AC Analysis</strong> และถ้าเลือกโหมด <strong>DC Operating Point</strong> คือ การวิเคราะห์วงจร ณ เวลาเท่ากับ 0 (<strong>t=0</strong>) เป็นต้น</p>
<p>การวาดผังวงจร (<strong>Schematic Capture</strong>) โดยใช้ <strong>EasyEDA</strong> เริ่มต้นโดยการสร้างโปรเจกต์ใหม่
ให้เปลี่ยนจากโหมด <strong>Standard (STD)</strong> เป็นโหมด <strong>Simulation (SIM)</strong> ก่อนเริ่มวาดวงจร
สำหรับวิธีการใช้งาน แนะนำให้ศึกษาเอกสารออนไลน์ <a href="https://docs.easyeda.com/en/Simulation/Headings/index.html"><strong>EasyEDA Simulation Tutorial</strong></a> </p>
<p>&nbsp;</p>
<hr />
<h2 id="easyeda_1">&#9655; <strong>การวิเคราะห์วงจรกระแสตรง และการจำลองการทำงานด้วย EasyEDA</strong><a class="headerlink" href="#easyeda_1" title="Permanent link">#</a></h2>
<p>ตัวอย่างแรกเป็นวงจรไฟฟ้ากระแสตรงที่ประกอบด้วยตัวต้านทาน (<strong>R1 R2 R3</strong>) และแหล่งจ่ายแรงดันคงที่
(<strong>V1 V2</strong>) ตามรูปผังวงจรต่อไปนี้</p>
<p><img alt="" src="dc_op_sim_circuit.png" /></p>
<p>รูป: ตัวอย่างวงจรกระแสตรงและการจำลองการทำงานในโหมด <strong>DC Operating Point (.op)</strong></p>
<p>จากผังวงจร ก็สามารถใช้หลักการวิเคราะห์แบบ <strong>Mesh Analysis (Loop Analysis)</strong> 
เพื่อหาปริมาณและทิศทางกระแสที่ไหลในวงจรไฟฟ้ากระแสตรง โดยการแปลงวงจร
ให้อยู่ในรูปของระบบสมการเชิงเส้นและหาผลเฉลยสำหรับตัวแปรที่เป็นกระแสไฟฟ้า</p>
<p>
<script type="math/tex; mode=display">
I_1 + I_2 = I_3 \\
-V_1 + I_1 R_1 + I_3 R_2 = 0 \\
-I_3 R_2 - I_2 R_3 + V_2 = 0 \\
</script>
จัดรูปของสมการใหม่ และเขียนให้อยู่ในรูปแบบของเมทริกซ์ <script type="math/tex">\mathbf{A}</script> และเวกเตอร์ <script type="math/tex">\mathbf{b}</script> ได้ดังนี้
<script type="math/tex; mode=display">
\begin{align}
  I_1 (R_1+R_2) + I_2 R_2 &_= V_1 \\
  I_1 R_2 + I_2 (R_2+R_3) &= V_2 \\
\end{align}
</script>
</p>
<p>
<script type="math/tex; mode=display">
\underbrace{\begin{pmatrix}
 (R_1+R_2) & R_2 \\
 R_2      & (R_2+R_3) \\
\end{pmatrix}}_{\mathbf{A}}
\begin{pmatrix}
I_1 \\
I_2 \\
\end{pmatrix}
= 
\underbrace{\begin{pmatrix}
V_1 \\
V_2 \\
\end{pmatrix}}_{\mathbf{b}}
</script>
</p>
<p>ถ้าสามารถแก้ระบบสมการเชิงเส้นที่มีสองตัวแปรนี้ได้ ก็จะทราบกระแสไฟฟ้า <script type="math/tex">I_1</script> และ <script type="math/tex">I_2</script> ที่ไหลในวงจร</p>
<p>แต่ถ้าจะใช้วิธีแบบ <strong>Nodal Analysis</strong> เพื่อหาค่าของแรงดันไฟฟ้าที่จุดหรือโหนด เช่น <script type="math/tex">V_A</script>, <script type="math/tex">V_B</script>, <script type="math/tex">V_C</script>
เทียบกับ <strong>GND</strong> ของวงจร ก็มีตัวอย่างดังนี้</p>
<p>
<script type="math/tex; mode=display">
  \text{KCL: } \; \frac{(V_A - V_B)}{R_1}
   +\frac{(V_C - V_B)}{R_3} = \frac{V_B}{R_2}  \\
   V_A = V_1 \\
   V_C = V_2 \\
</script>
</p>
<p>จากการจำลองการทำงานของวงจรไฟฟ้าด้วย <strong>EasyEDA</strong> จะได้กระแสไฟฟ้า <script type="math/tex">I_1=0.016 A</script>
และ <script type="math/tex">I_2=0.004 A</script> ตามทิศทางของกระแสที่ได้กำหนดไว้ในวงจร
และจะได้แรงดันไฟฟ้า <script type="math/tex">V_A=12 V</script>, <script type="math/tex">V_B=4 V</script> และ <script type="math/tex">V_C=5 V</script> ซึ่งใช้โพรบวัดแรงดัน (<strong>Voltage Probe</strong>)
หรือจุดวัดแรงดันไฟฟ้าในวงจรเทียบกับ <strong>GND</strong></p>
<p><img alt="" src="dc_op_sim_voltages.png" /></p>
<p>รูป: ผลการจำลองการทำงาน (<strong>SPICE Simulation Results</strong>) แสดงค่า <script type="math/tex">V_A</script>, <script type="math/tex">V_B</script>, <script type="math/tex">V_C</script>
</p>
<p>&nbsp;</p>
<p>ถ้าจะลองเขียนโค้ด <strong>MATLAB</strong> (ทดลองใช้กับเวอร์ชัน <strong>R2022a</strong>)
เพื่อแก้ระบบสมการที่ได้จากการวิเคราะห์แบบ <strong>Mesh Analysis</strong> (ใช้การประมวลผลเชิงสัญลักษณ์ หรือ <strong>Symbolic Processing</strong>) ก็มีแนวทางดังนี้ ซึ่งจะได้ <strong>I1=0.016 A</strong> 
และ <strong>I2=0.004 A</strong> (หรือ <strong>4 mA</strong>) ตามลำดับ</p>
<p>&nbsp;</p>
<p><strong>การเขียนโค้ดแบบทื่ 1</strong>: สร้างสมการแล้วแปลงให้เป็นเมทริกซ์และเวกเตอร์  (<strong>Mesh Analysis</strong>)</p>
<pre><code class="language-matlab">% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% create symbols
syms R1 R2 R3 positive;
syms V1 V2 I1 I2;
% write equations resulting from KVL analysis 
eqn1 = -V1 + I1*R1 + (I1+I2)*R2 == 0;
eqn2 = -(I1+I2)*R2 - I2*R3 + V2 == 0;
eqns = [eqn1, eqn2];
vars = [I1, I2];
% convert the equations into matrix form
[A,b] = equationsToMatrix( eqns, vars )
% solve the linear equation system
sol = A\b;
% substitute circuit parameters with specific values
params = [R1, R2, R3, V1, V2];
values = [500, 200, 250, 12, 5];
I1 = sol(1); I2 = sol(2);
I1 = subs( I1, params, values );
I2 = subs( I2, params, values );
% show the numeric values of current flows I1 and I2
fprintf( &quot;I1=%.3f A, I2=%.3f A&quot;, I1, I2 )
</code></pre>
<p><img alt="" src="matlab_online_livescript-1.png" /></p>
<p>รูป: ตัวอย่างการใช้งาน <strong>MATLAB Online - LiveScript</strong> สำหรับตัวอย่างโค้ดที่ 1</p>
<p>&nbsp;</p>
<p><strong>การเขียนโค้ดแบบทื่ 2</strong>: เขียนให้อยู่ในรูปเมทริกซ์และเวกเตอร์ (<strong>Mesh Analysis</strong>)</p>
<pre><code class="language-matlab">% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% create symbols
syms R1 R2 R3 positive;
syms V1 V2;
% write the corresponding matrix and vector: A*x=b
A = [[(R1+R2), R2]; [R2, (R2+R3)]];
b = [V1; V2];
% solve the equation system using the linsolve() command
sol = linsolve(A,b);
I1  = sol(1); I2 = sol(2);
% substitute circuit parameters with specific values
params = [R1, R2, R3, V1, V2];
values = [500, 200, 250, 12, 5];
I1 = subs( I1, params, values );
I2 = subs( I2, params, values );
% show the numeric values of current flows I1 and I2
fprintf( &quot;I1=%.3f A, I2=%.3f A&quot;, I1, I2 )
</code></pre>
<p>&nbsp;</p>
<p><strong>การเขียนโค้ดแบบทื่ 3</strong>:  สร้างสมการแล้วแปลงให้เป็นเมทริกซ์และเวกเตอร์  (<strong>Nodal Analysis</strong>)</p>
<p>ในตัวอย่างนี้ มีการใช้คำสั่ง <code>equationsToMatrix()</code> เพื่อแปลงรายการของสมการหรือระบบสมการเชิงเส้น
ให้อยู่ในรูปของเมทริกซ์และเวกเตอร์ จากนั้นจึงแก้ระบบสมการเชิงเส้นโดยใช้คำสั่ง <code>linsolve()</code> </p>
<pre><code>% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% create symbols
syms R1 R2 R3 positive;
syms VA VB VC V1 V2;
% write equations resulting from KCL analysis 
eqn1 = (VA - VB)/R1 + (VC - VB)/R3 == VB/R2;
eqn2 = VA == V1;
eqn3 = VC == V2;
eqns = [eqn1, eqn2, eqn3];
vars = [VA,VB,VC];
% convert the equations into matrix form
[A,b] = equationsToMatrix( eqns, vars )
% solve the linear equation system
sol = linsolve(A,b);
cells = num2cell(sol);
[VA, VB, VC] = cells{:};
% substitute circuit parameters with specific values
params = [R1, R2, R3, V1, V2];
values = [500, 200, 250, 12, 5];
V = subs( [VA,VB,VC], params, values );
fprintf( &quot;V_A=%.3f V, V_B=%.3f V, V_C=%.3f&quot;, V(1),V(2),V(3) )
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="rc">&#9655; <strong>วงจร RC และการจำลองการทำงาน</strong><a class="headerlink" href="#rc" title="Permanent link">#</a></h2>
<p>ลองมาวิเคราะห์การทำงานของตัวอย่างวงจรประเภท <strong>RC</strong> ด้วยซอฟต์แวร์ ซึ่งจะเห็นได้ว่า 
วงจรตัวอย่างนี้มีเพียงตัวต้านทาน <strong>R</strong> และ <strong>C</strong> อย่างละหนึ่งตัวเท่านั้น ต่ออนุกรมกันอยู่
และมีแหล่งจ่ายแรงดันไฟฟ้า <strong>VS</strong> ที่สามารถเลือกรูปแบบของสัญญาณให้เป็นแบบ <strong>DC</strong> หรือ <strong>AC</strong> ได้</p>
<p><img alt="" src="easyeda_schematic_capture.png" /></p>
<p>รูป: ตัวอย่างการวาดผังวงจรด้วย <strong>EasyEDA</strong></p>
<p>ในแถบด้านซ้ายมือที่มีชื่อว่า  <strong>Commomly Library</strong> มีชิ้นส่วนของวงจรไฟฟ้าให้เลือกนำมาวางในบริเวณ <strong>Schematic Editor</strong> แล้วต่อกันให้ครบวงจร และจะต้องมีสัญลักษณ์ทางไฟฟ้าสำหรับ <strong>GND</strong> อยู่ในวงจรด้วย</p>
<p>หากต้องการดูการเปลี่ยนแปลงของปริมาณทางไฟฟ้าของวงจรในเชิงเวลา หรือ ผลตอบสนองชั่วครู่ เช่น แรงดันไฟฟ้าจากแหล่งจ่าย
และแรงดันตกคร่อมที่ตัวเก็บประจุ เป็นต้น โดยมีจุดอ้างอิงเป็น <strong>GND</strong> ของวงจร 
ก็สามารถเลือกใช้โหมด <strong>Transient</strong> (<code>.tran</code>) และกดปุ่ม <strong>F8 (Run your simulation)</strong>
เพื่อเริ่มต้นขั้นตอนการจำลองการทำงาน</p>
<p><img alt="" src="rc_circuit-1.png" /></p>
<p>รูป: วงจร <strong>RC</strong> และการวัดแรงดันตกคร่อมที่ตัวเก็บประจุเมื่ออ้างอิงกับ <strong>GND</strong> ของวงจรด้วย <strong>Voltage Probe</strong> </p>
<p><img alt="" src="rc_circuit-2.png" /></p>
<p>รูป: วงจร <strong>RC</strong> และการวัดแรงดันตกคร่อมที่ตัวต้านทานด้วย <strong>Voltage Probe</strong> </p>
<p><strong>ข้อจำกัด</strong>: การจำลองการทำงานในโหมด <strong>Transient</strong> เป็นการคำนวณตามจุดเวลาที่เรียกว่า <strong>Time Step</strong>
และสามารถกำหนดระยะห่างเชิงเวลา เวลาเริ่มต้น และเวลาจบการจำลองการทำงานได้ แต่รวมแล้วจะต้องไม่เกิน <strong>10,000</strong>:
<strong>(stop time - start time)/timestep <script type="math/tex">\leq</script> 10000</strong></p>
<p>ผลการจำลองการทำงานโดย <strong>Simulator</strong> ใน <strong>Waveform Tab</strong>
ผู้ใช้สามารถนำข้อมูลออกโดยบันทึกเป็นไฟล์ <strong>.CSV</strong> ได้ โดยทำคำสั่งจากเมนู <strong>Waveform &gt; Export Waveform</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="rc_1">&#9655; <strong>การจำลองการทำงานของวงจร RC: แหล่งจ่ายเป็นแบบขั้นบันไดและพัลส์</strong><a class="headerlink" href="#rc_1" title="Permanent link">#</a></h2>
<p>ถ้าจะสร้างสัญญาณแรงดันไฟฟ้าให้เป็นแบบขั้นบันได (<strong>Step Function</strong>)
มีการเปลี่ยนแปลงระดับแรงดันไฟฟ้าแบบทันทีในเชิงเวลา 
เช่น ณ เวลา <script type="math/tex">t=0</script> ให้มีแรงดันไฟฟ้าเปลี่ยนจาก <script type="math/tex">0V</script> เป็น <script type="math/tex">5V</script> ก็เลือกใช้แหล่งจ่ายแรงดันไฟฟ้าในโหมด <code>PULSE</code>
และตั้งค่าช่วงที่แรงดันไฟฟ้าเป็นบวกและคาบของสัญญาณให้เท่ากัน และให้มีระยะเวลามากพอ (ดูที่การตั้งค่าสำหรับพารามิเตอร์
<strong>Ton [s]</strong> และ <strong>Tperiod [s]</strong> สำหรับ <strong>Voltage Source Settings</strong>)</p>
<p><img alt="" src="pulse_source_setting-1.png" /></p>
<p>รูป: ตัวอย่างการตั้งค่าสำหรับ <script type="math/tex">V_S</script> แบบ <strong>PULSE</strong> ให้เป็น <strong>5V</strong> ตั้งแต่เวลา <script type="math/tex">t=0</script> เป็นต้นไป</p>
<p>ลองมาดูผลการจำลองการทำงานและแสดงรูปคลื่นสัญญาณ (<strong>Waveform</strong>) สำหรับแรงดันไฟฟ้า <script type="math/tex">V_C</script>
ซึ่งเป็นผลตอบสนองของวงจรจากการเปลี่ยนแปลงของแหล่งจ่าย <script type="math/tex">V_S</script> (เพิ่มระดับแบบขั้นบันได ณ เวลา <strong>t=0</strong>)</p>
<p><img alt="" src="rc_circuit_sim-1.png" /></p>
<p>รูป: ผลตอบสนองของวงจรที่มีต่อการเปลี่ยนแปลงระดับแรงดันไฟฟ้าของแหล่งจ่าย <script type="math/tex">V_S</script>
</p>
<p>&nbsp;</p>
<p>ถ้าต้องการเลือกใช้สัญญาณแบบ <strong>PWM (<em>Pulse Width Modulation</em>) </strong> แล้วดูผลตอบสนองของวงจร
ก็มีตัวอย่างดังนี้ และค่า <strong>Duty Cycle</strong> ของสัญญาณ <strong>PWM</strong> มีนิยามดังนี้</p>
<p>
<script type="math/tex; mode=display">
  \text{Duty Cycle} = \frac{T_{on}}{T_{period}} \times 100 %
</script>
</p>
<p><img alt="" src="pulse_source_setting-2.png" /></p>
<p>รูป: ตัวอย่างการตั้งค่าสำหรับ <script type="math/tex">V_S</script> แบบพัลส์ (<strong>Pulse</strong>) หรือ <strong>PWM</strong>
ให้เป็นสัญญาณแบบมีคาบกว้าง <strong>100ms</strong> (หรือ ความถี่ <strong>10Hz</strong>) และช่วงเวลาที่ <strong>ON</strong>
ให้เป็น <strong>50ms</strong> (หรือ <strong>Duty Cycle</strong> เท่ากับ <strong>50%</strong>)</p>
<p><img alt="" src="rc_circuit_sim-2.png" /></p>
<p>รูป: ผลตอบสนองของวงจรที่มีต่อสัญญาณแบบพัลส์จากแหล่งจ่าย <script type="math/tex">V_S</script>
</p>
<p>การวัดแรงดันตกคร่อม (<strong>Voltage Drop</strong>) ระหว่างสองจุดในวงจรไฟฟ้า อาจใช้สิ่งที่เรียกว่า <strong>Differential Probe</strong> โดยค้นหาอุปกรณ์โดยใช้คำว่า <code>Diff_V_Probe</code> จากไลบรารี <strong>SPICE</strong></p>
<p><img alt="" src="diff_probe_measure.png" /></p>
<p>รูป:  การค้นหา <code>Diff_V_Probe</code> ใน <strong>SPICE Library</strong></p>
<p>ถัดไปให้ลองนำ  <code>Diff_V_Probe</code> มาใช้ในวงจร เช่น วัดแรงดันตกคร่อมที่ตัวเก็บประจุ <script type="math/tex">C_1</script> แล้วแสดงรูปคลื่นสัญญาณจากผลการจำลองการทำงาน</p>
<p><img alt="" src="rc_circuit_diff_probe.png" /></p>
<p>รูป: การใช้ <code>Diff_V_Probe</code> เพื่อวัดแรงดันตกคร่อมที่ตัวเก็บประจุ <script type="math/tex">C_1</script>
</p>
<p>&nbsp;</p>
<p><img alt="" src="rc_circuit_sim-4.png" /></p>
<p>รูป: ผลการจำลองการทำงานที่แสดงรูปคลื่นสัญญาณสำหรับ <script type="math/tex">V_S</script>, <script type="math/tex">V_C</script> และ <script type="math/tex">V_R</script>
</p>
<p>&nbsp;</p>
<p>ในกรณีที่มีการต่อวงจรเพื่อทดลองจริง ผู้ใช้สามารถใช้แหล่งจ่ายที่เป็นเครื่องกำเนิดสัญญาณได้  (<strong>Function Generator</strong>)
เช่น สร้างสัญญาณรูปคลื่นไซน์ รูปคลื่นสามเหลี่ยม และรูปคลื่นสี่เหลี่ยม และใช้เครื่องออสซิลโลสโคป (<strong>Oscilloscope</strong>)
สำหรับการวัดสัญญาณแบบสองช่องได้ ตัวอย่างการวาดผังวงจรมีดังนี้</p>
<p><img alt="" src="signal_generator_setting-1.png" /></p>
<p>รูป: การใช้เครื่องกำเนิดสัญญาณแบบคลื่นสี่เหลี่ยม และะเครื่องออสซิลโลสโคปเพื่อการวัดสัญญาณ <script type="math/tex">V_S</script> และ <script type="math/tex">V_C</script>
เทียบกับ <strong>GND</strong> สำหรับช่องสัญญาณ <strong>A</strong> และ <strong>B</strong> ตามลำดับ</p>
<p>&nbsp;</p>
<hr />
<h2 id="rc_2">&#9655; <strong>การจำลองการทำงานของวงจร RC: แหล่งจ่ายเป็นรูปคลื่นไซน์</strong><a class="headerlink" href="#rc_2" title="Permanent link">#</a></h2>
<p>ในการจำลองการทำงานด้วย <strong>EasyEDA</strong> หากต้องการให้แหล่งจ่าย <script type="math/tex">V_S</script> เป็นรูปคลื่นสัญญาณไฟฟ้าแบบ <strong>AC</strong>
(รูปคลื่นไซน์) ให้เลือกโหมด <code>SINE</code> เช่น ตั้งค่าความถี่ <strong>50Hz</strong> และมีแอมพลิจูด <strong>5V</strong>
และดูผลการจำลองการทำงานในโหมด <strong>Transient</strong> (<code>.tran</code>) ก็มีตัวอย่างดังนี้</p>
<p><img alt="" src="sin_source_setting-1.png" /></p>
<p>รูป: ตัวอย่างการตั้งค่าสำหรับ <script type="math/tex">V_S</script> ให้เป็นสัญญาณแบบไซน์ (<strong>Sine</strong>) </p>
<p><img alt="" src="rc_circuit_sim-3.png" /></p>
<p>รูป: ผลตอบสนองของวงจรที่มีต่อสัญญาณแบบไซน์จากแหล่งจ่าย <script type="math/tex">V_S</script>
</p>
<p>&nbsp;</p>
<hr />
<h2 id="rc_3">&#9655; <strong>การวิเคราะห์วงจร RC: แหล่งจ่ายเป็นรูปคลื่นไซน์</strong><a class="headerlink" href="#rc_3" title="Permanent link">#</a></h2>
<p>จากวงจร <strong>RC</strong> ที่มีตัวต้านทานต่ออนุกรมกับตัวเก็บประจุ สามารถนำเขียนเขียนสมการโดยใช้หลักการ <strong>KVL</strong> ได้ดังนี้
<script type="math/tex; mode=display">
  \mbox{KVL:} \; v_R(t) + v_C(t) = v_S(t) \\
</script>
โดยที่ <script type="math/tex">v_R(t)</script> และ <script type="math/tex">v_C(t)</script> คือ แรงดันตกคร่อมที่ตัว <script type="math/tex">R</script> และตัวเก็บประจุ <script type="math/tex">C</script> ตามลำดับ 
และมี <script type="math/tex">v_S(t)</script> เป็นฟังก์ชันที่มีตัวแปรอิสระเป็นเวลา <script type="math/tex">t</script> และกำหนดรูปแบบของแหล่งจ่ายแรงดันไฟฟ้าในวงจร</p>
<p>กระแสไฟฟ้า <script type="math/tex">i(t)</script> เป็นกระแสที่ไหลผ่าน <script type="math/tex">R</script> และ <script type="math/tex">C</script> ในวงจรตัวอย่าง เป็นกระแสเดียวกัน ดังนั้นจึงเขียนความสัมพันธ์ได้ดังนี้
<script type="math/tex; mode=display">
  i(t) = i_R(t) = i_C(t) \\
</script>
</p>
<p>จากคุณสมบัติและความสัมพันธ์ระหว่างแรงดันไฟฟ้าและกระแสไฟฟ้าสำหรับ <script type="math/tex">R</script> กับ <script type="math/tex">C</script>
<script type="math/tex; mode=display">
  v_R(t) = R\, i_R(t) \\
  i_C(t) = C \frac{d v_C(t)}{dt} = C v'_C(t) \\
</script>
</p>
<p>ก็สามารถเขียนสมการเชิงอนุพันธ์สามัญอันดับหนึ่ง (<strong>First-Order ODE</strong>) ได้ดังนี้
<script type="math/tex; mode=display">
\begin{align}
       v_R(t) + v_C(t) &= v_S(t) \\
   R\, i_R(t) + v_C(t) &= v_S(t) \\
  RC\,v'_C(t) + v_C(t) &= v_S(t) \\
\end{align}
</script>
</p>
<p>หากเลือกแหล่งจ่าย <script type="math/tex">v_S(t)</script> เป็นแรงดันไฟฟ้ากระแสสลับ หรือ <strong>AC</strong> 
สำหรับใช้เป็นสัญญาณอินพุตของระบบหรือสัญญาณกระตุ้น ก็ให้ใช้รูปสัญญาณไซน์ที่มีแอมพลิจูด <script type="math/tex">V_S</script> 
และมีความถี่เชิงมุม <script type="math/tex">\omega</script> ซึ่งเป็นค่าคงที่</p>
<p>
<script type="math/tex; mode=display">
  v_S(t) = V_S \, sin(\omega t),\; V_S > 0,\; \omega = 2\pi f = \frac{2\pi}{T} \\
</script>
</p>
<p>สมการเชิงอนุพันธ์ซึ่งเป็นเชิงเส้นและมีสัมประสิทธิ์เป็นค่าคงตัวในกรณีนี้คือ 
<script type="math/tex; mode=display">
\begin{align}
           RC\, v'_C(t) + v_C(t) &= V_S \, sin(\omega t) \\
   v'_C(t) + \frac{1}{RC} v_C(t) &= \frac{V_S}{RC} \, sin(\omega t) \\
\end{align}
</script>
ในตัวอย่างนี้การหาผลเฉลยของ <strong>ODE</strong> ก็คือ การหาฟังก์ชัน <script type="math/tex">v_C(t)</script> สำหรับช่วงเวลา <script type="math/tex">t \geq 0</script> เป็นต้นไป ที่ทำให้สมการเชิงอนุพันธ์นี้เป็นจริง ถ้าทราบรูปแบบของฟังก์ชันสำหรับ <script type="math/tex">v_C(t)</script> แล้ว ก็สามารถหา <script type="math/tex">v_R(t)</script> ในวงจร <strong>RC</strong> โดยคำนวณจาก
<script type="math/tex; mode=display">
  v_R(t) = R \cdot i(t) = RC \frac{d}{dt} v_C(t)
</script>
</p>
<p>&nbsp;</p>
<p>ผลเฉลยของสมการเชิงอนุพันธ์ในลักษณะนี้ หรืออาจเรียกว่า "ผลตอบสนองโดยสมบรูณ์" (<strong>Complete Response</strong>)
ก็ได้จากผลรวมของผลตอบสนองทางธรรมชาติและผลตอบสนองบังคับ: <script type="math/tex">y(t) = y_h(t) + y_p(t)</script>
</p>
<p>&nbsp;</p>
<h4 id="_2"><strong>การหาผลตอบสนองทางธรรมชาติ</strong><a class="headerlink" href="#_2" title="Permanent link">#</a></h4>
<p>&nbsp;</p>
<p>หากกำหนดให้ <script type="math/tex">v_S(t) = 0</script> ก็จะได้สมการที่เป็นเอกพันธ์ (<strong>Homogeneous ODE</strong>) และหาสมการลักษณะเฉพาะ (<strong>Characteristic Equation</strong>) และรากของสมการที่เกี่ยวข้องได้ดังนี้
<script type="math/tex; mode=display">
   v'_C(t) + \frac{1}{RC} v_C(t) = 0 \\
   (s+\frac{1}{RC}) = 0 \Rightarrow s = -1/(RC) \\
</script>
ผลเฉลยของสมการเอกพันธ์จะเรียกว่า "ผลตอบสนองทางธรรมชาติ" (<strong>Natural Response</strong>) ของวงจร <strong>RC</strong> 
<script type="math/tex; mode=display">
   y_h(t) = K e^{-t/RC} = K\,e^{-t/\tau}, \; \tau := RC \\
</script>
โดยที่ <script type="math/tex">\tau=RC</script> (เรียกว่า <strong>Time Constant</strong>) และมีสัญลักษณ์ <script type="math/tex">K</script> เป็นค่าคงที่  และก็ขึ้นอยู่กับค่าเริ่มต้น <script type="math/tex">v_C(0)</script> ที่เวลา <script type="math/tex">t=0</script> (<strong>Initial Condition</strong>) </p>
<p>หาก  <script type="math/tex">v_C(0) \neq 0</script> ก็หมายความว่า มีพลังงานหรือประจุไฟฟ้าเก็บอยู่ในตัวเก็บประจุ ถ้าให้ <script type="math/tex">v_C(0) = V_0</script> ดังนั้นจะได้ <script type="math/tex">y_h(t)</script> ดังนี้
<script type="math/tex; mode=display">
  y_h(0) = K\, e^{0/\tau} = V_0 \; \Rightarrow \; y_h(t) = V_0\, e^{-t/\tau} \\
\\
</script>
</p>
<h4 id="_3"><strong>การหาผลตอบสนองบังคับ</strong><a class="headerlink" href="#_3" title="Permanent link">#</a></h4>
<p>&nbsp;</p>
<p>แต่ถ้าสมมุติว่า  <script type="math/tex">v_C(0) = 0</script> ไม่มีพลังงานเก็บไว้ในตัวเก็บประจุ (กรณีนี้เรียกว่า <strong>Zero Initial Condition</strong>) และให้ <script type="math/tex">v_S(t) = V_S\, sin(\omega t)</script> ผลเฉลยของสมการเชิงอนุพันธ์ที่ไม่เป็นเอกพันธ์ (<strong>Non-homogeneous</strong>) จะเรียกว่า  "ผลเฉลยเจาะจง" (<strong>Particular Solution</strong>) หรือ "ผลตอบสนองบังคับ" (<strong>Forced Reponse</strong>) </p>
<p>สำหรับฟังก์ชันรูปคลื่นไซน์ จะมีรูปแบบของฟังก์ชันที่เป็นผลเฉลยดังนี้
<script type="math/tex; mode=display">
   y_p(t) = A\, sin(\omega t) + B\, cos(\omega t)  \\
</script>
โดยที่ <script type="math/tex">A</script> และ <script type="math/tex">B</script> เป็นค่าคงที่ และอนุพันธ์อันดับหนึ่งของฟังก์ชัน เป็นดังนี้
<script type="math/tex; mode=display">
  y'_p(t) = \frac{d}{dt} y_p(t) = A\omega\, cos(\omega t) - B\omega\,sin(\omega t) \\
</script>
ดังนั้นถ้าให้ <script type="math/tex">v_C(t) := y_p(t)</script> แล้วนำไปแทนลงสมการ <strong>ODE</strong> ก็จะเขียนได้ใหม่ดังนี้
<script type="math/tex; mode=display">
   v'_C(t) + \frac{1}{RC} v_C(t) = \frac{V_S}{RC} \, sin(\omega t) \\
\Rightarrow  A\omega\, cos(\omega t) - B\omega\,sin(\omega t) 
  + \frac{1}{RC} [ A\, sin(\omega t) + B\, cos(\omega t) ]
  \\ = \frac{V_S}{RC} \, sin(\omega t) \\
</script>
จัดกลุ่มใหม่จะได้
<script type="math/tex; mode=display">
   \underbrace{[A\omega + \frac{B}{RC}]}_{0}\, cos(\omega t)
   + [\frac{A}{RC} - B\omega]\,sin(\omega t)
  = \frac{V_S}{RC} \, sin(\omega t) \\
</script>
ดังนั้นจึงสามารถเขียนเงื่อนไขที่จะทำให้สมการเป็นจริงได้ดังนี้<br />
<script type="math/tex; mode=display">
  A\omega + \frac{B}{RC} = 0\; \mbox{ และ  }
  \frac{A}{RC} - B\omega = \frac{V_S}{RC} \\
</script>
<script type="math/tex">A</script> และ <script type="math/tex">B</script> จะได้จากการแก้ระบบสมการเชิงเส้นสองตัวแปรตามเงื่อนไขข้างต้น
<script type="math/tex; mode=display">
  A = \frac{1}{1 + \omega^2 (RC)^2} V_S = \frac{1}{1 + \omega^2\tau^2} V_S  \\
  B = -\frac{\omega RC}{1 + \omega^2 (RC)^2} V_S = -\frac{\omega\tau}{1 + \omega^2 \tau^2} V_S \\
</script>
ดังนั้นจะได้ฟังก์ชัน <script type="math/tex">y_p(t)</script> ที่เป็นผลเฉลยดังนี้
<script type="math/tex; mode=display">\begin{align}
  y_p(t) &= A\, sin(\omega t) + B\, cos(\omega t) \\
         &= \frac{1}{1 + \omega^2\tau^2} V_S\, sin(\omega t) 
           -\frac{\omega\tau}{1 + \omega^2 \tau^2} V_S\, cos(\omega t)
\end{align}</script>
</p>
<p>โดยสรุป ผลตอบสนองโดยสมบรูณ์สำหรับ <script type="math/tex">t \geq 0</script>
</p>
<p>
<script type="math/tex; mode=display">
\begin{align}
  v_C(t) &= y_h(t) + y_p(t) \\
       &= K\,e^{-t/\tau} + \frac{1}{1 + \omega^2\tau^2} V_S\, sin(\omega t) 
           -\frac{\omega\tau}{1 + \omega^2 \tau^2} V_S\, cos(\omega t)
\end{align}
</script>
</p>
<p>และถ้ากำหนดให้ <script type="math/tex">v_C(0) = V_0</script> ดังนั้นค่าคงที่ <script type="math/tex">K</script> ในสมการ จะเป็นดังนี้</p>
<p>
<script type="math/tex; mode=display">
  K  = V_0 + \frac{\omega\tau}{1 + \omega^2 \tau^2} V_S
</script>
</p>
<p>&nbsp;</p>
<hr />
<h2 id="rc_4">&#9655; <strong>การวิเคราะห์วงจร RC: แรงดันแบบขั้นบันได</strong><a class="headerlink" href="#rc_4" title="Permanent link">#</a></h2>
<p>จากสมการเชิงอนุพันธ์สำหรับวงจร <strong>RC</strong> </p>
<p>
<script type="math/tex; mode=display">
   v'_C(t) + \frac{1}{RC} v_C(t) = \frac{1}{RC} v_S(t) \\
</script>
</p>
<p>ถ้าให้ <script type="math/tex">v_S(t)</script> เป็นแหล่งจ่ายกระแสตรง โดยมีการเปลี่ยนแปลงแบบขั้นบันได (<strong>Step Function</strong>) ที่เกิดขึ้น ณ เวลา <script type="math/tex">t=0</script> ดังนี้</p>
<p>
<script type="math/tex; mode=display">
  v_S(t) = \begin{cases}
   V_S & t \geq 0 \\
   0   & t < 0 \\
  \end{cases}
</script>
</p>
<p>ผลตอบสนองสมบรูณ์ <script type="math/tex">v_C(t)</script> สำหรับวงจร <strong>RC</strong> จะเป็นดังนี้
<script type="math/tex; mode=display">
\begin{align}
  v_C(t) &= V_0\, e^{-t/\tau} + V_S\,(1 - e^{-t/\tau}), \; t \geq 0 \\
  v_C(0) &= V_0
\end{align}
</script>
</p>
<p>&nbsp;</p>
<hr />
<h2 id="rc-matlab">&#9655; <strong>การวิเคราะห์วงจร RC ด้วย MATLAB</strong><a class="headerlink" href="#rc-matlab" title="Permanent link">#</a></h2>
<p>ลองมาดูตัวอย่างโค้ด <strong>MATLAB</strong> สำหรับการวิเคราะห์วงจร <strong>RC</strong> 
หากสามารถกำหนดรูปแบบของสมการเชิงอนุพันธ์สำหรับวงจร <strong>RC</strong> ได้แล้ว
ก็สามารถหาผลเฉลยโดยใช้เทคนิคการคำนวณเชิงสัญลักษณ์ทางคณิตศาสตร์ (<strong>Symbolic Math Processing</strong>) </p>
<p>&nbsp;</p>
<h4 id="_4"><strong>กรณีที่ใช้แหล่งจ่ายแรงดันไฟฟ้ารูปคลื่นไซน์</strong><a class="headerlink" href="#_4" title="Permanent link">#</a></h4>
<p>&nbsp;</p>
<pre><code class="language-matlab">% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% define symbols to be used for formulating the ODE
syms t R C V0 V_S omega tau v_C(t) v_S(t) 
% voltage source (sinusoidal)
v_S(t) = V_S * sin(omega * t)
% ODE (first-order)
ode = diff(v_C(t),t) + (1/(R*C))*v_C(t) == v_S(t)/(R*C)
% intial condition
ic = v_C(0)==V0
% solve the ODE to determine v_C(t)
sol = dsolve( ode, ic );
% substitute RC with tau
sol = subs( sol, R*C, tau )
% check whether v_C(0) is equal to V0 (should be true)
isAlways(subs( sol, t, 0 )==V0)
% resistor value (Ohm)
R_value = 1000; 
% capacitor value (Farad)
C_value = 10*10^-6; 
% frequency (Hz) of the sinusoidal voltage source 
freq = 50;
% amplitude (Volt) of the sinusoidal voltage source 
VS = 5.0;
% list of parameters
params = [V_S, omega, tau, V0];
% specific values for the parameters
values = [VS, 2*pi*freq, R_value*C_value, 0];
% substitute circuit parameters with the specific values
v_C(t) = subs( sol, params, values )
v_S(t) = subs( v_S(t), params, values )
% set time interval = 0..100 msec
tspan = [0, 0.1]; 
% plot both v_S(t) and v_C(t) functions
fplot( [v_S(t),v_C(t)], tspan ), 
grid on, xlabel('t')
</code></pre>
<p>&nbsp;</p>
<p><img alt="" src="matlab_output-1.png" /></p>
<p>รูป: ตัวอย่างการใช้งาน <strong>MATLAB LiveScript</strong> แบบออนไลน์ใน <strong>MATLAB Cloud</strong></p>
<p>ผลเฉลยของสมการอนุพันธ์สำหรับวงจร <strong>RC</strong> ในกรณีที่ <script type="math/tex">v_S(t)</script> เป็นสัญญาณไซน์ จะได้ดังนี้ 
<script type="math/tex; mode=display"> 
 v_C(t) = e^{-t/\tau} \Big( V_0 + \frac{V_S\,\omega}{\tau\big(\omega^2 + \frac{1}{\tau^2}\big)} \Big)
+ \frac{V_S\big(-\omega\,cos(\omega t) + sin(\omega t)/\tau\big)}{\tau\big(\omega^2 + \frac{1}{\tau^2}\big)}
</script>
</p>
<p>หากรันโค้ดสำหรับ <strong>MATLAB</strong> จะมีการแสดงรูปกราฟดังนี้ โดยกำหนดให้ <script type="math/tex">v_C(0) = V_0 = 0</script>,
<script type="math/tex">R=1000\Omega</script>, <script type="math/tex">C=10uF</script>, <script type="math/tex">VS=5V</script>, <script type="math/tex">f=50Hz</script>
</p>
<p><img alt="" src="matlab_figure_v_c_plot-1.png" /></p>
<p>รูป: ตัวอย่างการแสดงรูปกราฟสำหรับ <script type="math/tex">v_S(t)</script> และ <script type="math/tex">v_C(t)</script>
</p>
<p>ให้ลองเปรียบเทียบกับรูปคลื่นสัญญาณที่ได้จากการจำลองการทำงานด้วย <strong>EasyEDA - LTspice Simulator</strong>
ในโหมด <strong>Transient</strong> สำหรับช่วงเวลา <script type="math/tex">t=0 .. 100ms</script>
</p>
<p>ถ้าให้ <script type="math/tex">t</script> มีค่ามากพอ พจน์ที่มี <script type="math/tex">e^{-t/\tau}</script> จะลู่เข้า <script type="math/tex">0</script> หรือกล่าวได้ว่า <script type="math/tex">v_C(t)</script> จะเข้าสู่สภาวะคงตัว และได้ผลตอบสนองสภาวะคงตัว (<strong>Steady-State Response</strong>) ดังนี้</p>
<p>
<script type="math/tex; mode=display">\begin{align}
 v_C(t) &= \frac{V_S\big(-\omega\,cos(\omega t) + sin(\omega t)/\tau\big)}{\tau\big(\omega^2 + \frac{1}{\tau^2}\big)} \\
        &= 
    \frac{1}{1 + \omega^2\tau^2} V_S\, sin(\omega t)
   -\frac{\omega\tau}{1 + \omega^2\tau^2} V_S\, cos(\omega t) \\
\\
\end{align}</script>
</p>
<p>&nbsp;</p>
<h4 id="_5"><strong>กรณีที่ใช้แหล่งจ่ายแรงดันไฟฟ้าแบบขั้นบันได</strong><a class="headerlink" href="#_5" title="Permanent link">#</a></h4>
<p>&nbsp;</p>
<p>ถ้าให้ <script type="math/tex">v_S(t)</script> เป็นฟังก์ชันแบบขั้นบันได
<script type="math/tex; mode=display">
  v_S(t) = \begin{cases}
   V_S & t \geq 0 \\
   0   & t < 0 \\
  \end{cases}
</script>
</p>
<p>โค้ด <strong>MATLAB</strong> สำหรับหาผลเฉลยมีดังนี้</p>
<pre><code class="language-matlab">% define symbols to be used for formulating the ODE
syms t R C V_S tau V0 v_C(t) v_R(t) v_S(t) 
% voltage source: step function (Heaviside)
v_S(t) = V_S * heaviside(t);
% ODE (first-order)
ode = diff(v_C(t),t) + (1/(R*C))*v_C(t) == v_S(t)/(R*C);
% intial condition
ic = v_C(0)==V0;
% solve the ODE to determine v_C(t)
assume( t, 'positive' )
sol = simplify( dsolve( ode, ic ), 'Steps', 10 )
% resistor value for R (Ohm)
R_value = 1000; 
% capacitor value for C (Farad)
C_value = 10*10^-6;
% step height V_S (Volt)
VS = 5.0;
% list of parameters
params = [V_S, tau, V0];
% specific values for the parameters
values = [VS, R_value*C_value, 0];
assume(t, 'real');
% substitute the parameters in v_C(t) with the specific values
v_C(t) = subs( sol, params, values )*heaviside(t);
v_R(t) = subs( tau*diff(v_C(t), t), params, values );
% substitute the parameters in v_S(t) with the specific values
v_S(t) = subs( v_S(t), V_S, VS );
% set time interval = -20msec .. 120 msec
tspan = [-0.02, 0.12]; 
% plot both v_S(t) and v_C(t) functions
fplot( [v_S(t), v_C(t), v_R(t)], tspan, 'linewidth', 1.2 ), 
grid on, xlabel('t'), ylim([-1 6]),
legend({'v_S(t)','v_C(t)','v_R(t)'} )
</code></pre>
<p>ตัวอย่างการรันโค้ด (บางส่วน)</p>
<p><img alt="" src="matlab_output-2.png" /></p>
<p>รูป: การคำนวณด้วย <strong>MATLAB</strong> เพื่อหาผลตอบสนองสำหรับอินพุตที่เป็นฟังก์ชันขั้นบันได</p>
<p>ผลเฉลยของสมการอนุพันธ์ หรือ ผลตอบสนองสมบรูณ์ของระบบสำหรับ <script type="math/tex">v_C(t)</script> เป็นไปตามสมการต่อไปนี้
<script type="math/tex; mode=display">
  v_C(t) = V_S + e^{-t/\tau}(-V_S + V_0), \; \tau = RC \\
\\
</script>
</p>
<p>การแสดงรูปกราฟด้วย <strong>MATLAB</strong> ได้ใช้ค่าสำหรับพารามิเตอร์ดังนี้ <script type="math/tex">R=1000\Omega</script>, 
<script type="math/tex">C=10uF</script>, <script type="math/tex">V_S=5V</script>, <script type="math/tex">V_0=0V</script>
</p>
<p><img alt="" src="matlab_figure_v_c_plot-2.png" /></p>
<p>รูป: การแสดงรูปกราฟสำหรับ <script type="math/tex">v_S(t)</script>, <script type="math/tex">v_C(t)</script> และ  <script type="math/tex">v_R(t)</script> โดยให้ <script type="math/tex">V_0=0V</script> และ <script type="math/tex">V_S=5V</script>
</p>
<p>&nbsp;</p>
<hr />
<h2 id="rc-python">&#9655; <strong>การวิเคราะห์วงจรอนุกรม RC ด้วย Python</strong><a class="headerlink" href="#rc-python" title="Permanent link">#</a></h2>
<p>จากตัวอย่างการเขียนโค้ด <strong>MATLAB</strong> เพื่อหาผลตอบสนองของระบบ เมื่อมีแหล่งจ่ายเป็นแบบขั้นบันได เช่น เปลี่ยนจาก <strong>0V</strong>
เป็น <strong>5V</strong> ณ เวลา <strong>t=0</strong> ถัดไปลองมาดูตัวอย่างการเขียนโค้ด <strong>Python 3</strong> โดยใช้ไลบรารี เช่น <a href="https://www.sympy.org/en/index.html"><code>sympy</code></a> 
สำหรับการประมวลผลเชิงสัญลักษณ์ การหาผลเฉลยของ <strong>ODE</strong> และการใช้ <a href="https://numpy.org/"><code>numpy</code></a> สำหรับการประมวลผลเชิงตัวเลข และใช้ <a href="https://matplotlib.org/"><code>matplotlib</code></a> สำหรับการแสดงรูปกราฟ</p>
<pre><code class="language-python">from sympy import *
import numpy as np
import matplotlib.pyplot as plt 

# use t as time (independent variable)
t = Symbol('t')
# define other symbols
R, C, VS = symbols('R C VS')
i,v_C,v_R,v_S = symbols('i v_C v_R v_S', cls=Function)
# define the time constant (tau)
tau = R*C
# define the ODE for the RC circuit
eqn = Eq(Derivative(v_C(t),t) + v_C(t)/tau - VS/tau,0)
# use SymPy's dsolve() to solve the ODE
sol = dsolve(eqn, func=v_C(t), t=t, ics={v_C(0):0} )
# define the unit-step function as a piecewise function  
unit_step = Piecewise( (0,t&lt;0), (1,t&gt;=0) )
# note: The value of the function is 0 for t &lt; 0.
v_C = sol.rhs * unit_step
v_R = tau * diff(v_C, t) * unit_step
v_S = VS * unit_step

# substitute all parameters in v_C(t) with specific values 
params = [R, C, VS]
values = [1000, 10*10**-6, 5] 
pairs = list( zip(params,values) )

# list funtions to be visuallized by matplotlib
funcs = [ v_S, v_C, v_R ]
funcs = [f.subs(pairs) for f in funcs]
funcs_np = [lambdify(t,f,'numpy') for f in funcs]

# plot the functions for the specified time interval
ts = np.linspace(-0.02, 0.12, 1000, False )
linestyles =  ['-','--', '-.']
for i, f in enumerate(funcs_np):
    plt.plot( ts, f(ts), linestyle=linestyles[i] )
plt.xlabel('t')
plt.legend( ['v_S(t)', 'v_C(t)', 'v_R(t)'], loc=1 )
plt.grid(True)
plt.show()
</code></pre>
<p>หากเปรียบเทียบรูปกราฟที่ได้จากโค้ด <strong>Python</strong> กับรูปกราฟที่ได้จาก <strong>MATLAB</strong> ก็จะเห็นว่าได้ผลเหมือนกัน</p>
<p><img alt="" src="rc_matplotlib_plot.png" /></p>
<p>รูป:  การแสดงรูปกราฟสำหรับ <script type="math/tex">v_S(t)</script>, <script type="math/tex">v_C(t)</script> และ  <script type="math/tex">v_R(t)</script> โดยให้ <script type="math/tex">V_0=0V</script> และ <script type="math/tex">V_S=5V</script>
</p>
<p>&nbsp;</p>
<hr />
<h2 id="rlc_1">&#9655; <strong>การวิเคราะห์วงจรอนุกรม RLC</strong><a class="headerlink" href="#rlc_1" title="Permanent link">#</a></h2>
<p>ถัดไปเป็นวงจรอนุกรมที่ประกอบด้วย <script type="math/tex">R</script>
<script type="math/tex">L</script>
<script type="math/tex">C</script> อย่างละหนึ่งตัว (หรือ <a href="https://en.wikipedia.org/wiki/RLC_circuit"><strong>RLC Circuit</strong></a>) ต่ออนุกรมกันร่วมกับแหล่งจ่าย <script type="math/tex">V_S(t)</script>
และสามารถเขียนสมการแสดงความสัมพันธ์ของปริมาณทางไฟฟ้าได้ดังนี้</p>
<p><img alt="" src="rlc_series_circuit.png" /></p>
<p>รูป: วงจรอนุกรม <strong>RLC</strong> และการวัดแรงดันไฟฟ้าของแหล่งจ่าย <script type="math/tex">v_S(t)</script> และแรงดันตกคร่อมที่ตัวเก็บประจุ <script type="math/tex">v_C(t)</script>
</p>
<p>
<script type="math/tex; mode=display">
 \text{KVL: }\quad -v_S(t) + v_R(t) + v_L(t) + v_C(t) = 0 \\
</script>
</p>
<p>โดยที่ <script type="math/tex; mode=display">\begin{align}
 v_R(t) &= R\, i_R(t) \\
 i_C(t) &= C \frac{d}{dt} v_C(t) \Rightarrow v'_C(t) = \frac{1}{C} i_C(t) \\
 v_L(t) &= L \frac{d}{dt} i_L(t) \Rightarrow i'_L(t) = \frac{1}{L} v_L(t) \\
   i(t) &= i_R(t) = i_C(t) = i_L(t) \\
\end{align}</script>
</p>
<p>หรือเขียนเป็นระบบของสมการอนุพันธ์สามัญสำหรับตัวแปร <script type="math/tex">v_C(t)</script> และ <script type="math/tex">i(t)</script> ได้ดังนี้
<script type="math/tex; mode=display">\begin{align}
 v'_C(t) &= \frac{1}{L} i(t) \\
 i'(t)   &= \frac{1}{L}(- R\, i(t) - v_C(t)) + \frac{1}{L}v_S(t) \\
\end{align}</script>
</p>
<p>หรือเขียนให้อยู่ในรูปเมทริกซ์ (<strong>Matrix Form</strong>)</p>
<p>
<script type="math/tex; mode=display">
\frac{d}{dt}
\begin{pmatrix}
 v_C(t) \\
 i(t)   \\
\end{pmatrix}
= 
\begin{pmatrix}
 0 & \frac{1}{L}  \\
 -\frac{1}{L} & -\frac{R}{L} \\
\end{pmatrix}
\begin{pmatrix}
 v_C(t) \\
 i(t)   \\
\end{pmatrix}
+
\begin{pmatrix}
  0 \\
 \frac{1}{L}v_S(t) \\
\end{pmatrix}
</script>
และมีเงื่อนไขเริ่มต้น (<strong>Initial Conditions</strong>) ดังนี้
หากพิจารณาการเปลี่ยนแปลงที่เกิดขึ้นตั้งแต่เวลา <script type="math/tex">t \geq 0</script> เป็นต้นไป
<script type="math/tex; mode=display">
  v_C(0) = V_0 \text{ และ } i(0) = I_0 \\
</script>
ซึ่ง <script type="math/tex">V_0</script> หมายถึง แรงดันตกคร่อมที่ตัวเก็บประจุ <script type="math/tex">C</script> และ <script type="math/tex">I_0</script>
หมายถึง ปริมาณกระแสที่ไหลผ่านตัวเหนี่ยวนำ <script type="math/tex">L</script> ณ เวลา <script type="math/tex">t=0</script>
</p>
<p>หากต้องการเขียนให้อยู่ในรูปของสมการเชิงอนุพันธ์อันดับสอง ก็ทำได้ดังนี้</p>
<p>
<script type="math/tex; mode=display">
  v_R(t) + v_C(t) + v_L(t) = v_S(t) \\
  R\,i(t) + \frac{1}{C}\int_0^t i(\tau)d\tau + v_C(0) + L\frac{dt}{dt} i(t) = v_S(t)
</script>
</p>
<p>ถ้านำสมการนี้ไปหาอนุพันธ์ตามตัวแปร <script type="math/tex">t</script> อีกหนึ่งครั้ง จะได้เป็น</p>
<p>
<script type="math/tex; mode=display">
  R\,\frac{d}{dt} i(t) +  \frac{1}{C}i(t) + L\, \frac{d^2}{dt^2} i(t) = \frac{d}{dt} v_S(t) \\
  \frac{d^2}{dt^2} i(t) + \frac{R}{L}\frac{d}{dt} i(t) + \frac{1}{LC} i(t) 
   = \frac{1}{L} \frac{d}{dt} v_S(t) \\
</script>
</p>
<p>ในหลายตำรา จะมีการเขียนรูปสมการ <strong>ODE</strong> ดังนี้
<script type="math/tex; mode=display">
  \frac{d^2}{dt^2} i(t) + 2\alpha \frac{d}{dt} i(t) 
   + \omega_{0}^{2}\, i(t) = \frac{1}{L}\frac{d}{dt} v_S(t) \\
</script>
โดยมีการใช้สัญลักษณ์ค่าคงที่  <script type="math/tex">\alpha = \frac{R}{2L}</script> และ <script type="math/tex">\omega_{0} = \frac{1}{\sqrt{LC}}</script>
</p>
<p>&nbsp;</p>
<p>ลองมาดูตัวอย่างการคำนวณด้วย <strong>MATLAB</strong> โดยกำหนดให้
<script type="math/tex">v_S(t) = 2V</script> เป็นฟังก์ชันแบบขั้นบันไดซึ่งเปลี่ยนจาก <script type="math/tex">0V</script> 
เป็น <script type="math/tex">2 V</script> ที่เวลา <script type="math/tex">t=0</script> และให้ <script type="math/tex">R=10 \Omega</script>, <script type="math/tex">L=1 H</script>,
<script type="math/tex">C=1/9 F</script>, <script type="math/tex">V_0=3 V</script>, <script type="math/tex">I_0=1/3 A</script> ตามลำดับ เป็นค่าตัวเลขสำหรับตัวอย่างในการคำนวณ</p>
<pre><code class="language-matlab">% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% define symbols to be used for formulating the ODE
syms t R L C VS V0 I0 v_C(t) i(t)
eq1 = diff(v_C(t),t) == i(t)/C;
eq2 = diff(i(t),t) == (VS - i(t)*R - v_C(t))/L;
% state equations
eqn = [eq1, eq2];
% initial condition
ic = [i(0)==I0, v_C(0)==V0];
% solve the ODE system with initial conditions
sol = dsolve( eqn, ic );
v_C(t) = simplify( sol.v_C );
i(t) = simplify( sol.i );
% set specific values for the parameters of the circuit
params = [R, L, C, VS, V0, I0 ];
values = [10, 1, 1/9, 2, 3, 1/3 ];
v_C(t) = simplify( subs( v_C(t), params, values ) )
</code></pre>
<p><img alt="" src="matlab_output-3.png" /></p>
<p>รูป: การคำนวณด้วย <strong>MATLAB</strong> เพื่อหาผลตอบสนองสำหรับอินพุตที่เป็นฟังก์ชันขั้นบันไดสำหรับวงจร <strong>Series RLC</strong></p>
<p>&nbsp;</p>
<p>ถัดไปลองมาดูอีกตัวอย่างหนึ่งที่เป็นวงจรอนุกรม <strong>R L C</strong> แต่มีการต่อทรานซิสเตอร์-มอสเฟตชนิดพี (<strong>P-channel MOSFET</strong>) เบอร์ <a href="https://www.infineon.com/dgdl/irf7204pbf.pdf?fileId=5546d462533600a4015355f14dbe1ade"><strong>IRF7204</strong></a> ที่ทำหน้าที่เป็นสวิตช์เปิด-ปิดการเชื่อมต่อกับแหล่งจ่ายแรงดันไฟฟ้าคงที่ <strong>VS2</strong> เช่น <strong>5V</strong> และมีแหล่งจ่ายแรงดัน <strong>VS1</strong> ที่ได้เลือกฟังก์ชันการทำงานเป็นแบบ <strong>PULSE</strong> (ใช้งานเป็นฟังก์ชันแบบขั้นบันไดในช่วงเวลาเริ่มต้น เช่น เปลี่ยนจาก <strong>0V</strong> เป็น <strong>5V</strong>) ทำหน้าที่ควบคุมการทำงานของมอสเฟต</p>
<p><img alt="" src="rlc_circuit-1.png" /></p>
<p>รูป: วงจร <strong>Series RLC</strong> ที่มีทรานซิสเตอร์แบบมอสเฟตควบคุมการเชื่อมต่อกับแหล่งจ่าย <strong>VS2</strong></p>
<p>อีกรูปแบบหนึ่งคือ การใช้สวิตช์ปรกติทั่วไป แต่ตั้งค่าเริ่มต้น (<strong>Initial Conditions</strong>) ในการจำลองการทำให้ถูกต้อง
เช่น เมื่อ <strong>t=0</strong> ให้แรงดันตกคร่อมที่ตัวเก็บประจุ <strong>C1</strong> เท่ากับ <strong>5.0V</strong> และใช้เป็นเงื่อนไขเริ่มต้นในการทำงาน 
(เขียนข้อความว่า <code>ic=5.0</code> ต่อท้ายค่าของตัวเก็บประจุในข้อความ <strong>SPICE text</strong>)
และกระแสไฟฟ้าที่ไหลผ่านตัวเหนี่ยวนำ <strong>L1</strong> เท่ากับ <strong>-0.25A</strong></p>
<p><img alt="" src="rlc_sim_switch.png" /></p>
<p>รูป: วงจร <strong>Series RLC</strong> ที่ใช้สวิตช์แบบเปิด-ปิดการเชื่อมต่อกับแหล่งจ่าย <strong>VS2</strong> </p>
<p>หากต้องการวัดแรงดันตกคร่อมที่ขาของ <strong>R,L,C</strong> ก็สามารถใช้ <strong>Differential Probes</strong> ในการจำลองการทำงานด้วย <strong>EasyEDA</strong> ตามตัวอย่างดังนี้</p>
<p><img alt="" src="rlc_sim_diff_probes.png" /></p>
<p>รูป: การใช้ <strong>Differntial Probes</strong> ในการวัดแรงดันไฟฟ้าตกคร่อมเมื่อจำลองการทำงาน</p>
<p><strong>ข้อสังเกต</strong>: หากพิจารณาทิศทางของกระแสและแรงดันตกคร่อมของ <strong>R L C</strong> ในวงจรสำหรับการวิเคราะห์วงจรตามที่ได้นำเสนอไปแล้วนั้น จะเห็นว่า <script type="math/tex">v_1 = -v_L(t)</script> ซึ่งมีทิศทางตรงข้ามกัน <script type="math/tex">v_2 = v_C(t)</script> และ <script type="math/tex">v_1 - v_2 = V_R(t)</script>
</p>
<p>ในช่วงเริ่มต้น แรงดันไฟฟ้าของ <strong>VS1</strong> เป็น <strong>0V</strong> ความต่างศักย์ไฟฟ้าระหว่างขา <strong>G (Gate)</strong> และขา <strong>S (Source)</strong> หรือ <script type="math/tex">V_{GS}</script> ได้เท่ากับ <strong>-5V</strong> และต่ำกว่า <script type="math/tex">V_{GS(th)}</script> ของมอสเฟตตัวนี้ หรือที่เรียกว่า "แรงดันเทรชโฮลด์" (<strong>Threshold Voltage</strong>) ซึ่งอยู่ในช่วง <strong>-1.0V .. -2.5V</strong> (น้อยกว่า <strong>0V</strong>)</p>
<p>เมื่อ <script type="math/tex">V_{GS} < V_{GS(th)} < 0</script> ส่งผลให้มอสเฟตชนิดนี้ มีค่าความต้านทานต่ำมากและนำไฟฟ้าได้ดีระหว่างขา <strong>S (Source)</strong> กับ <strong>D (Drain)</strong> ทำให้มีกระแสไหลจากแหล่งจ่าย <strong>VS2</strong> ผ่านมอสเฟตเข้าไปในวงจร ไปยังตัวต้านทานและตัวเหนี่ยวนำไฟฟ้า ในขณะเดียวกันจะมีการชาร์จประจุไฟฟ้าที่ตัวเก็บประจุอย่างรวดเร็ว เมื่อเข้าสู่สภาวะคงตัว กระแสไฟฟ้าที่ไหลผ่านตัวต้านทานและตัวเหนี่ยวนำไฟฟ้า จะได้เท่ากับ <strong>5V / 20<script type="math/tex">\Omega</script> = 0.25A</strong> และแรงดันตกคร่อมที่ตัวเก็บประจุเท่ากับ <strong>5V</strong> โดยประมาณ</p>
<p>หลังจากนั้น <strong>VS1</strong> จะเปลี่ยนเป็น <strong>5V</strong> ทำให้ <script type="math/tex">V_{GS}</script> เท่ากับ <strong>0V</strong> มอสเฟตจึงมีค่าความต้านทานสูงมากและไม่นำไฟฟ้า อยู่ในสถานะ <strong>Cut-off</strong> ไม่มีกระแสไหลจาก <strong>VS2</strong> เข้าไปในวงจร หรือกล่าวได้ว่า แหล่งจ่าย <strong>VS2</strong> ถูกตัดออกจากวงจร </p>
<p>ดังนั้นหากพิจารณา ณ เวลานี้เป็นต้นไป (เมื่อแหล่งจ่าย <strong>VS2</strong> ถูกตัดออก)  วงจรนี้มีเพียงตัวต้านทาน ตัวเก็บประจุ และตัวเหนี่ยวนำไฟฟ้าต่ออนุกรมกันในวงจรเท่านั้น ไม่มีแหล่งจ่ายแรงดันไฟฟ้าในวงจร (<strong>Source-Free RLC Circuit</strong>) กระแสไฟฟ้าที่ไหลในขณะนั้นเท่ากับ <strong>-0.25A</strong> (มีค่าเป็นลบเพราะมีทิศทางสวนทางกับการกำหนดทิศทางการไหลของกระแสในวงจร)  และแรงดันตกคร่อมที่ตัวเก็บประจุจะเท่ากับ <strong>5V</strong></p>
<p>ลองมาดูผลการจำลองการทำงานของวงจรด้วย <strong>EasyEDA</strong> ในโหมด <strong>Transient</strong> สำหรับช่วงเวลา <strong>0..5ms</strong></p>
<p><img alt="" src="rlc_circuit-1_sim.png" /></p>
<p>รูป: ผลการจำลองการทำงานโดย <strong>EasyEDA</strong> แสดงรูปกราฟสำหรับ <script type="math/tex">v1</script> และ <script type="math/tex">v2</script>
</p>
<p><img alt="" src="rlc_circuit-2_sim.png" /></p>
<p>รูป: ผลการจำลองการทำงานโดย <strong>EasyEDA</strong> แสดงรูปกราฟสำหรับ <script type="math/tex">v_L(t)</script>, <script type="math/tex">v_R(t)</script> และ <script type="math/tex">v_C(t)</script>
</p>
<p>ถ้าเปรียบเทียบผลลัพธ์ที่ได้จากโค้ด <strong>MATLAB</strong> ต่อไป ก็จะได้รูปกราฟในลักษณะเดียวกัน</p>
<pre><code class="language-matlab">% clear all symbols, variables, figures and command outputs
clearvars; clc; clf;
% define symbols to be used for formulating the ODE
syms t R L C VS V0 I0 v_C(t) v_R(t) V_L(t) i(t)
eq1 = diff(v_C(t),t) == i(t)/C;
eq2 = diff(i(t),t) == (VS - i(t)*R - v_C(t))/L;
% state equations
eqn = [eq1, eq2];
% initial condition
ic = [i(0)==I0, v_C(0)==V0];
% solve the ODE system with initial conditions
sol = dsolve( eqn, ic );
i(t)   = simplify( sol.i );
v_C(t) = simplify( sol.v_C );
v_R(t) = R*i(t);
v_L(t) = L*diff(i(t),t);
% set specific values for the parameters of the circuit
params = [R, L, C, VS, V0, I0 ];
values = [20, 10*10^-3, 10*10^-6, 0, 5, -0.25 ];
v_R(t) = simplify( subs( v_R(t), params, values ) );
v_L(t) = simplify( subs( v_L(t), params, values ) );
v_C(t) = simplify( subs( v_C(t), params, values ) );
% plot v_L(t), v_R(t) and v_C(t) for t between 0 and 5 msec
fplot( [v_L(t), v_R(t), v_C(t)], [0, 5*10^-3] ), 
grid on, xlabel('t'), ylim([-6,6]), 
xticks( 0:5*10^-4:5*10^-3 ), 
legend('v_L(t)','v_R(t)','v_C(t)')
</code></pre>
<p><img alt="" src="matlab_output-4.png" /></p>
<p>รูป: แสดงรูปกราฟด้วย <strong>MATLAB</strong> สำหรับ  <script type="math/tex">v_L(t)</script>, <script type="math/tex">v_R(t)</script> และ <script type="math/tex">v_C(t)</script> ในช่วงเวลา  <strong>0..5ms</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="_6">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_6" title="Permanent link">#</a></h2>
<p>การเรียนรู้เกี่ยวกับการวิเคราะห์วงจรไฟฟ้าพื้นฐานที่ประกอบด้วย <strong>R L C</strong> เกี่ยวข้องกับความรู้ในเชิงทฤษฎี เช่น การแปลงวงจรให้เป็นสมการเชิงอนุพันธ์สามัญ และการหาผลเฉลย นอกจากวิธีการวิเคราะห์ในเชิงคณิตศาสตร์แล้ว ยังมีเครื่องมือที่เป็นซอฟต์แวร์ อย่างเช่น ซอฟต์แวร์จำลองการทำงานของวงจรอย่างเช่น <strong>EasyEDA - LTspice</strong> หรือ การเขียนโค้ดด้วย <strong>MATLAB</strong> หรือ <strong>Python</strong> เพื่อแก้ปัญหาทางคณิตศาสตร์ เป็นต้น</p>
<p>หากสนใจตัวอย่างเพิ่มเติมสำหรับการเขียนโค้ด <strong>MATLAB</strong> หรือ <strong>Python</strong> เพื่อหาผลเฉลยของสมการเชิงอนุพันธ์สามัญ
ด้วยวิธีการคำนวณเชิงสัญลักษณ์และเชิงตัวเลข สามารถอ่านเนื้อหาเพิ่มเติมได้จากบทความภาษาทไทยต่อไปนี้</p>
<ul>
<li><a href="../../python/python_ode_solving/">"<strong>ODE Solving with Python</strong>"</a>
ตัวอย่างการเขียนโค้ด <strong>Python</strong> เพื่อหาผลเฉลยของสมการเชิงอนุพันธ์</li>
<li><a href="../../matlab/matlab_ode_solving/">"<strong>ODE Solving with MATLAB</strong>"</a>
ตัวอย่างการเขียนโค้ด <strong>MATLAB</strong> เพื่อหาผลเฉลยของสมการเชิงอนุพันธ์</li>
<li><a href="../../matlab/matlab_laplace_ode_solving/">"<strong>ODE Solving with MATLAB - Laplace Transforms</strong>"</a>
ตัวอย่างการเขียนโค้ด <strong>MATLAB</strong> เพื่อหาผลเฉลยของสมการเชิงอนุพันธ์ด้วยวิธีการแปลงลาปลาซ</li>
</ul>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2022-04-03 | Last Updated: 2022-04-23</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2022 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
