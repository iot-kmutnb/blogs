<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/teaching/digital_logic_lab_2025-1/intro_ff_latch_reg/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Tutorial: VHDL Modeling of D Flip-Flops, D Latches, and Shift Registers - IoT Engineering Education</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#tutorial-vhdl-modeling-of-d-flip-flops-d-latches-and-shift-registers" class="nav-link">Tutorial: VHDL Modeling of D Flip-Flops, D Latches, and Shift Registers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#d-flip-flops" class="nav-link">D Flip-Flops</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#rs-latches" class="nav-link">RS Latches</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#d-latches" class="nav-link">D Latches</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#shift-registers" class="nav-link">Shift Registers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="tutorial-vhdl-modeling-of-d-flip-flops-d-latches-and-shift-registers"><strong>Tutorial: VHDL Modeling of D Flip-Flops, D Latches, and Shift Registers</strong><a class="headerlink" href="#tutorial-vhdl-modeling-of-d-flip-flops-d-latches-and-shift-registers" title="Permanent link">#</a></h1>
<hr />
<p>In this tutorial, we will learn how to model and simulate basic storage elements in VHDL, such as:</p>
<ul>
<li><a href="#d-flip-flops"><strong>D Flip-Flops</strong></a></li>
<li><a href="#rs-latches"><strong>RS Latches</strong></a></li>
<li><a href="#d-latches"><strong>D Latches</strong></a></li>
<li><a href="#shift-registers"><strong>Shift Registers</strong></a></li>
</ul>
<hr />
<h2 id="d-flip-flops"><strong>D Flip-Flops</strong><a class="headerlink" href="#d-flip-flops" title="Permanent link">#</a></h2>
<p>A <strong>D flip-flop (DFF)</strong> is a storage element that stores one bit.
On a specific logic transition of the clock input <code>CLK</code>),
either <strong>rising edge</strong> or <strong>falling edge</strong>, the DFF captures the value at its data input (<code>D</code>) and updates its output (<code>Q</code>) accordingly.</p>
<p>There are two types of DFFs:</p>
<ul>
<li><strong>Positive-edge triggered</strong>: updates on the rising edge of the clock.</li>
<li><strong>Negative-edge triggered</strong>: updates on the falling edge of the clock.</li>
</ul>
<p>The following is an example of a D flip-flop modeled in VHDL.</p>
<pre><code class="language-VHDL">-- File: d_ff.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY d_ff IS
    PORT (
        clk : IN STD_LOGIC; -- clock input
        d   : IN STD_LOGIC; -- data input
        q   : OUT STD_LOGIC -- data output
    );
END d_ff;

ARCHITECTURE behavioral OF d_ff IS
BEGIN
    update_proc : PROCESS (clk)
    BEGIN
        -- use either rising_edge(clk) or falling_edge(clk)
        IF rising_edge(clk) THEN
           q &lt;= d;
        END IF;
    END PROCESS;
END behavioral;
</code></pre>
<p>To simulate the VHDL model of the DFF, a VHDL testbench is provided.</p>
<pre><code class="language-VHDL">-- File: tb_d_ff.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY tb_d_ff IS
END tb_d_ff;

ARCHITECTURE sim OF tb_d_ff IS
    -- DUT port signals
    SIGNAL t_clk : STD_LOGIC := '0';
    SIGNAL t_d : STD_LOGIC := '0';
    SIGNAL t_q : STD_LOGIC;

    -- LFSR reg
    SIGNAL lfsr : STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS =&gt; '1');

    -- Clock period constant
    CONSTANT CLK_PERIOD : TIME := 20 ns;

BEGIN
    -- Instantiate the D Flip-Flop
    uut: ENTITY work.d_ff(behavioral)
        PORT MAP(
            clk =&gt; t_clk,
            d =&gt; t_d,
            q =&gt; t_q
        );

    -- LFSR process
    lfsr_proc: PROCESS
    BEGIN
       -- LFSR feedback (bit 7 XOR bit 5)
       lfsr &lt;= lfsr(6 DOWNTO 0) &amp; (lfsr(7) XOR lfsr(5));
       WAIT UNTIL rising_edge(t_clk);
    END PROCESS;

    t_d &lt;= lfsr(0);

    -- Clock generation: 20 ns period (50 MHz)
    clk_gen: PROCESS
    BEGIN
        t_clk &lt;= '0';
        WAIT FOR CLK_PERIOD/2;
        t_clk &lt;= '1';
        WAIT FOR CLK_PERIOD/2;
    END PROCESS;

END sim;
</code></pre>
<p><strong>Note</strong></p>
<ul>
<li>In this VHDL testbench, a 8-bit <strong>LFSR</strong> (<em>Linear Feedback Shift Register</em>)
is used to produce a <em>pseudo-random</em> bit sequence for the data input <code>d</code>
of the DFF for testing purposes.</li>
<li>This 8-bit LFSR is initialized with a non-zero value (e.g., all bits set to <code>'1'</code>).</li>
<li>It shifts the 8-bit register one position to the left on every rising edge of the clock. </li>
<li>The new bit entering at the LSB position (bit 0)
is computed as the XOR of bit 7 and bit 5 of the current value in the LFSR register.</li>
<li>LFSRs are commonly used in testbenches to simulate randomized input patterns without needing manually specified input vectors.</li>
<li>The 8-bit LFSR can generate a maximum-length sequence of <script type="math/tex">2^8 -1</script> bits.</li>
<li>The feedback taps of the LFSR (in this case: bit 7 and bit 5) 
form a so-called <strong>primitive polynomial</strong>.</li>
</ul>
<p>If <strong>GHDL</strong> is used as the VHDL simulator, 
the following commands can be used to compile the code and run the simulation:</p>
<pre><code class="language-text"># Analyze (compile) the VHDL design and its testbench
ghdl -a d_ff.vhd tb_d_ff.vhd

# Elaborate the VHDL testbench (build the simulation model)
ghdl -e tb_d_ff

# Run the simulation, generate VCD waveform, stop at 1 μs
ghdl -r tb_d_ff --vcd=./wave.vcd --stop-time=1us
</code></pre>
<p>For <code>.vcd</code> waveform visualization, the <strong>GTKWave</strong> program can be used:</p>
<pre><code class="language-text"># Open the waveform file using GTKWave (in the background)
gtkwave wave.vcd &amp;
</code></pre>
<p>The simulation result is shown as a waveform below.</p>
<ul>
<li>It shows that the input stimulus signal <code>d</code> changes synchronously, 
immediately after the rising edges of the clock.</li>
<li>Initially, the output <code>q</code> of the D flip-flop is in an unknown state (<code>'U'</code>).</li>
<li>After the first rising clock edge, the output changes to <code>'0'</code>, 
matching the value of the input <code>d</code> at that clock transition.</li>
<li>In this example, the output <code>q</code> of the DFF is allowed to change
at the rising edges of <code>clk.</code></li>
</ul>
<p><img alt="" src="wave_dff-1.jpg" /></p>
<p><strong>Figure:</strong> Simulation waveform of the DFF.</p>
<p>The following VHDL code shows how the model of a <strong>DFF</strong> can be modified
to include <strong>multiple control signals</strong>, including:</p>
<ul>
<li>Asynchronous clear</li>
<li>Asynchronous preset</li>
<li>Asynchronous load</li>
<li>Synchronous clear</li>
<li>Synchronous load</li>
<li>Data enable and load</li>
</ul>
<p>This model <em>prioritizes</em> asynchronous controls over synchronous ones
and only loads data on the rising edge of the clock when enabled.</p>
<pre><code class="language-VHDL">-- File: d_ff_ctrl.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY d_ff_ctrl IS
    PORT (
        clk          : IN STD_LOGIC;
        d            : IN STD_LOGIC;
        en           : IN STD_LOGIC;
        async_clr    : IN STD_LOGIC;
        async_preset : IN STD_LOGIC;
        async_load   : IN STD_LOGIC;
        async_data   : IN STD_LOGIC;
        sync_clr     : IN STD_LOGIC;
        sync_load    : IN STD_LOGIC;
        sync_data    : IN STD_LOGIC;
        q            : OUT STD_LOGIC
    );
END d_ff_ctrl;

ARCHITECTURE rtl OF d_ff_ctrl IS
    SIGNAL q_reg : STD_LOGIC := '0';
BEGIN

    PROCESS (clk, async_clr, async_preset, async_load)
    BEGIN
        -- Highest priority: Asynchronous clear
        IF async_clr = '1' THEN
            q_reg &lt;= '0';

        -- Asynchronous preset
        ELSIF async_preset = '1' THEN
            q_reg &lt;= '1';

        -- Asynchronous load
        ELSIF async_load = '1' THEN
            q_reg &lt;= async_data;

        -- Synchronous logic
        ELSIF rising_edge(clk) THEN
            IF en = '1' THEN
                IF sync_clr = '1' THEN
                    q_reg &lt;= '0';
                ELSIF sync_load = '1' THEN
                    q_reg &lt;= sync_data;
                ELSE
                    q_reg &lt;= d;
                END IF;
            END IF;
        END IF;
    END PROCESS;

    q &lt;= q_reg;

END ARCHITECTURE;
</code></pre>
<p>This model prioritizes asynchronous controls over synchronous ones and
only loads data on the rising edge of the clock when enabled. 
The synthesis result provided by <strong>Intel Quartus Prime Lite software</strong> is given below.</p>
<p><img alt="" src="dff_synth_result.jpg" /></p>
<p><strong>Figure:</strong> RTL-level synthesis result targeting the MAX-10 FPGA</p>
<p>&nbsp;</p>
<hr />
<h2 id="rs-latches"><strong>RS Latches</strong><a class="headerlink" href="#rs-latches" title="Permanent link">#</a></h2>
<p>An <strong>RS latch</strong> is a basic type of latches which can stores one bit of data.
It has two active-low inputs, reset (<code>/R</code> or <code>R_N</code>) and set (<code>/S</code> or <code>S_N</code>)
and two complementary output, <code>Q</code> and <code>QB</code>, respectively.</p>
<p>An RS latch can be constructed using two cross-coupled two-input NAND gates.
The following VHDL code shows how to model an RS latch, with two implementation styles.</p>
<pre><code class="language-VHDL">-- File: rs_latch.vhd
-- RS Latch with Active-Low Inputs
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY rs_latch IS
    PORT (
        R_N : IN  STD_LOGIC; -- Active-low Reset input
        S_N : IN  STD_LOGIC; -- Active-low Set input
          Q : OUT STD_LOGIC; -- Output Q
         QB : OUT STD_LOGIC  -- Inverted output (Q - bar)
    );
END rs_latch;

-- dataflow implementation
ARCHITECTURE impl_1 OF rs_latch IS
    SIGNAL q_int, qb_int : STD_LOGIC;
BEGIN
    -- Cross-coupled NAND gates
    q_int  &lt;= NOT(S_N AND qb_int);
    qb_int &lt;= NOT(R_N AND q_int);
    Q  &lt;= q_int;
    QB &lt;= qb_int;
END impl_1;

-- Behavioral implementation
ARCHITECTURE impl_2 OF rs_latch IS
    SIGNAL q_int   : STD_LOGIC := '0'; -- Internal Q signal
    SIGNAL invalid : STD_LOGIC := '0';
BEGIN
    PROCESS (R_N, S_N, q_int)
    BEGIN
        invalid &lt;= '0';
        IF R_N = '0' AND S_N = '1' THEN
            q_int &lt;= '0'; -- Reset: Q=0, QB=1
        ELSIF R_N = '1' AND S_N = '0' THEN
            q_int &lt;= '1'; -- Set: Q=1, QB=0
        ELSIF R_N = '1' AND S_N = '1' THEN
            -- no change (hold previous state)
        ELSE
            invalid &lt;= '1';
            q_int &lt;= '1'; -- Invalid state: both active
        END IF;
    END PROCESS;

    -- Output assignments
    Q &lt;= q_int;
    QB &lt;= NOT q_int WHEN invalid = '0' ELSE q_int;
END impl_2;
</code></pre>
<p><strong>VHDL testbench for simulation purposes</strong>:</p>
<pre><code class="language-VHDL">-- File tb_rs_latch.vhd
-- Test bench for RS latch
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY tb_rs_latch IS
END tb_rs_latch;

ARCHITECTURE sim OF tb_rs_latch IS
    COMPONENT rs_latch
        PORT (
            S_N : IN  STD_LOGIC;
            R_N : IN  STD_LOGIC;
            Q  : OUT STD_LOGIC;
            QB : OUT STD_LOGIC
        );
    END COMPONENT;

    SIGNAL t_S_N, t_R_N, t_Q, t_QB : STD_LOGIC;

    -- LFSR reg
    SIGNAL lfsr : STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS =&gt; '1');

BEGIN
    -- Instantiate RS latch (UUT = Unit Under Test)
    uut: ENTITY work.rs_latch(impl_1)
    PORT MAP(
        S_N  =&gt; t_S_N,
        R_N  =&gt; t_R_N,
        Q  =&gt; t_Q,
        QB =&gt; t_QB
    );

    -- 8-bit LFSR
    lfsr_proc: PROCESS
    BEGIN
        lfsr &lt;= lfsr(6 DOWNTO 0) &amp; (lfsr(7) XOR lfsr(5));
         WAIT FOR 10 ns;
    END PROCESS;

    t_S_N &lt;= lfsr(0);
    t_R_N &lt;= lfsr(1);

END sim;
</code></pre>
<p>Commands for simulation:</p>
<pre><code class="language-text"># Analyze (compile) the RS latch design and its testbench
ghdl -a rs_latch.vhd tb_rs_latch.vhd

# Elaborate the testbench (build the simulation model)
ghdl -e tb_rs_latch

# Run the simulation, generate VCD waveform, stop at 1 μs
ghdl -r tb_rs_latch --vcd=./wave.vcd --stop-time=1us

# Open the waveform file using GTKWave (in the background)
gtkwave wave.vcd &amp;
</code></pre>
<p><img alt="" src="wave_rs_latch.jpg" /></p>
<p><strong>Figure:</strong> Simulation result</p>
<p>&nbsp;</p>
<hr />
<h2 id="d-latches"><strong>D Latches</strong><a class="headerlink" href="#d-latches" title="Permanent link">#</a></h2>
<p>A <strong>D latch</strong> is a 1-bit storage element that allows its output to change 
when the enable input is high. 
When the enable input is low, the output remains unchanged.  </p>
<p>Because <strong>D latches</strong> are <strong>level-sensitive</strong>, their output (<code>Q</code>) follows 
the data input (<code>D</code>) as long as the enable signal (<code>EN</code>) is active. 
If a clock signal is used directly as an enable for a latch, 
the output may change multiple times during a single clock cycle if the input toggles.</p>
<p>A <strong>D latch</strong> can be constructed based on an <strong>RS latch</strong> or <strong>NAND2</strong> gates as shown below.</p>
<p><img alt="" src="d_latch.jpg" /></p>
<p><strong>Figure:</strong> Gated D latch</p>
<p>&nbsp;</p>
<p>The following is a VHDL code example of a RS latch,
implemented using <strong>three different styles</strong>.</p>
<pre><code class="language-VHDL">-- File: d_latch.vhd
-- D Latch Entity
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY d_latch IS
    PORT (
        D  : IN STD_LOGIC;  -- Data input
        EN : IN STD_LOGIC;  -- Enable input
        Q  : OUT STD_LOGIC; -- Output Q
        QB : OUT STD_LOGIC  -- Inverted output (Q-bar)
    );
END d_latch;

-- Structural implementation using RS latch
ARCHITECTURE impl_1 OF d_latch IS
    COMPONENT rs_latch
        PORT (
            R_N : IN STD_LOGIC;
            S_N : IN STD_LOGIC;
            Q   : OUT STD_LOGIC;
            QB  : OUT STD_LOGIC
        );
    END COMPONENT;

    SIGNAL s_n, r_n : STD_LOGIC;
BEGIN

    s_n &lt;= NOT (D AND EN);
    r_n &lt;= NOT (NOT(D) AND EN);

    -- Instantiate RS latch
    rs_inst : ENTITY work.rs_latch(impl_1)
    PORT MAP(
        R_N =&gt; r_n,
        S_N =&gt; s_n,
        Q   =&gt; Q,
        QB  =&gt; QB
    );
END impl_1;

-- Behavioral implementation 
ARCHITECTURE impl_2 OF d_latch IS
   SIGNAL q_int : STD_LOGIC := '0';
BEGIN
    PROCESS (D, EN)
    BEGIN
        IF EN = '1' THEN
            q_int &lt;= D;
        -- else: latch holds previous state
        END IF;
    END PROCESS;
    Q  &lt;= q_int; 
    QB &lt;= NOT q_int;
END impl_2;

ARCHITECTURE impl_3 OF d_latch IS
    SIGNAL q_int : STD_LOGIC := '0';
BEGIN
    -- dataflow using MUX2_1 logic
    q_int &lt;= D WHEN EN = '1' ELSE q_int;
    Q  &lt;= q_int;
    QB &lt;= NOT q_int;
END impl_3;
</code></pre>
<p>&nbsp;</p>
<p><strong>VHDL Testbench:</strong></p>
<pre><code class="language-VHDL">-- File tb_d_latch.vhd
-- Test bench for D latch
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY tb_d_latch IS
END tb_d_latch;

ARCHITECTURE sim OF tb_d_latch IS
    COMPONENT d_latch
        PORT (
            D  : IN  STD_LOGIC;
            EN : IN  STD_LOGIC;
            Q  : OUT STD_LOGIC;
            QB : OUT STD_LOGIC
        );
    END COMPONENT;

    SIGNAL t_D, t_EN, t_Q, t_QB : STD_LOGIC;

    -- LFSR reg
    SIGNAL lfsr : STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS =&gt; '1');

BEGIN
    -- Instantiate D latch
    uut : ENTITY work.d_latch(impl_2)
    PORT MAP(
        D  =&gt; t_D,
        EN =&gt; t_EN,
        Q  =&gt; t_Q,
        QB =&gt; t_QB
    );

    -- 8-bit LFSR
    lfsr_proc : PROCESS
    BEGIN
        lfsr &lt;= lfsr(6 DOWNTO 0) &amp; (lfsr(7) XOR lfsr(5));
        WAIT FOR 10 ns;
    END PROCESS;

    t_d &lt;= lfsr(0);

    t_en &lt;= '0',
        '1' AFTER 100 ns,
        '0' AFTER 200 ns,
        '1' AFTER 300 ns,
        '0' AFTER 1000 ns;

END sim;
</code></pre>
<p><strong>GHDL commands for simulation:</strong></p>
<pre><code class="language-text">ghdl -a rs_latch.vhd d_latch.vhd tb_d_latch.vhd
ghdl -e tb_d_latch
ghdl -r tb_d_latch --vcd=./wave.vcd --stop-time=1us
</code></pre>
<p><strong>Simulation Results:</strong></p>
<p><img alt="" src="wave_d_latch-1.jpg" /></p>
<p><strong>Figure:</strong> VHDL simulation (for the implementation <code>impl_1</code>)</p>
<p><img alt="" src="wave_d_latch-2.jpg" /></p>
<p><strong>Figure:</strong> VHDL simulation (for the implementation <code>impl_2</code>)</p>
<p>As seen in the simulation waveform, when the enable signal (<code>EN</code>)
is asserted (high), the D latch updates its output (<code>Q</code>) in response to 
changes on the input (<code>D</code>). When the enable signal is deasserted (low), 
the output remains unchanged.</p>
<p>&nbsp;</p>
<p>Alternatively, a <strong>D latch</strong> can be implemented using a <strong>2-to-1 multiplexer</strong>
with two data inputs (<code>D0</code> and <code>D1</code>) and a select signal (<code>SEL</code>).</p>
<ul>
<li>The enable input (<code>EN</code>) of the D latch is connected to the multiplexer's <code>SEL</code> input.</li>
<li>The first data input (<code>D0</code>) of the multiplexer is connected to 
  the latch's output (<code>Q</code>), creating a feedback path.</li>
<li>The second data input (<code>D1</code>) is connected to the data input (<code>D</code>) of the D latch.</li>
</ul>
<p>This design ensures that:
- When <code>EN</code> = 0, the latch holds its current value (feedback).
- When <code>EN</code> = 1, the latch updates its output based on the data input.</p>
<p><strong>VHDL Code for MUX-based D-Latch Implementation</strong></p>
<pre><code class="language-VHDL">-- File: d_latch_mux.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY d_latch_mux IS
    PORT (
        D  : IN STD_LOGIC; -- Data input
        EN : IN STD_LOGIC; -- Enable (acts as SEL for MUX)
        Q  : OUT STD_LOGIC -- Latch output
    );
END ENTITY;

ARCHITECTURE Behavioral OF d_latch_mux IS
    -- Internal signals for MUX2_1
    SIGNAL mux_d0, mux_d1, mux_sel : STD_LOGIC;
    SIGNAL mux_o : STD_LOGIC := '0';
BEGIN

    mux_d0  &lt;= mux_o;
    mux_d1  &lt;= D;
    mux_sel &lt;= EN;

    mux2_1_proc: PROCESS (mux_d0, mux_d1, mux_sel, mux_o)
    BEGIN
        -- 2-to-1 MUX logic:
        IF mux_sel = '1' THEN
            mux_o &lt;= mux_d1;
        ELSE
            mux_o &lt;= mux_d0; -- Hold value (feedback path)
        END IF;
    END PROCESS;

    Q &lt;= mux_o;

END ARCHITECTURE;
</code></pre>
<p>&nbsp;</p>
<p><strong>Notes:</strong></p>
<ul>
<li>In <strong>FPGA-based synchronous designs</strong>, edge-triggered D flip-flops*
are preferred over D latches due to their predictable timing behavior and better tool support.</li>
<li>D flip-flops and D latches, when implemented using FPGA resources, 
may have initial values automatically loaded during FPGA configuration.</li>
<li>However, as a good coding practice, every synchronous design should include 
a <strong>global reset input</strong> to explicitly initialize all internal storage elements to a known state.</li>
<li>In functional simulation, all flip-flops update their outputs 
immediately after the active clock edge (either rising or falling)
depending on their trigger type.</li>
<li>In contrast, timing simulation takes signal delays into account,
including clock-to-Q delay, setup and hold times of flip-flops,
gate delays, and other propagation delays in the circuit.</li>
</ul>
<hr />
<h2 id="shift-registers"><strong>Shift Registers</strong><a class="headerlink" href="#shift-registers" title="Permanent link">#</a></h2>
<p>An <script type="math/tex">n</script>-bit register is a sequential digital circuit composed of an array
of <script type="math/tex">n</script> D flip-flops connected in parallel and typically driven 
by a common clock signal. Each flip-flop stores one bit,
forming an <script type="math/tex">n</script>-bit wide storage unit.</p>
<p>In addition to clock and data inputs, registers may include control signals
such as a load or clock enable input. When this signal is deasserted, 
the contents of the register remain unchanged and are not updated on the clock edge.</p>
<p>An <script type="math/tex">n</script>-bit shift register is a special type of register
in which data is shifted one bit position
per clock cycle. The direction of shifting can be:</p>
<ul>
<li><strong>Left-shift register</strong>: shifts bits toward the MSB; new data enters at the LSB
(least significant bit).</li>
<li><strong>Right-shift register</strong>: shifts bits toward the LSB; new data enters at the MSB
(most significant bit).</li>
</ul>
<p>The following is a VHDL code example that shows how to construct
a parameterized left-shifting register using two different implementation styles:</p>
<ol>
<li>Structural style using DFF instantiations</li>
<li>Behavioral style using a <code>PROCESS</code> block</li>
</ol>
<p>When the asynchronous reset (<code>RST_N</code>) is asserted, 
the register is initialized to <code>INIT_VALUE</code>.
On each rising clock edge, the new bit (<code>SDI</code>) is shifted into the 
LSB of the register and the output bit is available at <code>SDO</code>.</p>
<pre><code class="language-VHDL">-- File: d_ff.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

-- A VHDL model of a positive-edge triggered D-type flip-flop 
-- with asynchronous active-low reset (or clear)
ENTITY d_ff IS
    GENERIC (
        INIT_LOGIC : STD_LOGIC := '0'
    );
    PORT (
        CLK   : IN STD_LOGIC; -- clock input
        RST_N : IN STD_LOGIC; -- asynchronous active-low reset (or clear) input
        D     : IN STD_LOGIC; -- data input
        Q     : OUT STD_LOGIC -- data output
    );
END d_ff;

ARCHITECTURE behavioral OF d_ff IS
    SIGNAL reg : STD_LOGIC := INIT_LOGIC;
BEGIN
    update_proc : PROCESS (RST_N, CLK)
    BEGIN
        IF RST_N = '0' THEN
            reg &lt;= INIT_LOGIC;
        ELSIF rising_edge(CLK) THEN
            reg &lt;= D;
        END IF;
    END PROCESS;
    -- concurrent output signal assignment
    Q &lt;= reg;
END behavioral;
</code></pre>
<pre><code class="language-VHDL">-- File: shift_reg.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY shift_reg IS
    GENERIC (
        BW : POSITIVE := 4; -- Bitwidth of the register
        INIT_VALUE : INTEGER := 0
    );
    PORT (
        CLK   : IN STD_LOGIC; -- clock input
        RST_N : IN STD_LOGIC; -- async. reset
        SDI   : IN STD_LOGIC; -- shift data input
        SDO   : OUT STD_LOGIC; -- shift data output
        Q     : OUT STD_LOGIC_VECTOR(BW - 1 DOWNTO 0) -- register output
    );
END shift_reg;

ARCHITECTURE impl_1 OF shift_reg IS
    COMPONENT d_ff
        GENERIC (
            INIT_LOGIC : STD_LOGIC := '0'
        );
        PORT (
            CLK   : IN STD_LOGIC; 
            RST_N : IN STD_LOGIC; 
            D     : IN STD_LOGIC; 
            Q     : OUT STD_LOGIC
        );
    END COMPONENT;

    CONSTANT INIT_BITS : unsigned(BW - 1 DOWNTO 0) := to_unsigned(INIT_VALUE, BW);
    SIGNAL reg   : unsigned(BW - 1 DOWNTO 0);
    SIGNAL chain : unsigned(BW DOWNTO 0);

BEGIN
    -- internal chain signals
    chain &lt;= reg &amp; SDI;

    -- Generate D flip-flops
    for_gen : FOR i IN 0 TO BW - 1 GENERATE
        dff_inst : d_ff
        GENERIC MAP(
            INIT_LOGIC =&gt; INIT_BITS(i)
        )
        PORT MAP(
            CLK   =&gt; CLK,
            rst_n =&gt; RST_N,
            D     =&gt; chain(i),
            Q     =&gt; reg(i)
        );
    END GENERATE for_gen;

    -- Output assignments
    SDO &lt;= reg(BW - 1);
    Q &lt;= STD_LOGIC_VECTOR(reg);
END impl_1;

ARCHITECTURE impl_2 OF shift_reg IS
    SIGNAL reg : unsigned(BW - 1 DOWNTO 0) := to_unsigned(INIT_VALUE, BW);
BEGIN
    -- The chain signal acts as a shift input path: SDI enters at LSB.
    PROCESS (RST_N, CLK)
    BEGIN
        IF RST_N = '0' THEN
            reg &lt;= to_unsigned(INIT_VALUE, BW);
        ELSIF rising_edge(CLK) THEN
            reg &lt;= reg(BW - 2 DOWNTO 0) &amp; SDI; -- shift left
        END IF;
    END PROCESS;

    SDO &lt;= reg(BW - 1);
    Q &lt;= STD_LOGIC_VECTOR(reg);
END impl_2;
</code></pre>
<p>&nbsp;</p>
<p><strong>VHDL Testbench:</strong></p>
<pre><code class="language-VHDL">-- File: tb_shift_reg.vhd
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY tb_shift_reg IS
END tb_shift_reg;

ARCHITECTURE sim OF tb_shift_reg IS

    -- Bitwidth of the shift register
    CONSTANT BW : POSITIVE := 8;

    -- Signals to connect to UUT
    SIGNAL t_clk   : STD_LOGIC := '0';
    SIGNAL t_rst_n : STD_LOGIC := '0';
    SIGNAL t_sdi   : STD_LOGIC := '0';
    SIGNAL t_sdo   : STD_LOGIC := '0';
    SIGNAL t_q     : STD_LOGIC_VECTOR(BW - 1 DOWNTO 0);

    -- Clock period constant
    CONSTANT CLK_PERIOD : TIME := 20 ns;

BEGIN

    -- Circular shift left: MSB fed back into LSB
    t_sdi &lt;= t_sdo;

    -- Instantiate the Unit Under Test (UUT) using direct entity instantiation
    uut : ENTITY work.shift_reg(impl_1)
        GENERIC MAP (
            BW =&gt; BW,
            INIT_VALUE =&gt; 1
        )
        PORT MAP (
            clk   =&gt; t_clk,
            rst_n =&gt; t_rst_n,
            sdi   =&gt; t_sdi,
            sdo   =&gt; t_sdo,
            q     =&gt; t_q
        );

    -- Clock process
    clk_process : PROCESS
    BEGIN
        t_clk &lt;= '0';
        WAIT FOR CLK_PERIOD / 2;
        t_clk &lt;= '1';
        WAIT FOR CLK_PERIOD / 2;
    END PROCESS;

    -- Stimulus process
    stim_proc : PROCESS
    BEGIN
        -- Apply reset
        t_rst_n &lt;= '0';
        WAIT FOR 100 ns;
        t_rst_n &lt;= '1';

        -- Let the register shift for some clock cycles
        FOR i IN 0 TO 2 * BW LOOP
            WAIT UNTIL rising_edge(t_clk);
        END LOOP;

        WAIT FOR 100 ns;

        -- End simulation
        ASSERT false REPORT &quot;End of simulation.&quot; SEVERITY note;
        WAIT;
    END PROCESS;

END sim;
</code></pre>
<p><strong>GHDL Commands for Simulation:</strong></p>
<pre><code class="language-text">ghdl -a d_ff.vhd shift_reg.vhd tb_shift_reg.vhd
ghdl -e tb_shift_reg
ghdl -r tb_shift_reg --fst=wave.fst --stop-time=10us
</code></pre>
<p><strong>GHDL Simulation Result:</strong></p>
<p><img alt="" src="wave_shift_reg.jpg" /></p>
<p><strong>Figure:</strong> VHDL simulation</p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2025-06-07 | Last Updated: 2025-06-07</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
