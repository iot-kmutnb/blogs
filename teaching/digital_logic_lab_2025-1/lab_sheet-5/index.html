<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/teaching/digital_logic_lab_2025-1/lab_sheet-5/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Lab Sheet 5 - IoT Engineering Education</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#lab-sheet-5" class="nav-link">Lab Sheet 5</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#hardware-software-required" class="nav-link">Hardware / Software Required</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-1-ripple-carry-adder-vs-carry-select-adder" class="nav-link">Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-2-accumulator" class="nav-link">Lab 2: Accumulator</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_1" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_1" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-3-linear-feedback-shift-register-lfsr" class="nav-link">Lab 3: Linear Feedback Shift Register (LFSR)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_2" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-4-on-chip-ram-testing" class="nav-link">Lab 4: On-chip RAM Testing</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_3" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_2" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-5-ram-based-fifo-testing" class="nav-link">Lab 5: RAM-based FIFO Testing</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_4" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_3" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-6-altera-fifo-ip-core-testing" class="nav-link">Lab 6: Altera FIFO IP Core Testing</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_5" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_4" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-7-signed-multiplier" class="nav-link">Lab 7: Signed Multiplier</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_6" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_5" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="lab-sheet-5"><strong>Lab Sheet 5</strong><a class="headerlink" href="#lab-sheet-5" title="Permanent link">#</a></h1>
<p>This lab sheet contains the following lab activities:</p>
<ul>
<li><a href="#lab-1-ripple-carry-adder-vs-carry-select-adder"><strong>Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</strong></a></li>
<li><a href="#lab-2-accumulator"><strong>Lab 2: Accumulator</strong></a></li>
<li><a href="#lab-3-linear-feedback-shift-register-lfsr"><strong>Lab 3: Linear Feedback Shift Register (LFSR)</strong></a></li>
<li><a href="#lab-4-on-chip-ram-testing"><strong>Lab 4: On-chip RAM Testing</strong></a></li>
<li><a href="#lab-5-ram-based-fifo-testing"><strong>Lab 5: RAM-based FIFO Testing</strong></a></li>
<li><a href="#lab-6-altera-fifo-ip-core-testing"><strong>Lab 6: Altera FIFO IP Core Testing</strong></a></li>
<li><a href="#lab-7-signed-multiplier"><strong>Lab 7: Signed Multiplier</strong></a></li>
</ul>
<h3 id="hardware-software-required"><strong>Hardware / Software Required</strong><a class="headerlink" href="#hardware-software-required" title="Permanent link">#</a></h3>
<ul>
<li>Intel DE10-Lite FPGA board (with a USB cable)</li>
<li>Computer with USB ports + Intel Quartus Prime Lite + VHDL Simulator</li>
<li>Digital Oscilloscope or Logic Analyzer</li>
<li>Jumper Wires / Dupont Wires</li>
</ul>
<hr />
<h2 id="lab-1-ripple-carry-adder-vs-carry-select-adder"><strong>Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</strong><a class="headerlink" href="#lab-1-ripple-carry-adder-vs-carry-select-adder" title="Permanent link">#</a></h2>
<h3 id="objective"><strong>Objective</strong><a class="headerlink" href="#objective" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement different types of binary adders using FPGA logic.</li>
</ul>
<p>In digital logic design, there are different ways to implement
N-bit binary adders. In this lab, we will explore 
how to implement two types of <script type="math/tex">N</script>-bit binary adders, namely the 
<strong>Ripple-Carry Adder (RCA)</strong> and the <strong>Carry-Select Adder (CSA)</strong>,
and compare the synthesis results when mapped to FPGA logic resources.
Their pseudo-code is given below.</p>
<p><strong>Pseudo-code for Ripple-Carry Adder:</strong></p>
<pre><code class="language-text">C[0] = CIN
for i=0 to N-1:
  SUM[i] = A[i] xor B[i] xor C[i]
  C[i+1] = (A[i] AND B[i]) OR (C[i] AND (A[i] XOR B[i]))
COUT = C[N]
</code></pre>
<p><strong>Note</strong> </p>
<ul>
<li>Each <script type="math/tex">i</script>-th stage of the ripple-carry adder is a full adder (FA).</li>
<li><code>CIN</code> and <code>COUT</code> are the carry-in and carry-out of the <script type="math/tex">N</script>-bit adder, respectively.</li>
</ul>
<p><strong>Pseudo-code for Carry-Select Adder (1 bit per step):</strong></p>
<pre><code class="language-text">C[0] = CIN
for i=0 to N-1:
     // if C[i] = 0
     sum0   = (A[i] XOR B[i])
     c_out0 = (A[i] AND B[i])

     // if C[i] = 1
     sum1   = NOT(A[i] XOR B[i])
     c_out1 = (A[i] AND B[i]) OR (A[i] XOR B[i])

     // carry select
     if C[i] == 0:
         SUM[i] = sum0
         C[i+1] = c_out0
     else:
         SUM[i] = sum1
         C[i+1] = c_out1
COUT = C[N]
</code></pre>
<h3 id="lab-procedure"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code to implement an <strong>N-bit adder</strong>, where <code>N</code> is defined as 
a generic (positive integer). Use the provided VHDL entity.</li>
<li>Write VHDL for two different architectural implementations:<ul>
<li>Option 1: <strong>Ripple-Carry Adder</strong></li>
<li>Option 2: <strong>Carry-Select Adder</strong></li>
</ul>
</li>
<li>Write your own VHDL testbench (or use the provided code) to simulate
and verify your design. Capture the simulation waveforms for your lab report.</li>
<li>Use the Quartus Prime Lite software to synthesize both versions of the adder
and compare the synthesis results.</li>
</ol>
<p><strong>VHDL entity for the adder</strong></p>
<pre><code class="language-VHDL">ENTITY adder IS
    GENERIC (
        N : INTEGER := 8
    );
    PORT (
        CIN  : IN  STD_LOGIC; -- carry-in
        A, B : IN  STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- operands
        SUM  : OUT STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- result
        COUT : OUT STD_LOGIC -- carry-out
    );
END ENTITY adder;
</code></pre>
<p><strong>VHDL testbench for the adder</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY tb_adder IS
END ENTITY tb_adder;

ARCHITECTURE sim OF tb_adder IS
    CONSTANT N  : INTEGER := 4;

    SIGNAL CIN  : STD_LOGIC := '0';
    SIGNAL A, B : STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
    SIGNAL SUM  : STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
    SIGNAL COUT : STD_LOGIC;

    -- DUT: Try RCA or CSA here
    COMPONENT ADDER IS
        GENERIC (N : INTEGER := 8);
        PORT (
            CIN  : IN  STD_LOGIC;
            A, B : IN  STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
            SUM  : OUT STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
            COUT : OUT STD_LOGIC
        );
    END COMPONENT;

BEGIN
    -- Instantiate an adder
    uut : ENTITY work.adder(RCA) -- use RCA or CSA
        GENERIC MAP(N =&gt; N)
        PORT MAP(
            CIN =&gt; CIN, A =&gt; A, B =&gt; B,
            SUM =&gt; SUM, COUT =&gt; COUT
        );

    -- Test process
    stim_proc : PROCESS
        VARIABLE expected : UNSIGNED(N DOWNTO 0); -- N bits + carry
    BEGIN
        FOR intA IN 0 TO 2**N - 1 LOOP
            FOR intB IN 0 TO 2**N - 1 LOOP
                -- apply inputs
                A &lt;= STD_LOGIC_VECTOR(to_unsigned(intA, N));
                B &lt;= STD_LOGIC_VECTOR(to_unsigned(intB, N));

                CIN &lt;= '0';
                WAIT FOR 10 ns;

                expected := to_unsigned(intA + intB, N + 1);
                ASSERT (unsigned(SUM) = expected(N - 1 DOWNTO 0) AND
                COUT = STD_LOGIC(expected(N)))
                REPORT &quot;Mismatch CIN=0: A=&quot; &amp; INTEGER'IMAGE(intA) &amp;
                    &quot; B=&quot; &amp; INTEGER'IMAGE(intB) &amp;
                    &quot; SUM=&quot; &amp; INTEGER'IMAGE(to_integer(unsigned(SUM))) &amp;
                    &quot; COUT=&quot; &amp; STD_LOGIC'IMAGE(COUT)
                    SEVERITY ERROR;

                CIN &lt;= '1';
                WAIT FOR 10 ns;

                expected := to_unsigned(intA + intB + 1, N + 1);
                ASSERT (unsigned(SUM) = expected(N - 1 DOWNTO 0) AND
                COUT = STD_LOGIC(expected(N)))
                REPORT &quot;Mismatch CIN=0: A=&quot; &amp; INTEGER'IMAGE(intA) &amp;
                    &quot; B=&quot; &amp; INTEGER'IMAGE(intB) &amp;
                    &quot; SUM=&quot; &amp; INTEGER'IMAGE(to_integer(unsigned(SUM))) &amp;
                    &quot; COUT=&quot; &amp; STD_LOGIC'IMAGE(COUT)
                    SEVERITY ERROR;

            END LOOP;
        END LOOP;
        WAIT; -- stop simulation
    END PROCESS;

END ARCHITECTURE sim;
</code></pre>
<p><strong>Questions</strong></p>
<ul>
<li>How do the two adder implementations differ in terms of logic resource usage?</li>
<li>Compare the critical paths of both designs (for example, the signal path 
from <code>CIN</code> to <code>COUT</code> in the circuit). Use Quartus Prime's synthesis &amp; 
static timing analysis (STA) report to identify the critical paths.</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-2-accumulator"><strong>Lab 2: Accumulator</strong><a class="headerlink" href="#lab-2-accumulator" title="Permanent link">#</a></h2>
<h3 id="objective_1"><strong>Objective</strong><a class="headerlink" href="#objective_1" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement an accumulator in VHDL and test its function using an FPGA board.</li>
</ul>
<p>An <strong>accumulator</strong> is a basic sequential circuit widely used in digital systems. 
Its main function is to add input data to its current stored value.</p>
<p>Two main components of the accumulator are:</p>
<ul>
<li>Adder: this adds the input value to the current contents of the register.</li>
<li>Register: this stores the accumulated sum and feeds it back into the adder
on the next clock cycle.</li>
</ul>
<h3 id="lab-procedure_1"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_1" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code to implement an accumulator.
Use an <code>N</code>-bit adder and an <code>M</code>-bit register 
(where <code>M &gt; N</code>, e.g., <code>N=8</code>, <code>M=12</code>) to implement the accumulator.
Make the design modular by creating separate components 
and then instantiating them in the top-level design (<code>acc_demo</code>).</li>
<li>Connect the I/O of the accumulator as follows:<ul>
<li>The integer (unsigned) value from the external <code>N</code>-bit slide switches 
  is internally zero-extended to <code>M</code> bits and applied as one input of the adder.</li>
<li>The output of the accumulator register is fed back into 
  the other <code>M</code>-bit input of the adder.</li>
<li>The <code>M</code>-bit result is stored in the accumulator register,
  decoded into BCD, and displayed on the external 4-digit seven-segment display.</li>
<li>The accumulator register is updated on the rising edge of 
  the push-button signal (after debouncing and edge detection).</li>
</ul>
</li>
<li>Write a VHDL testbench to simulate and test your design
to verify its correctness.</li>
<li>Complete the FPGA design process and test your design using the FPGA board (Terasic DE10-Lite) provided in the lab.<ul>
<li>Change the positions of the slide switches before pressing the button,
and observe the resulting change in the accumulator value.</li>
</ul>
</li>
<li>Demonstrate your FPGA design to the lab instructor.</li>
</ol>
<p><strong>VHDL entity for the accumulator demo</strong></p>
<pre><code class="language-VHDL">
ENTITY acc_demo IS
    GENERIC (
        N : INTEGER := 8;
        M : INTEGER := 12
    );
    PORT (
        RST_N : IN STD_LOGIC; -- global async. active-low reset
        CLK   : IN STD_LOGIC; -- clock
        BTN   : IN STD_LOGIC; -- push button
        SW    : IN STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- N-bit input
        -- 7seg digits 3~0 (output)
        HEX0  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX1  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);  
        HEX2  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX3  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)   
    );
END ENTITY acc_demo;
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="lab-3-linear-feedback-shift-register-lfsr"><strong>Lab 3: Linear Feedback Shift Register (LFSR)</strong><a class="headerlink" href="#lab-3-linear-feedback-shift-register-lfsr" title="Permanent link">#</a></h2>
<h3 id="objective_2"><strong>Objective</strong><a class="headerlink" href="#objective_2" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement an LFSR in VHDL.</li>
<li>Learn how to LFSRs to produce pseudo-random numbers for testing purposes.</li>
</ul>
<p>In this task, we will learn about the <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register"><strong>LFSR</strong></a>, which is a special type of shift register 
that can be used to implement a <strong>pseudo-random</strong> number generator 
(not a true-random number generator) for FPGA designs.</p>
<p>An LFSR consists of a register (flip-flops) and a feedback function.
The feedback function is typically the <strong>XOR</strong> (exclusive OR) of 
selected bits (called <strong>taps</strong>) from the register.</p>
<p>On each clock cycle, all bits of the register are shifted by one position to the right (or left).
The new input bit is computed from the XOR of tapped positions.
The initial state of the LFRST is called <strong>seed</strong>: 
The seed must not be all zeros, otherwise it will stay at all 0's forever.</p>
<p>An <script type="math/tex">n</script>-bit LFSR can generate at most (<script type="math/tex">2^n - 1</script>) states before repeating.
If the XOR taps are chosen correctly, the LFSR is called a <strong>maximum-length LFSR</strong>.</p>
<p>Mathematically, the tap selection depends on the so-called <strong>primitive polynomials over GF(2)</strong>, where <strong>GF(2)</strong> denotes the <strong>Galois Field with two elements: 0 and 1</strong>.</p>
<ol>
<li>Write VHDL code to implement a circuit (with the VHDL entity name <code>lfsr_demo</code>)
that instantiates the provided the LFSR module (<code>lfsr</code>) in VHDL. 
The function of the circuit is as follows:<ul>
<li>When the reset input (<code>RST_N</code>) is asserted ('0', active-low) or at power-up
  or when the button (<code>BTN</code>) is clicked, 
  the initial value from the slide switches (<code>SW</code>) 
  is loaded into both the LFSR and a register that stores the initial value (seed).</li>
<li>Otherwise, at every rising edge of the clock, the LFSR is updated 
  by shifting the newly generated bit into the register.</li>
<li>The <code>PULSE</code> signal is generated by comparing the current LFSR value
  with the initial-value register.</li>
<li>The <code>FB</code> signal is the feedback bit from the LFSR, and it is used as an output of the circuit.</li>
<li>A pre-defined primitive polynomial is selected based on the <code>N_BITS</code> generic.
  The provided primitive polynomials for the LFSR are used to generate 
  a maximum-length sequence.</li>
<li>A clock divider is used to generate a lower-frequency internal clock signal.
  The LFSR unit uses this low-frequency clock.</li>
</ul>
</li>
<li>Complete the design project and test your design on the FPGA board.</li>
<li>Use a digital oscilloscope with two probes to observe the <code>FB</code> and <code>PULSE</code> signals from the FPGA.</li>
<li>Measure the period of the <code>PULSE</code> signal.</li>
<li>Repeat the process and test your design with at least <em>three</em> different values of <code>N_BITS</code>.</li>
</ol>
<p><strong>VHDL entity for the design</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY lfsr_demo IS
    GENERIC (
        N_BITS  : INTEGER := 4;
        CLK_DIV : INTEGER := 50000
    );
    PORT (
        RST_N : IN STD_LOGIC; -- async. active-low reset
        CLK   : IN STD_LOGIC; -- system clock
        BTN   : IN STD_LOGIC; -- load seed into LFSR
        SW    : IN STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0); -- seed value
        FB    : OUT STD_LOGIC; -- feedback bit
        PULSE : OUT STD_LOGIC -- single-cycle pulse
    );
END ENTITY lfsr_demo;
</code></pre>
<p><strong>VHDL for the LSFR</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY lfsr IS
    GENERIC (
        N_BITS : INTEGER := 8 -- LFSR length (4..16 supported)
    );
    PORT (
        RST_N : IN STD_LOGIC; -- active low
        CLK   : IN STD_LOGIC;
        CE    : IN STD_LOGIC;
        LOAD  : IN STD_LOGIC;
        SEED  : IN STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0);
        Q     : OUT STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0);
        FB    : OUT STD_LOGIC
    );
END ENTITY lfsr;

ARCHITECTURE rtl OF lfsr IS
    SIGNAL reg : STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0) := (OTHERS =&gt; '1');
    SIGNAL fb_bit : STD_LOGIC := '0';
BEGIN
    -- valid range
    ASSERT (N_BITS &gt;= 4 AND N_BITS &lt;= 16)
    REPORT &quot;LFSR: N_BITS must be between 4 and 16&quot;
        SEVERITY FAILURE;

    feedback_proc : PROCESS (reg)
    BEGIN
        CASE N_BITS IS
                -- n = 4:  x^4 + x^3 + 1 
            WHEN 4 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(2);
                -- n = 5:  x^5 + x^3 + 1
            WHEN 5 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(2);
                -- n = 6:  x^6 + x^5 + 1
            WHEN 6 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4);
                -- n = 7:  x^7 + x^6 + 1 
            WHEN 7 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5);
                -- n = 8:  x^8 + x^6 + x^5 + x^4 + 1
            WHEN 8 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5) XOR reg(4) XOR reg(3);
                -- n = 9:  x^9 + x^5 + 1
            WHEN 9 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4);
                -- n = 10: x^10 + x^7 + 1 
            WHEN 10 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(6);
                -- n = 11: x^11 + x^9 + 1
            WHEN 11 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(8);
                -- n = 12: x^12 + x^6 + x^4 + x + 1
            WHEN 12 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5) XOR reg(3) XOR reg(0);
                -- n = 13: x^13 + x^4 + x^3 + x + 1 
            WHEN 13 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(3) XOR reg(2) XOR reg(0);
                -- n = 14: x^14 + x^5 + x^3 + x + 1 
            WHEN 14 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4) XOR reg(2) XOR reg(0);
                -- n = 15: x^15 + x^14 + 1 
            WHEN 15 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(13);
                -- n = 16: x^16 + x^15 + x^13 + x^4 + 1
            WHEN 16 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(14) XOR reg(12) XOR reg(3);
            WHEN OTHERS =&gt;
                -- fallback: simple tap (not maximal-length)
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(N_BITS - 2);
        END CASE;
    END PROCESS;

    ----------------------------------------------------------------------------
    -- Shift register
    ----------------------------------------------------------------------------
    PROCESS (CLK, RST_N)
    BEGIN
        IF RST_N = '0' THEN
            reg &lt;= SEED; -- async load on reset (active low)
        ELSIF rising_edge(CLK) THEN
            IF CE = '1' THEN
                IF LOAD = '1' THEN
                    reg &lt;= SEED; -- synchronous load
                ELSE
                    -- shift left (MSB at N_BITS-1), new bit becomes LSB
                    reg &lt;= reg(N_BITS - 2 DOWNTO 0) &amp; fb_bit;
                END IF;
            END IF;
        END IF;
    END PROCESS;

    Q &lt;= reg;
    FB &lt;= fb_bit;

END ARCHITECTURE;
</code></pre>
<p><img alt="" src="lfsr_waveform.jpg" /></p>
<p><strong>Figure:</strong> Example of waveforms of an 4-bit LFSR measured by a digital oscilloscope </p>
<p><strong>Questions</strong></p>
<ul>
<li>What happens if the initial value is set to all zeros?</li>
<li>How is the length (<code>N_BITS</code>) of the LFSR related to the period of the pulse signal?</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-4-on-chip-ram-testing"><strong>Lab 4: On-chip RAM Testing</strong><a class="headerlink" href="#lab-4-on-chip-ram-testing" title="Permanent link">#</a></h2>
<h3 id="objective_3"><strong>Objective</strong><a class="headerlink" href="#objective_3" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to use on-chip RAM of the MAX10 FPGA chip.</li>
</ul>
<p><strong>Embedded Memory Blocks</strong></p>
<p>Modern FPGA architectures typically include different types of storage components such as flip-flops, LUT-RAMs (also called <strong>distributed RAMs</strong>), and embedded memory blocks (also called <strong>Block RAMs</strong>). Embedded memory blocks on an FPGA have a fixed storage capacity (typically a few kilobits), but their configuration—such as memory depth and data width—is flexible. 
In addition, they support both single- and dual-port read/write memory configurations, with single or dual clocks.</p>
<p>In this lab, we will learn how to write VHDL code to infer the use of embedded memory blocks
available on the MAX10 FPGA to implement a <strong>synchronous single-port RAM</strong>.</p>
<h3 id="lab-procedure_2"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_2" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code that implements a simple <strong>on-chip RAM tester</strong> 
(with the VHDL entity name <code>ram_tester</code>).</li>
<li>The function of the RAM tester is as follows:<ul>
<li>It utilizes the provided VHDL model of a <strong>single-port synchronous RAM</strong>,
  which the Quartus software can infer to implement using the FPGA’s on-chip RAM resources.</li>
<li>The RAM has <code>N</code> data bits and <code>M</code> address bits, and should infer <strong>FPGA block RAM</strong>
  when the size of the memory (<script type="math/tex">2^M \times N</script>) is large enough to fit into
  the FPGA’s <strong>dedicated memory blocks</strong> rather than being mapped to <strong>distributed RAM logic</strong>.</li>
<li>An LFSR is used to generate test patterns for writing data into the RAM.</li>
<li>An FSM controls the RAM write and read operations for testing purposes.</li>
<li>On reset, the LFSR is seeded with an initial value, and the FSM waits for a <code>START</code> pulse.</li>
<li>When <code>START</code> is asserted by pressing the button, the FSM writes to all RAM addresses one by one, starting from address zero, with data generated by the LFSR.</li>
<li>After writing completes, the FSM reloads the same LFSR with the same seed,
  then reads back the RAM contents in the same address sequence.</li>
<li>Each read value is compared with the expected value from the LFSR for every memory address.</li>
<li>Any mismatch sets a error flag and the <code>LED_ERROR</code> output is high, otherwise it is low.</li>
<li>When the RAM test process is complete, the <code>LED_DONE</code> output is high, otherwise it is low.</li>
</ul>
</li>
<li>Demonstrate your FPGA design to the lab instructor.</li>
</ol>
<p><strong>VHDL entity for the RAM tester</strong></p>
<pre><code class="language-VHDL">ENTITY ram_tester IS
    GENERIC (
        DATA_WIDTH : INTEGER := 8;
        ADDR_WIDTH : INTEGER := 16
    );
    PORT (
        RST_N     : IN STD_LOGIC; -- active-low reset
        CLK       : IN STD_LOGIC; -- system clock
        START     : IN STD_LOGIC; -- start pulse
        SW        : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0); -- SEED
        LED_DONE  : OUT STD_LOGIC;
        LED_ERROR : OUT STD_LOGIC
    );
END ENTITY ram_tester;
</code></pre>
<p><strong>VHDL code for a single-port synchronous RAM</strong></p>
<pre><code class="language-VHDL">-- single-port synchronous RAM
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY RAM_SP IS
    GENERIC (
        DATA_WIDTH : INTEGER := 8;
        ADDR_WIDTH : INTEGER := 10
    );
    PORT (
        CLK  : IN  STD_LOGIC; -- system clock
        WE   : IN  STD_LOGIC; -- write enable
        ADDR : IN  UNSIGNED(ADDR_WIDTH - 1 DOWNTO 0);
        DIN  : IN  STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
        DOUT : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0)
    );
END ENTITY RAM_SP;

ARCHITECTURE rtl OF RAM_SP IS
    TYPE ram_t IS ARRAY (0 TO 2**ADDR_WIDTH - 1) 
         OF STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);

    FUNCTION init_ram
        RETURN ram_t IS
        VARIABLE tmp : ram_t := (OTHERS =&gt; (OTHERS =&gt; '0'));
    BEGIN
        FOR addr_pos IN 0 TO 2**ADDR_WIDTH - 1 LOOP
            -- Initialize each address with the address itself
            tmp(addr_pos) := STD_LOGIC_VECTOR(to_unsigned(addr_pos, DATA_WIDTH));
        END LOOP;
        RETURN tmp;
    END init_ram;

    -- RAM declaration with initialization (use this for simulation only!)
    --signal ram : ram_t := init_ram;

    -- RAM declaration without initialization (use this for synthesis!)
    SIGNAL ram : ram_t;

    SIGNAL addr_reg : NATURAL RANGE 0 TO 2**ADDR_WIDTH - 1 := 0;

BEGIN
    PROCESS (CLK)
    BEGIN
        IF rising_edge(CLK) THEN
            IF WE = '1' THEN
                ram(to_integer(ADDR)) &lt;= DIN; -- synchronous write operation
            END IF;
            addr_reg &lt;= to_integer(ADDR);
        END IF;
    END PROCESS;
    DOUT &lt;= ram(addr_reg); -- synchronous read operation

END ARCHITECTURE;
</code></pre>
<p><img alt="" src="tb_ram_tester_sim.jpg" /></p>
<p><strong>Figure:</strong> Example of simulation waveforms (using GHDL and GTKwave for VHDL simulation)</p>
<p><strong>Questions</strong></p>
<ul>
<li>For a data width of 8 bits, what is the maximum memory depth that can be used and still fit on the target FPGA?</li>
<li>For the FPGA device on the board used in this lab session, what is the maximum size of a single block RAM, and how many such blocks are available?</li>
<li>How does the width of the data bus affect the number of block RAMs required to implement a given memory?</li>
<li>How can it be checked whether memory inference in VHDL will use block RAM rather than distributed logic?</li>
</ul>
<hr />
<h2 id="lab-5-ram-based-fifo-testing"><strong>Lab 5: RAM-based FIFO Testing</strong><a class="headerlink" href="#lab-5-ram-based-fifo-testing" title="Permanent link">#</a></h2>
<h3 id="objective_4"><strong>Objective</strong><a class="headerlink" href="#objective_4" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to use on-chip RAM of the MAX10 FPGA chip to implement a FIFO.</li>
<li>Understand the principles of FIFO (First-In-First-Out) memory.</li>
</ul>
<p>A <strong>FIFO</strong> (<em>First-In-First-Out</em>) is a special type of memory that stores data 
in the order it is written and guarantees that the first data written is 
the first data read. It is commonly used for buffering and data streaming.</p>
<p>In this lab, we will use the FPGA’s embedded memory blocks to implement a FIFO with two independent, synchronous read and write ports.</p>
<h3 id="lab-procedure_3"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_3" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL testbench (<code>tb_fifo_sc</code>) to simulate the operation of the 
the provided FIFO module (<code>fifo_sc</code>), which requires
a single-clock, dual-port RAM module (<code>ram_dp_sc</code>).</li>
<li>Write VHDL code that implements a simple <strong>FIFO tester</strong> 
(with the VHDL entity name <code>fifo_tester</code>).</li>
<li>The function of the FIFO tester is as follows:<ul>
<li>It uses the provided FIFO module (<code>fifo_sc</code>).</li>
<li>Two onboard push buttons are used for the <code>RST_N</code> signal and the <code>TEST</code> signal. Both input signals are active-low.</li>
<li>Two onboard slide switches are used to select the <strong>FIFO put and get operations</strong>.</li>
<li>Two onboard LEDs are used to indicate the <strong>FIFO full and empty status</strong>.</li>
<li>The <code>TEST</code> input must be processed through debounce logic.</li>
<li>If <code>TEST</code> is held ('0') and <code>PUT</code> = '1', the tester puts the next value from an 8-bit counter into the FIFO every 100 ms, provided the FIFO is not full.</li>
<li>If <code>TEST</code> is held ('0') and <code>GET</code> = '1', the tester gets data from the FIFO every 100 ms, provided the FIFO is not empty.</li>
<li>Data pushed comes from an 8-bit counter that increments each time.
  Initially, the counter starts with the value <code>0xA0</code> (hex).</li>
<li>The input data to the FIFO is displayed in HEX format on two 7-segment displays.</li>
<li>The output data from the FIFO is displayed in HEX format on two 7-segment displays.</li>
</ul>
</li>
<li>Complete the design project and test your design on the FPGA board.<ul>
<li>Synthesize, implement, and download the design to the FPGA board.</li>
<li>Apply test inputs using the switches and observe the results.</li>
<li>Verify that the sequence of input data matches the sequence of output data according to FIFO operation.</li>
<li>Check the FIFO full and empty indicators using the LEDs.</li>
<li>Test the design with two different FIFO depth settings (e.g., memory depths of 16 and 256). This step requires changing the memory depth and recompiling the design.</li>
</ul>
</li>
</ol>
<p><img alt="" src="fifo_sim-1.jpg" /></p>
<p><img alt="" src="fifo_sim-2.jpg" /></p>
<p><strong>Figure:</strong> Example waveform of FIFO simulation (FIFO depth = 16)</p>
<p><strong>VHDL entity for the FIFO tester</strong> (<code>fifo_tester</code>)</p>
<pre><code class="language-VHDL">ENTITY fifo_tester IS
    PORT (
        RST_N : IN STD_LOGIC;  -- active-low reset
        CLK   : IN STD_LOGIC;  -- 50 MHz clock
        TEST  : IN STD_LOGIC;  -- test button
        PUT   : IN STD_LOGIC;  -- FIFO put operation
        GET   : IN STD_LOGIC;  -- FIFO get operation
        FULL  : OUT STD_LOGIC; -- FIFO full flag (LED)
        EMPTY : OUT STD_LOGIC; -- FIFO empty flag (LED)
        HEX3  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- for data output
        HEX2  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX1  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- for data input
        HEX0  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
    );
END ENTITY;
</code></pre>
<p><strong>VHDL code for dual-port, single-clock synchronous RAM</strong></p>
<pre><code class="language-VHDL">-- Simple dual-port RAM with different read/write addresses 
-- but single read/write clock

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY ram_dp_sc IS
    GENERIC (
        DATA_WIDTH : NATURAL := 8;
        ADDR_WIDTH : NATURAL := 6
    );
    PORT (
        clk   : IN STD_LOGIC;         -- clock
        we    : IN STD_LOGIC := '0';  -- write enable
        raddr : IN NATURAL RANGE 0 TO 2**ADDR_WIDTH - 1; -- read address
        waddr : IN NATURAL RANGE 0 TO 2**ADDR_WIDTH - 1; -- write address
        data  : IN  STD_LOGIC_VECTOR((DATA_WIDTH - 1) DOWNTO 0); -- data in
        q     : OUT STD_LOGIC_VECTOR((DATA_WIDTH - 1) DOWNTO 0)  -- data out
    );

END ENTITY;

ARCHITECTURE rtl OF ram_dp_sc IS
    -- Build a 2-D array type for the RAM
    SUBTYPE word_t IS STD_LOGIC_VECTOR((DATA_WIDTH - 1) DOWNTO 0);
    TYPE memory_t IS ARRAY(2**ADDR_WIDTH - 1 DOWNTO 0) OF word_t;
    -- Declare the RAM signal. 
    SIGNAL ram : memory_t;

BEGIN
    PROCESS (clk)
    BEGIN
        IF (rising_edge(clk)) THEN
            IF (we = '1') THEN
                ram(waddr) &lt;= data; -- write the data
            END IF;
            q &lt;= ram(raddr); -- read the data
        END IF;
    END PROCESS;
END rtl;
</code></pre>
<p><strong>VHDL code for single-clock FIFO</strong></p>
<pre><code class="language-VHDL">-- Single-clock FIFO (Altera-like behavior, show-ahead)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY fifo_sc IS
    GENERIC (
        DATA_WIDTH : NATURAL := 8;
        ADDR_WIDTH : NATURAL := 10 -- FIFO depth = 2^ADDR_WIDTH
    );
    PORT (
        clk   : IN STD_LOGIC;
        rst_n : IN STD_LOGIC;
        wr_en : IN STD_LOGIC;
        rd_en : IN STD_LOGIC;
        din   : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
        dout  : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
        full  : OUT STD_LOGIC;
        empty : OUT STD_LOGIC
    );
END ENTITY;

ARCHITECTURE rtl OF fifo_sc IS
    CONSTANT MEM_DEPTH : NATURAL := 2 ** ADDR_WIDTH;

    SIGNAL wr_ptr, rd_ptr : NATURAL RANGE 0 TO MEM_DEPTH - 1 := 0;
    SIGNAL fifo_count : NATURAL RANGE 0 TO MEM_DEPTH := 0;

    SIGNAL ram_in   : STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
    SIGNAL ram_out  : STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
    SIGNAL dout_reg : STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0) := (OTHERS =&gt; '0');
    SIGNAL ram_we   : STD_LOGIC;
    SIGNAL is_full, is_empty : STD_LOGIC;

BEGIN
    ram_in &lt;= din;
    ram_we &lt;= (wr_en AND NOT is_full);

    -- dual-port RAM
    u_ram : ENTITY work.ram_dp_sc
        GENERIC MAP(
            DATA_WIDTH =&gt; DATA_WIDTH,
            ADDR_WIDTH =&gt; ADDR_WIDTH
        )
        PORT MAP(
            clk =&gt; clk,
            raddr =&gt; rd_ptr,
            waddr =&gt; wr_ptr,
            data =&gt; ram_in,
            we =&gt; ram_we,
            q =&gt; ram_out
        );

    fifo_wr_proc : PROCESS (clk, rst_n)
    BEGIN
        IF rst_n = '0' THEN
            wr_ptr &lt;= 0;
        ELSIF rising_edge(clk) THEN
            IF (wr_en = '1' AND is_full = '0') THEN
                IF wr_ptr = MEM_DEPTH - 1 THEN
                    wr_ptr &lt;= 0;
                ELSE
                    wr_ptr &lt;= wr_ptr + 1;
                END IF;
            END IF;
        END IF;
    END PROCESS;

    fifo_rd_proc : PROCESS (clk, rst_n)
    BEGIN
        IF rst_n = '0' THEN
            rd_ptr &lt;= 0;
            dout_reg &lt;= (OTHERS =&gt; '0');
        ELSIF rising_edge(clk) THEN
            -- Update read pointer when valid read
            IF (rd_en = '1' AND is_empty = '0') THEN
                IF rd_ptr = MEM_DEPTH - 1 THEN
                    rd_ptr &lt;= 0;
                ELSE
                    rd_ptr &lt;= rd_ptr + 1;
                END IF;
            END IF;
            -- Output logic
            IF (rd_en = '1' AND is_empty = '0') THEN
                -- Normal read
                dout_reg &lt;= ram_out;
            END IF;
        END IF;
    END PROCESS;

    fifo_cnt_proc : PROCESS (clk, rst_n)
        VARIABLE wr_rd_en : STD_LOGIC_VECTOR(1 DOWNTO 0);
    BEGIN
        IF rst_n = '0' THEN
            fifo_count &lt;= 0;
        ELSIF rising_edge(clk) THEN
            wr_rd_en := wr_en &amp; rd_en;
            CASE wr_rd_en IS
                WHEN &quot;10&quot; =&gt; -- write only
                    IF is_full = '0' THEN
                        fifo_count &lt;= fifo_count + 1;
                    END IF;
                WHEN &quot;01&quot; =&gt; -- read only
                    IF is_empty = '0' THEN
                        fifo_count &lt;= fifo_count - 1;
                    END IF;
                WHEN OTHERS =&gt;
                    NULL; -- write+read (no net change) or idle
            END CASE;
        END IF;
    END PROCESS;

    -- Status signals
    is_full &lt;= '1' WHEN fifo_count = MEM_DEPTH ELSE
        '0';
    is_empty &lt;= '1' WHEN fifo_count = 0 ELSE
        '0';

    full &lt;= is_full;
    empty &lt;= is_empty;
    dout &lt;= dout_reg;
END ARCHITECTURE;
</code></pre>
<p><strong>Questions</strong></p>
<ul>
<li>What are the initial logic states of the <code>EMPTY</code> and <code>FULL</code> signals?</li>
<li>If the FIFO is not empty, does the data output of the FIFO give the first data to be read?</li>
<li>Explain the behavior of the FIFO by observing <code>din</code> and <code>dout</code>
on the 7-segment display when the FIFO is empty, and both 
the <code>PUT</code> and <code>GET</code> inputs are '1', while <code>TEST</code> is clicked multiple times.</li>
<li>According to the Quartus synthesis report, how many bits of on-chip memory are used to implement the FIFO for FIFO depths of 16 and 256, respectively?</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-6-altera-fifo-ip-core-testing"><strong>Lab 6: Altera FIFO IP Core Testing</strong><a class="headerlink" href="#lab-6-altera-fifo-ip-core-testing" title="Permanent link">#</a></h2>
<h3 id="objective_5"><strong>Objective</strong><a class="headerlink" href="#objective_5" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to use an FIFO generated by Intel/Altera IP Catalog.</li>
</ul>
<h3 id="lab-procedure_4"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_4" title="Permanent link">#</a></h3>
<ol>
<li>Create a new project in <strong>Quartus Prime Lite</strong> first, then open the <strong>IP Catalog</strong>:<ul>
<li>Select <strong>FIFO</strong>:
Tools &gt; IP Catalog &gt; Basic Functions &gt; On-Chip Memory &gt; FIFO</li>
<li>Set the IP variation filename to <code>fifo_ip</code> (use VHDL file type).</li>
<li>Configure the FIFO IP core:<ul>
<li>Use single common clock for both FIFO read and write operations.</li>
<li>Select the data with (e.g. 8 bits) and the FIFO depth (e.g. 256).</li>
</ul>
</li>
<li>Make sure that the FIFO IP core will have the following interface
as shown in the figure below.</li>
<li>Generate the IP core and insert the <strong>.qip</strong> file into the project.</li>
</ul>
</li>
<li>Reuse your code from <strong>Lab 5</strong>, but replace the FIFO with the one generated
by the IP Catalog.        </li>
<li>Complete the design project and test your design on the FPGA board.</li>
</ol>
<p>&nbsp;</p>
<p><img alt="" src="fifo_ip-1.jpg" /></p>
<p><strong>Figure:</strong> Setting the IP variation filename for the FIFO</p>
<p><img alt="" src="fifo_ip-2.jpg" /></p>
<p><strong>Figure:</strong> FIFO Configuration (single-clock, synchronous FIFO mode)</p>
<p><img alt="" src="fifo_ip-3.jpg" /></p>
<p><strong>Figure:</strong> FIFO Configuration (with FIFO full, empty status and asynchronous clear)</p>
<p><img alt="" src="fifo_ip-4.jpg" /></p>
<p><strong>Figure:</strong> FIFO File Generation</p>
<p><strong>VHDL entity of the FIFO generated by the IP Catalog</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY altera_mf;
USE altera_mf.all;

ENTITY fifo_ip IS
    PORT (
        aclr   : IN STD_LOGIC ;  -- async. clear
        clock  : IN STD_LOGIC ;  -- clock
        data   : IN STD_LOGIC_VECTOR (7 DOWNTO 0); -- data in
        rdreq  : IN STD_LOGIC ;  -- FIFO read request
        wrreq  : IN STD_LOGIC ;  -- FIFO write request
        empty  : OUT STD_LOGIC ; -- FIFO empty status
        full   : OUT STD_LOGIC ; -- FIFO full status
        q      : OUT STD_LOGIC_VECTOR (7 DOWNTO 0) -- data out
    );
END fifo_ip;
</code></pre>
<p><strong>Questions</strong></p>
<ul>
<li>Explain the behavior of the FIFO by observing <code>din</code> and <code>dout</code>
on the 7-segment display when the FIFO is empty, and both 
the <code>PUT</code> and <code>GET</code> inputs are '1', while <code>TEST</code> is clicked multiple times.</li>
<li>Does the behavior of the FIFO in Lab 6 differ from that in Lab 5? If so, describe the difference.</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-7-signed-multiplier"><strong>Lab 7: Signed Multiplier</strong><a class="headerlink" href="#lab-7-signed-multiplier" title="Permanent link">#</a></h2>
<h3 id="objective_6"><strong>Objective</strong><a class="headerlink" href="#objective_6" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement a signed multiplier in VHDL.</li>
</ul>
<p>Multiplication is an arithmetic operation that can be implemented
in digital logic circuits using various methods.
In this lab, we will implement an <strong>array multiplier for
two signed integers in 2’s complement form</strong>:
<script type="math/tex">p = a \cdot b</script>, where <script type="math/tex">a</script> and <script type="math/tex">b</script> (the multiplicand and multiplier) are <script type="math/tex">N</script>-bit signed integers, and <script type="math/tex">p</script> is their <script type="math/tex">2N</script>-bit product.</p>
<p>
<script type="math/tex; mode=display">\begin{align}
   a &= -a_{N-1}\cdot 2^{N-1} + \sum_{i=0}^{N-2} a_{i} \cdot 2^{i}, \, a_i \in \{0,1\} \\
   b &= -b_{N-1}\cdot 2^{N-1} + \sum_{i=0}^{N-2} b_{i} \cdot 2^{i}, \, b_i \in \{0,1\} \\
   p &= -p_{2N-1}\cdot 2^{2N-1} + \sum_{i=0}^{2N-2} p_{i} \cdot 2^{i}, \, p_i \in \{0,1\} \\
     &= a \cdot b = a \cdot ( -b_{N-1}\cdot 2^{N-1} + \sum_{i=0}^{N-2} b_{i} \cdot 2^{i} ) \\
     &= -b_{N-1} (a \ll (N-1)) + \sum_{i=0}^{N-2} b_{i} (a \ll i) \\
\end{align}</script>
</p>
<p>Note that multiplication by <script type="math/tex">2^i</script> is equivalent to shifting <script type="math/tex">a</script> left by <script type="math/tex">i</script> bit positions:
<script type="math/tex">a \cdot 2^i = a \ll i</script>. Before shifting, <script type="math/tex">a</script> must be signed extended to <script type="math/tex">2N</script> bits.</p>
<h3 id="lab-procedure_5"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_5" title="Permanent link">#</a></h3>
<ol>
<li>Write a VHDL testbench to simulate a signed array multiplier module.
Its VHDL code (<code>mult_signed</code>) is provided below.<ul>
<li>There are two different implementation styles of the signed multiplier 
 (<code>rtl_infer</code> and <code>rtl_array</code>) in the VHDL code. </li>
</ul>
</li>
<li>Write VHDL code (<code>mult_tester</code>) to test the signed multiplier. </li>
<li>The multiplier tester has the following functions:<ul>
<li>The VHDL entity of the design is given below.</li>
<li>It uses the provided multiplier module (<code>mult_signed</code>).</li>
<li>It takes input from 10-bit slide switches on the FPGA board to provide 
  two 5-bit signed integers (2's complement representation) to the multiplier.</li>
<li>The output of the multiplier is a 10-bit signed integer, 
  which is displayed on four 7-segment display units. 
  If the number is negative, the leftmost 7-segment unit must show a minus sign.</li>
<li>For example, the slide switch input <code>1000001111</code> (bin) represents
  the multiplier and multiplicand of <code>10000</code> = -16 and <code>01111</code> = 15, 
  respectively and the multiplication result is -240.</li>
<li>The signed multiplier (<code>mult_signed</code>) is combinational, 
  meaning it computes the full multiplication result in a single clock cycle.</li>
<li>The circuit has a system clock of 50 MHz and an asynchronous reset. 
  The input signals from the slide switches must be registered before 
  being fed to the multiplier. The result from the multiplier must 
  also be registered before being used by the 7-segment display.</li>
</ul>
</li>
<li>Complete the design project and test your design on the FPGA board.
Compare the synthesis results for both multiplier implementation styles.</li>
<li>Reimplement the signed-multiplier module as a <strong>sequential, multi-cycle multiplier</strong> that produces the same result. The multiplication will take several clock cycles rather than being completed in a single cycle. Revise the VHDL code of the top-level module to match the sequential version of the signed-multiplier module.</li>
</ol>
<p><strong>Questions:</strong></p>
<ul>
<li>Based on the provided VHDL code for a signed array multiplier, describe how the array multiplier builds the product step by step: from generating partial products, to combining them, and finally to handling the signed case.</li>
<li>According to the Quartus synthesis report, which implementation style of 
the signed multiplier uses fewer FPGA logic resources?</li>
<li>According to the Static Timing Analysis report, which implementation style 
of the signed multiplier has the maximum clock frequency (Fmax)?</li>
</ul>
<p><img alt="" src="signed_mult_sim.jpg" /></p>
<p><strong>Figure:</strong> Example of simulation waveforms</p>
<p><strong>The VHDL entity of the multiplier (top-level design)</strong></p>
<pre><code class="language-VHDL">ENTITY multiplier IS
    PORT (
        CLK   : IN STD_LOGIC; -- system clock
        RST_N : IN STD_LOGIC; -- async active-low reset
        SW    : IN  STD_LOGIC_VECTOR(9 DOWNTO 0); -- multiplier input
        HEX0  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- 7-seg outputs
        HEX1  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX2  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX3  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
    );
END ENTITY;
</code></pre>
<p><strong>VHDL code for the signed array multiplier</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY mult_signed IS
  GENERIC (
    N : INTEGER := 8 -- operand size
  );
  PORT (
    a : IN signed(N - 1 DOWNTO 0);
    b : IN signed(N - 1 DOWNTO 0);
    p : OUT signed(2 * N - 1 DOWNTO 0)
  );
END ENTITY;

-- Inferred multiplier
ARCHITECTURE rtl_infer OF mult_signed IS
BEGIN
  p &lt;= a * b;
END rtl_infer;

-- array multiplier 
ARCHITECTURE rtl_array OF mult_signed IS
BEGIN
  PROCESS (a, b)
    VARIABLE product : signed(2 * N - 1 DOWNTO 0);
    VARIABLE pp : signed(2 * N - 1 DOWNTO 0); -- partial product
  BEGIN
    product := (OTHERS =&gt; '0');
    -- Generate partial products
    FOR i IN 0 TO N - 2 LOOP
      IF b(i) = '1' THEN
        pp := resize(a, 2 * N) SLL i; -- shift left by i
        product := product + pp;
      END IF;
    END LOOP;
    -- Handle negative numbers (2's complement)
    IF b(N - 1) = '1' THEN
      product := product - (resize(a, 2 * N) SLL (N - 1));
    END IF;
    p &lt;= product;
  END PROCESS;
END ARCHITECTURE rtl_array;
</code></pre>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2025-09-03 | Last Updated: 2025-09-09</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
