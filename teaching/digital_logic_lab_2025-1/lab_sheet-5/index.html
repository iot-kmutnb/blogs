<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/teaching/digital_logic_lab_2025-1/lab_sheet-5/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Lab Sheet 5 - IoT Engineering Education</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#lab-sheet-5" class="nav-link">Lab Sheet 5</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#hardware-software-required" class="nav-link">Hardware / Software Required</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-1-ripple-carry-adder-vs-carry-select-adder" class="nav-link">Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-2-accumulator" class="nav-link">Lab 2: Accumulator</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_1" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_1" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-3-linear-feedback-shift-register-lfsr" class="nav-link">Lab 3: Linear Feedback Shift Register (LFSR)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_2" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lab-4-on-chip-ram-testing" class="nav-link">Lab 4: On-chip RAM Testing</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#objective_3" class="nav-link">Objective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#lab-procedure_2" class="nav-link">Lab Procedure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="lab-sheet-5"><strong>Lab Sheet 5</strong><a class="headerlink" href="#lab-sheet-5" title="Permanent link">#</a></h1>
<p>This lab sheet contains the following lab activities:</p>
<ul>
<li><a href="#lab-1-ripple-carry-adder-vs-carry-select-adder"><strong>Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</strong></a></li>
<li><a href="#lab-2-accumulator"><strong>Lab 2: Accumulator</strong></a></li>
<li><a href="#lab-3-linear-feedback-shift-register-lfsr"><strong>Lab 3: Linear Feedback Shift Register (LFSR)</strong></a></li>
<li><a href="#lab-4-on-chip-ram-testing"><strong>Lab 4: On-chip RAM Testing</strong></a></li>
</ul>
<h3 id="hardware-software-required"><strong>Hardware / Software Required</strong><a class="headerlink" href="#hardware-software-required" title="Permanent link">#</a></h3>
<ul>
<li>Intel DE10-Lite FPGA board (with a USB cable)</li>
<li>Computer with USB ports + Intel Quartus Prime Lite + VHDL Simulator</li>
<li>Digital Oscilloscope or Logic Analyzer</li>
<li>Jumper Wires / Dupont Wires</li>
</ul>
<hr />
<h2 id="lab-1-ripple-carry-adder-vs-carry-select-adder"><strong>Lab 1: Ripple-Carry Adder vs. Carry-Select Adder</strong><a class="headerlink" href="#lab-1-ripple-carry-adder-vs-carry-select-adder" title="Permanent link">#</a></h2>
<h3 id="objective"><strong>Objective</strong><a class="headerlink" href="#objective" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement different types of binary adders using FPGA logic.</li>
</ul>
<p>In digital logic design, there are different ways to implement
N-bit binary adders. In this lab, we will explore 
how to implement two types of <script type="math/tex">N</script>-bit binary adders, namely the 
<strong>Ripple-Carry Adder (RCA)</strong> and the <strong>Carry-Select Adder (CSA)</strong>,
and compare the synthesis results when mapped to FPGA logic resources.
Their pseudo-code is given below.</p>
<p><strong>Pseudo-code for Ripple-Carry Adder:</strong></p>
<pre><code class="language-text">C[0] = CIN
for i=0 to N-1:
  SUM[i] = A[i] xor B[i] xor C[i]
  C[i+1] = (A[i] AND B[i]) OR (C[i] AND (A[i] XOR B[i]))
COUT = C[N]
</code></pre>
<p><strong>Note</strong> </p>
<ul>
<li>Each <script type="math/tex">i</script>-th stage of the ripple-carry adder is a full adder (FA).</li>
<li><code>CIN</code> and <code>COUT</code> are the carry-in and carry-out of the <script type="math/tex">N</script>-bit adder, respectively.</li>
</ul>
<p><strong>Pseudo-code for Carry-Select Adder (1 bit per step):</strong></p>
<pre><code class="language-text">C[0] = CIN
for i=0 to N-1:
     // if C[i] = 0
     sum0   = (A[i] XOR B[i])
     c_out0 = (A[i] AND B[i])

     // if C[i] = 1
     sum1   = NOT(A[i] XOR B[i])
     c_out1 = (A[i] AND B[i]) OR (A[i] XOR B[i])

     // carry select
     if C[i] == 0:
         SUM[i] = sum0
         C[i+1] = c_out0
     else:
         SUM[i] = sum1
         C[i+1] = c_out1
COUT = C[N]
</code></pre>
<h3 id="lab-procedure"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code to implement an <strong>N-bit adder</strong>, where <code>N</code> is defined as 
a generic (positive integer). Use the provided VHDL entity.</li>
<li>Write VHDL for two different architectural implementations:<ul>
<li>Option 1: <strong>Ripple-Carry Adder</strong></li>
<li>Option 2: <strong>Carry-Select Adder</strong></li>
</ul>
</li>
<li>Write your own VHDL testbench (or use the provided code) to simulate
and verify your design. Capture the simulation waveforms for your lab report.</li>
<li>Use the Quartus Prime Lite software to synthesize both versions of the adder
and compare the synthesis results.</li>
</ol>
<p><strong>VHDL entity for the adder</strong></p>
<pre><code class="language-VHDL">ENTITY adder IS
    GENERIC (
        N : INTEGER := 8
    );
    PORT (
        CIN  : IN  STD_LOGIC; -- carry-in
        A, B : IN  STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- operands
        SUM  : OUT STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- result
        COUT : OUT STD_LOGIC -- carry-out
    );
END ENTITY adder;
</code></pre>
<p><strong>VHDL testbench for the adder</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY tb_adder IS
END ENTITY tb_adder;

ARCHITECTURE sim OF tb_adder IS
    CONSTANT N  : INTEGER := 4;

    SIGNAL CIN  : STD_LOGIC := '0';
    SIGNAL A, B : STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
    SIGNAL SUM  : STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
    SIGNAL COUT : STD_LOGIC;

    -- DUT: Try RCA or CSA here
    COMPONENT ADDER IS
        GENERIC (N : INTEGER := 8);
        PORT (
            CIN  : IN STD_LOGIC;
            A, B : IN  STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
            SUM  : OUT STD_LOGIC_VECTOR(N - 1 DOWNTO 0);
            COUT : OUT STD_LOGIC
        );
    END COMPONENT;

BEGIN
    -- Instantiate an adder
    uut : ENTITY work.adder(RCA) -- use RCA or CSA
        GENERIC MAP(N =&gt; N)
        PORT MAP(
            CIN =&gt; CIN, A =&gt; A, B =&gt; B,
            SUM =&gt; SUM, COUT =&gt; COUT
        );

    -- Test process
    stim_proc : PROCESS
        VARIABLE expected : UNSIGNED(N DOWNTO 0); -- N bits + carry
    BEGIN
        FOR intA IN 0 TO 2**N - 1 LOOP
            FOR intB IN 0 TO 2**N - 1 LOOP
                -- apply inputs
                A &lt;= STD_LOGIC_VECTOR(to_unsigned(intA, N));
                B &lt;= STD_LOGIC_VECTOR(to_unsigned(intB, N));

                CIN &lt;= '0';
                WAIT FOR 10 ns;

                expected := to_unsigned(intA + intB, N + 1);
                ASSERT (unsigned(SUM) = expected(N - 1 DOWNTO 0) AND
                COUT = STD_LOGIC(expected(N)))
                REPORT &quot;Mismatch CIN=0: A=&quot; &amp; INTEGER'IMAGE(intA) &amp;
                    &quot; B=&quot; &amp; INTEGER'IMAGE(intB) &amp;
                    &quot; SUM=&quot; &amp; INTEGER'IMAGE(to_integer(unsigned(SUM))) &amp;
                    &quot; COUT=&quot; &amp; STD_LOGIC'IMAGE(COUT)
                    SEVERITY ERROR;

                CIN &lt;= '1';
                WAIT FOR 10 ns;

                expected := to_unsigned(intA + intB + 1, N + 1);
                ASSERT (unsigned(SUM) = expected(N - 1 DOWNTO 0) AND
                COUT = STD_LOGIC(expected(N)))
                REPORT &quot;Mismatch CIN=0: A=&quot; &amp; INTEGER'IMAGE(intA) &amp;
                    &quot; B=&quot; &amp; INTEGER'IMAGE(intB) &amp;
                    &quot; SUM=&quot; &amp; INTEGER'IMAGE(to_integer(unsigned(SUM))) &amp;
                    &quot; COUT=&quot; &amp; STD_LOGIC'IMAGE(COUT)
                    SEVERITY ERROR;

            END LOOP;
        END LOOP;
        WAIT; -- stop simulation
    END PROCESS;

END ARCHITECTURE sim;
</code></pre>
<p><strong>Questions</strong></p>
<ul>
<li>How do the two adder implementations differ in terms of logic resource usage?</li>
<li>Compare the critical paths of both designs (for example, the signal path 
from <code>CIN</code> to <code>COUT</code> in the circuit). Use Quartus Prime's synthesis &amp; 
static timing analysis (STA) report to identify the critical paths.</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-2-accumulator"><strong>Lab 2: Accumulator</strong><a class="headerlink" href="#lab-2-accumulator" title="Permanent link">#</a></h2>
<h3 id="objective_1"><strong>Objective</strong><a class="headerlink" href="#objective_1" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement an accumulator in VHDL and test its function using an FPGA board.</li>
</ul>
<p>An <strong>accumulator</strong> is a basic sequential circuit widely used in digital systems. 
Its main function is to add input data to its current stored value.</p>
<p>Two main components of the accumulator are:</p>
<ul>
<li>Adder: this adds the input value to the current contents of the register.</li>
<li>Register: this stores the accumulated sum and feeds it back into the adder
on the next clock cycle.</li>
</ul>
<h3 id="lab-procedure_1"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_1" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code to implement an accumulator.
Use an <code>N</code>-bit adder and an <code>M</code>-bit register 
(where <code>M &gt; N</code>, e.g., <code>N=8</code>, <code>M=12</code>) to implement the accumulator.
Make the design modular by creating separate components 
and then instantiating them in the top-level accumulator system (<code>accumulator_demo</code>).</li>
<li>Connect the I/O of the accumulator as follows:<ul>
<li>The integer (unsigned) value from the external <code>N</code>-bit slide switches 
  is internally zero-extended to <code>M</code> bits and applied as one input of the adder.</li>
<li>The output of the accumulator register is fed back into 
  the other <code>M</code>-bit input of the adder.</li>
<li>The <code>M</code>-bit result is stored in the accumulator register,
  decoded into BCD, and displayed on the external 4-digit seven-segment display.</li>
<li>The accumulator register is updated on the rising edge of 
  the push-button signal (after debouncing and edge detection).</li>
</ul>
</li>
<li>Write a VHDL testbench to simulate and test your design
to verify its correctness.</li>
<li>Complete the FPGA design process and test your design using the FPGA board (Terasic DE10-Lite) provided in the lab.<ul>
<li>Change the positions of the slide switches before pressing the button,
and observe the resulting change in the accumulator value.</li>
</ul>
</li>
</ol>
<p><strong>VHDL entity for the accumulator demo</strong></p>
<pre><code class="language-VHDL">
ENTITY accumulator_demo IS
    GENERIC (
        N : INTEGER := 8;
        M : INTEGER := 12
    );
    PORT (
        RST_N : IN STD_LOGIC; -- global async. active-low reset
        CLK   : IN STD_LOGIC; -- clock
        BTN   : IN STD_LOGIC; -- push button
        SW    : IN STD_LOGIC_VECTOR(N - 1 DOWNTO 0); -- N-bit input
        -- 7seg digits 3~0 (output)
        HEX0  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX1  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);  
        HEX2  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        HEX3  : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)   
    );
END ENTITY accumulator_demo;
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="lab-3-linear-feedback-shift-register-lfsr"><strong>Lab 3: Linear Feedback Shift Register (LFSR)</strong><a class="headerlink" href="#lab-3-linear-feedback-shift-register-lfsr" title="Permanent link">#</a></h2>
<h3 id="objective_2"><strong>Objective</strong><a class="headerlink" href="#objective_2" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to implement an LFSR in VHDL.</li>
<li>Learn how to LFSRs to produce pseudo-random numbers for testing purposes.</li>
</ul>
<p>In this task, we will learn about the <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register"><strong>LFSR</strong></a>, which is a special type of shift register 
that can be used to implement a <strong>pseudo-random</strong> number generator 
(not a true-random number generator) for FPGA designs.</p>
<p>An LFSR consists of a register (flip-flops) and a feedback function.
The feedback function is typically the <strong>XOR</strong> (exclusive OR) of 
selected bits (called <strong>taps</strong>) from the register.</p>
<p>On each clock cycle, all bits of the register are shifted by one position to the right (or left).
The new input bit is computed from the XOR of tapped positions.
The initial state of the LFRST is called <strong>seed</strong>: 
The seed must not be all zeros, otherwise it will stay at all 0's forever.</p>
<p>An <script type="math/tex">n</script>-bit LFSR can generate at most (<script type="math/tex">2^n - 1</script>) states before repeating.
If the XOR taps are chosen correctly, the LFSR is called a <strong>maximum-length LFSR</strong>.</p>
<p>Mathematically, the tap selection depends on the so-called <strong>primitive polynomials over GF(2)</strong>, where <strong>GF(2)</strong> denotes the <strong>Galois Field with two elements: 0 and 1</strong>.</p>
<ol>
<li>Write VHDL code to implement a circuit that uses the provided VHDL code
for an LFSR. The function of the circuit is as follows:<ul>
<li>When the reset input (<code>RST_N</code>) is asserted ('0', active-low) or at power-up
  or when the button (<code>BTN</code>) is clicked, 
  the initial value from the slide switches (<code>SW</code>) 
  is loaded into both the LFSR and a register that stores the initial value (seed).</li>
<li>Otherwise, at every rising edge of the clock, the LFSR is updated 
  by shifting the newly generated bit into the register.</li>
<li>The <code>PULSE</code> signal is generated by comparing the current LFSR value
  with the initial-value register.</li>
<li>The <code>FB</code> signal is the feedback bit from the LFSR, and it is used as an output of the circuit.</li>
<li>A pre-defined primitive polynomial is selected based on the <code>N_BITS</code> generic.
  The provided primitive polynomials for the LFSR are used to generate 
  a maximum-length sequence.</li>
<li>A clock divider is used to generate a lower-frequency internal clock signal.
  The LFSR unit uses this low-frequency clock.</li>
</ul>
</li>
<li>Complete the design project and test your design on the FPGA board.</li>
<li>Use a digital oscilloscope with two probes to observe the <code>FB</code> and <code>PULSE</code> signals from the FPGA.</li>
<li>Measure the period of the <code>PULSE</code> signal.</li>
<li>Repeat the process and test your design with at least <em>three</em> different values of <code>N_BITS</code>.</li>
</ol>
<p><strong>VHDL entity for the design</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY lfsr_demo IS
    GENERIC (
        N_BITS  : INTEGER := 4;
        CLK_DIV : INTEGER := 50000
    );
    PORT (
        RST_N : IN STD_LOGIC; -- async. active-low reset
        CLK   : IN STD_LOGIC; -- system clock
        BTN   : IN STD_LOGIC; -- load seed into LFSR
        SW    : IN STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0); -- seed value
        FB    : OUT STD_LOGIC; -- feedback bit
        PULSE : OUT STD_LOGIC -- single-cycle pulse
    );
END ENTITY lfsr_demo;
</code></pre>
<p><strong>VHDL for the LSFR</strong></p>
<pre><code class="language-VHDL">LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY lfsr IS
    GENERIC (
        N_BITS : INTEGER := 8 -- LFSR length (4..16 supported)
    );
    PORT (
        RST_N : IN STD_LOGIC; -- active low
        CLK   : IN STD_LOGIC;
        CE    : IN STD_LOGIC;
        LOAD  : IN STD_LOGIC;
        SEED  : IN STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0);
        Q     : OUT STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0);
        FB    : OUT STD_LOGIC
    );
END ENTITY lfsr;

ARCHITECTURE rtl OF lfsr IS
    SIGNAL reg : STD_LOGIC_VECTOR(N_BITS - 1 DOWNTO 0) := (OTHERS =&gt; '1');
    SIGNAL fb_bit : STD_LOGIC := '0';
BEGIN
    -- valid range
    ASSERT (N_BITS &gt;= 4 AND N_BITS &lt;= 16)
    REPORT &quot;LFSR: N_BITS must be between 4 and 16&quot;
        SEVERITY FAILURE;

    feedback_proc : PROCESS (reg)
    BEGIN
        CASE N_BITS IS
                -- n = 4:  x^4 + x^3 + 1 
            WHEN 4 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(2);
                -- n = 5:  x^5 + x^3 + 1
            WHEN 5 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(2);
                -- n = 6:  x^6 + x^5 + 1
            WHEN 6 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4);
                -- n = 7:  x^7 + x^6 + 1 
            WHEN 7 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5);
                -- n = 8:  x^8 + x^6 + x^5 + x^4 + 1
            WHEN 8 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5) XOR reg(4) XOR reg(3);
                -- n = 9:  x^9 + x^5 + 1
            WHEN 9 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4);
                -- n = 10: x^10 + x^7 + 1 
            WHEN 10 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(6);
                -- n = 11: x^11 + x^9 + 1
            WHEN 11 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(8);
                -- n = 12: x^12 + x^6 + x^4 + x + 1
            WHEN 12 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(5) XOR reg(3) XOR reg(0);
                -- n = 13: x^13 + x^4 + x^3 + x + 1 
            WHEN 13 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(3) XOR reg(2) XOR reg(0);
                -- n = 14: x^14 + x^5 + x^3 + x + 1 
            WHEN 14 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(4) XOR reg(2) XOR reg(0);
                -- n = 15: x^15 + x^14 + 1 
            WHEN 15 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(13);
                -- n = 16: x^16 + x^15 + x^13 + x^4 + 1
            WHEN 16 =&gt;
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(14) XOR reg(12) XOR reg(3);
            WHEN OTHERS =&gt;
                -- fallback: simple tap (not maximal-length)
                fb_bit &lt;= reg(N_BITS - 1) XOR reg(N_BITS - 2);
        END CASE;
    END PROCESS;

    ----------------------------------------------------------------------------
    -- Shift register
    ----------------------------------------------------------------------------
    PROCESS (CLK, RST_N)
    BEGIN
        IF RST_N = '0' THEN
            reg &lt;= SEED; -- async load on reset (active low)
        ELSIF rising_edge(CLK) THEN
            IF CE = '1' THEN
                IF LOAD = '1' THEN
                    reg &lt;= SEED; -- synchronous load
                ELSE
                    -- shift left (MSB at N_BITS-1), new bit becomes LSB
                    reg &lt;= reg(N_BITS - 2 DOWNTO 0) &amp; fb_bit;
                END IF;
            END IF;
        END IF;
    END PROCESS;

    Q &lt;= reg;
    FB &lt;= fb_bit;

END ARCHITECTURE;
</code></pre>
<p><img alt="" src="lfsr_waveform.jpg" /></p>
<p><strong>Figure:</strong> Example of waveforms of an 4-bit LFSR measured by a digital oscilloscope </p>
<p><strong>Questions</strong></p>
<ul>
<li>What happens if the initial value is set to all zeros?</li>
<li>How is the length (<code>N_BITS</code>) of the LFSR related to the period of the pulse signal?</li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="lab-4-on-chip-ram-testing"><strong>Lab 4: On-chip RAM Testing</strong><a class="headerlink" href="#lab-4-on-chip-ram-testing" title="Permanent link">#</a></h2>
<h3 id="objective_3"><strong>Objective</strong><a class="headerlink" href="#objective_3" title="Permanent link">#</a></h3>
<ul>
<li>Learn how to use on-chip RAM of the MAX10 FPGA chip.</li>
</ul>
<h3 id="lab-procedure_2"><strong>Lab Procedure</strong><a class="headerlink" href="#lab-procedure_2" title="Permanent link">#</a></h3>
<ol>
<li>Write VHDL code that implements a simple <strong>on-chip RAM tester</strong>.</li>
<li>The function of the RAM tester is as follows:<ul>
<li>It utilizes the provided VHDL model of a <strong>single-port synchronous RAM</strong>,
  which the Quartus software can infer to implement using the FPGA’s on-chip RAM resources.</li>
<li>The RAM has <code>N</code> data bits and <code>M</code> address bits, and should infer <strong>FPGA block RAM</strong>
  when the size of the memory (<script type="math/tex">2^M \times N</script>) is large enough to fit into
  the FPGA’s <strong>dedicated memory blocks</strong> rather than being mapped to <strong>distributed RAM logic</strong>.</li>
<li>An LFSR is used to generate test patterns for the RAM.</li>
<li>An FSM controls the RAM write and read operations for testing purposes.</li>
<li>On reset, the LFSR is seeded with an initial value, and the FSM waits for a <code>START</code> pulse.</li>
<li>When <code>START</code> is asserted by pressing the button, the FSM writes to all RAM addresses one by one, starting from address zero, with data generated by the LFSR.</li>
<li>After writing completes, the FSM reloads the same LFSR with the same seed,
  then reads back the RAM contents in the same address sequence.</li>
<li>Each read value is compared with the expected value from the LFSR for every memory address.</li>
<li>Any mismatch sets a error flag and the <code>LED_ERROR</code> output is high, otherwise it is low.</li>
<li>When the RAM test process is complete, the <code>LED_DONE</code> output is high, otherwise it is low.</li>
</ul>
</li>
</ol>
<p><strong>VHDL entity for the RAM tester</strong></p>
<pre><code class="language-VHDL">ENTITY ram_tester IS
    GENERIC (
        DATA_WIDTH : INTEGER := 8;
        ADDR_WIDTH : INTEGER := 16
    );
    PORT (
        RST_N     : IN STD_LOGIC; -- active-low reset
        CLK       : IN STD_LOGIC; -- system clock
        START     : IN STD_LOGIC; -- start pulse
        SW        : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0); -- SEED
        LED_DONE  : OUT STD_LOGIC;
        LED_ERROR : OUT STD_LOGIC
    );
END ENTITY ram_tester;
</code></pre>
<p><strong>VHDL code for a single-port synchronous RAM</strong></p>
<pre><code class="language-VHDL">-- single-port synchronous RAM
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY RAM_SP IS
    GENERIC (
        DATA_WIDTH : INTEGER := 8;
        ADDR_WIDTH : INTEGER := 10
    );
    PORT (
        CLK  : IN  STD_LOGIC; -- system clock
        WE   : IN  STD_LOGIC; -- write enable
        ADDR : IN  UNSIGNED(ADDR_WIDTH - 1 DOWNTO 0);
        DIN  : IN  STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);
        DOUT : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0)
    );
END ENTITY RAM_SP;

ARCHITECTURE rtl OF RAM_SP IS
    TYPE ram_t IS ARRAY (0 TO 2**ADDR_WIDTH - 1) 
         OF STD_LOGIC_VECTOR(DATA_WIDTH - 1 DOWNTO 0);

    FUNCTION init_ram
        RETURN ram_t IS
        VARIABLE tmp : ram_t := (OTHERS =&gt; (OTHERS =&gt; '0'));
    BEGIN
        FOR addr_pos IN 0 TO 2**ADDR_WIDTH - 1 LOOP
            -- Initialize each address with the address itself
            tmp(addr_pos) := STD_LOGIC_VECTOR(to_unsigned(addr_pos, DATA_WIDTH));
        END LOOP;
        RETURN tmp;
    END init_ram;

    --signal ram : ram_t := init_ram; -- use this for simulation only
    SIGNAL ram : ram_t;

    SIGNAL addr_reg : NATURAL RANGE 0 TO 2**ADDR_WIDTH - 1 := 0;

BEGIN
    PROCESS (CLK)
    BEGIN
        IF rising_edge(CLK) THEN
            IF WE = '1' THEN
                ram(to_integer(ADDR)) &lt;= DIN; -- synchronous write operation
            END IF;
            addr_reg &lt;= to_integer(ADDR);
        END IF;
    END PROCESS;
    DOUT &lt;= ram(addr_reg); -- synchronous read operation

END ARCHITECTURE;
</code></pre>
<p><img alt="" src="tb_ram_tester_sim.jpg" /></p>
<p><strong>Figure:</strong> Example of simulation waveforms (using GHDL and GTKwave form VHDL simulation)</p>
<p><strong>Questions</strong></p>
<ul>
<li>For a data width of 8 bits, what is the maximum memory depth that can be used and still fit on the target FPGA?</li>
<li>For the FPGA device on the board used in this lab session, what is the maximum size of a single block RAM, and how many such blocks are available?</li>
<li>How does the width of the data bus affect the number of block RAMs required to implement a given memory?</li>
<li>How can it be checked whether memory inference in VHDL will use block RAM rather than distributed logic?</li>
</ul>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2025-09-03 | Last Updated: 2025-09-04</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
