<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="http://iot-kmutnb.github.com/blogs/mbedos/mbed-stm32-part-2/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>ARM Mbed OS for STM32: Code Examples (Part 2) - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/julia.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-966FQ6RN6W');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#arm-mbed-os-for-stm32-code-examples-part-2" class="nav-link">ARM Mbed OS for STM32: Code Examples (Part 2)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#nucleo-f446re" class="nav-link">&#9655; ตำแหน่งของขาและคอนเนกเตอร์บนบอร์ด NUCLEO-F446RE</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm-led-blink" class="nav-link">&#9655; การสร้างสัญญาณ PWM สำหรับ LED Blink</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm-led-dimming" class="nav-link">&#9655; การสร้างสัญญาณ PWM สำหรับ LED Dimming</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#dac-stm32f4" class="nav-link">&#9655; การสร้างสัญญาณเอาต์พุตแอนะล็อกด้วย DAC ภายใน STM32F4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#adc-stm32f4" class="nav-link">&#9655; การอ่านค่าจากวงจร ADC ภายใน STM32F4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#dac-adc-loopback" class="nav-link">&#9655; การทดลอง DAC / ADC Loopback</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#led" class="nav-link">&#9655; การอ่านค่าจากวงจรตัวต้านทานปรับค่าได้และปรับความสว่างของ LED</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm-rgb" class="nav-link">&#9655; การสัญญาณ PWM เพื่อปรับสีของโมดูล RGB</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm-adc" class="nav-link">&#9655; การอ่านค่าสัญญาณ PWM ด้วย ADC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm" class="nav-link">&#9655; การวัดความถี่ของสัญญาณ PWM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm_1" class="nav-link">&#9655; การวัดความกว้างพัลส์ของสัญญาณ PWM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="arm-mbed-os-for-stm32-code-examples-part-2">ARM Mbed OS for STM32: Code Examples (Part 2)<a class="headerlink" href="#arm-mbed-os-for-stm32-code-examples-part-2" title="Permanent link">#</a></h1>
<p>เนื้อหาในส่วนนี้สาธิตการเขียนโค้ดโดยใช้ <strong>Mbed OS</strong> สำหรับบอร์ดไมโครคอนโทรลเลอร์ 
เช่น บอร์ด <strong>STM32 NUCLEO</strong> เป็นต้น โดยนำเสนอเป็น <strong>ตอนที่ 2</strong>
ต่อจาก <a href="../mbed-stm32-part-1/"><strong>ตอนที่ 1</strong></a></p>
<p><strong>Keywords</strong>: <em>Mbed OS</em>, <em>STM32 Nucleo</em>, <em>Mbed-enabled Platforms</em>, <em>RTOS Programming</em></p>
<hr />
<h2 id="nucleo-f446re">&#9655; <strong>ตำแหน่งของขาและคอนเนกเตอร์บนบอร์ด NUCLEO-F446RE</strong><a class="headerlink" href="#nucleo-f446re" title="Permanent link">#</a></h2>
<p>ในการทดลองการทำงานของโค้ดตัวอย่าง อาจจำเป็นต้องมีการต่อวงจรภายนอก
เพื่อเชื่อมต่อกับบอร์ดไมโครคอนโทรลเลอร์
ดังนั้นแผนผังแสดงตำแหน่งของขาบนบอร์ด หรือ <strong>PinOut</strong> / <strong>PinMap</strong> จึงเป็นสิ่งสำคัญ
รูปต่อไปนี้เป็นตัวอย่างของแผนผังสำหรับขาของบอร์ด <strong>NUCLEO-F446RE</strong></p>
<p><img alt="Nucleo F446RE Left Connector" src="../images/nucleo_f446re_morpho_left_side.png" /></p>
<p>รูปภาพ: แสดงตำแหน่งขาต่าง ๆ ของคอนเนกเตอร์ด้านซ้าย <strong>CN7</strong> บนบอร์ด  <strong>NUCLEO-F446RE</strong>
(Source: ARM Mbed)</p>
<p><img alt="Nucleo F446RE Right Connector" src="../images/nucleo_f446re_arduino_right.png" /></p>
<p>รูปภาพ: แสดงตำแหน่งขาต่าง ๆ ของคอนเนกเตอร์ด้านขวาบนบอร์ด  <strong>NUCLEO-F446RE</strong>
(Source: ARM Mbed)</p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm-led-blink">&#9655; <strong>การสร้างสัญญาณ PWM สำหรับ LED Blink</strong><a class="headerlink" href="#pwm-led-blink" title="Permanent link">#</a></h2>
<p>โดยทั่วไปแล้ว ไมโครคอนโทรลเลอร์ เช่น <strong>STM32</strong> มีวงจรภายในที่สามารถสร้างสัญญาณแบบ
<strong>PWM</strong> (<em>Pulse Width Modulation</em>)
และมีหลายขา <strong>GPIO</strong> ที่สามารถใช้เป็น  <strong>PWM Output</strong> ได้ แต่ไม่ใช่ทุกขา 
(ดังนั้นต้องตรวจสอบว่า ขาใดของบอร์ดที่ได้เลือกใช้งาน สามารถทำงานเป็น <strong>PWM Pins</strong> ได้บ้าง)</p>
<p>สัญญาณ <strong>PWM</strong> เป็นสัญญาณที่มีความถี่คงที่ แต่สามารถปรับช่วงกว้างของพัลส์ที่เป็น <strong>High</strong> ได้ 
จากความกว้างเป็น 0 ไปจนถึงเต็มหนึ่งคาบ หรือเรียกว่ามีค่า <strong>Duty Cycle</strong> ตั้งแต่ <strong>0%</strong> ถึง <strong>100%</strong> 
ไมโครคอนโทรลเลอร์ที่ไม่มีวงจร <strong>DAC</strong> ก็จะใช้วิธีการสร้างสัญญาณ <strong>PWM</strong> 
แทนการสร้างสัญญาณแรงดันไฟฟ้าแบบแอนะล็อก</p>
<p>ตัวอย่างนี้สาธิตการสร้างสัญญาณ <strong>PWM</strong> โดยการสร้างอ็อบเจกต์จากคลาสชื่อ 
<a href="https://os.mbed.com/docs/mbed-os/latest/apis/pwmout.html"><strong><code>PwmOut</code></strong></a> 
และใช้กับขาเอาต์พุตที่ตรงกับ <strong>onboard LED</strong> ตัวอย่างคำสั่งที่เกี่ยวข้อง ได้แก่</p>
<ul>
<li><code>void write( float value )</code> เขียนค่าเลขทศนิยมในข่วง <code>0.0f</code> (0%) ถึง <code>1.0f</code> (100%) สำหรับค่า <strong>Duty Cycle</strong></li>
<li><code>void period( float seconds)</code> เขียนค่าเลขทศนิยมสำหรับคาบของสัญญาณ (<strong>Period</strong>) หน่วยเป็นวินาที</li>
<li><code>void period_ms( int ms )</code> เขียนค่าเลขจำนวนเต็มสำหรับคาบของสัญญาณ หน่วยเป็นมิลลิวินาที</li>
<li><code>void period_us( int us )</code> เขียนค่าเลขจำนวนเต็มสำหรับคาบของสัญญาณ หน่วยเป็นไมโครวินาที</li>
<li><code>void pulsewidth( float seconds )</code> เขียนค่าเลขทศนิยมสำหรับค่าความกว้างของพัลส์
หน่วยเป็นวินาที</li>
<li><code>void pulsewidth_ms( int ms )</code> เขียนค่าจำนวนเต็มสำหรับค่าความกว้างของพัลส์
หน่วยเป็นมิลลิวินาที</li>
<li><code>void pulsewidth_us( int us )</code> เขียนค่าจำนวนเต็มสำหรับค่าความกว้างของพัลส์
หน่วยเป็นไมโครวินาที</li>
<li><code>void suspend()</code> และ <code>void resume()</code>สำหรับหยุดการสร้างสัญญาณ <strong>PWM</strong> ชั่วคราว
และบันทึกสถานะการทำงานเดิมไว้ หรือเปิดการสร้างสัญญาณใหม่อีกครั้งตามสถานะเดิม ตามลำดับ</li>
</ul>
<p>สัญญาณเอาต์พุตมีคาบเวลาเท่ากับ 1000 มิลลิวินาที หรือ ความถี่ <strong>1 Hz</strong> โดยทำคำสั่ง
<code>led.period_ms(...)</code> และนำไปใช้ควบคุมสถานะของ <strong>LED</strong> ภายนอก 
ค่า <strong>Duty Cycle</strong> มีค่าเท่ากับ 50% โดยใช้คำสั่ง 
<code>led.pulsewidth_ms(...)</code> เพื่อกำหนดความกว้างของพัลส์ช่วง <strong>High</strong>
ให้เท่ากับครึ่งหนึ่งของคาบ ดังนั้น <strong>LED</strong> จะกระพริบได้หนึ่งครั้งต่อวินาที</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;
#include &quot;rtos.h&quot;

#define PERIOD_MS  (1000)

PwmOut  led( LED1 );

int main(){
  led.period_ms( PERIOD_MS ); // set PWM period (in msec)
  led.pulsewidth_ms( PERIOD_MS/2 ); // set PWM pulse width (in msec)
  printf( &quot;Main thread waits forever...\r\n&quot; );
  while(1) {
    osDelay( osWaitForever );
  }
}
</code></pre>
<p><strong>ข้อสังเกต:</strong> ถ้ามีการคำสั่ง <code>suspend()</code> สำหรับอ็อบเจกต์ของ <code>PwmOut</code> 
แล้วมีการทำคำสั่งเพื่อเปลี่ยนแปลงค่าความถี่และความกว้างของพัลส์ของสัญญาณดังกล่าว ก็จะไม่มีผล 
ถ้าทำคำสั่ง <code>resume()</code> เพื่อการสร้างสัญญาณอีกครั้ง ลองดูตัวอย่างโค้ดต่อไปนี้</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

PwmOut pwm( LED1 ); // use PWM out on LED1 pin

int main() {
   // read the PWM pulsewidth and period before suspend
   printf( &quot;# 1) pulsewidth=%d us, period=%d us\r\n&quot;,
          pwm.read_pulsewitdth_us(),
          pwm.read_period_us() );

   pwm.suspend(); // suspend the PWM output and keep it state

   // update PWM period (=5msec) and duty cycle (=0.5 or 50%)
   pwm.period_ms( 5 );
   pwm = 0.5;

   pwm.resume(); // resume the PWM output

   // read the PWM pulse width and period after resume
   printf( &quot;# 2) pulsewidth=%d us, period=%d us\r\n&quot;,
          pwm.read_pulsewitdth_us(),
          pwm.read_period_us() );

   while (1) {
     ThisThread::sleep_for( 100ms );
   }
  return 0;
}
</code></pre>
<p>ตัวอย่างข้อความเอาต์พุต</p>
<pre><code class="language-text"># 1) pulsewidth=0 us, period=20000 us
# 2) pulsewidth=0 us, period=20000 us
</code></pre>
<p>ซึ่งจะเห็นได้ว่า ความกว้างของพัลส์และคาบของสัญญาณ <strong>PWM</strong> ไม่ใช่ค่าที่ต้องการ 
(คาบควรจะเป็น 5 msec และค่า <strong>Duty Cycle</strong> เป็น 0.5% ) หลังจากที่ได้ทำคำสั่ง <code>resume()</code> 
และยังเป็นค่าเดิมก่อนทำคำสั่ง <code>suspend()</code> </p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm-led-dimming">&#9655; <strong>การสร้างสัญญาณ PWM สำหรับ LED Dimming</strong><a class="headerlink" href="#pwm-led-dimming" title="Permanent link">#</a></h2>
<p>ตัวอย่างนี้สาธิตการสร้างสัญญาณ <strong>PWM</strong> ด้วยใช้คำสั่งของ
<a href="https://os.mbed.com/docs/mbed-os/latest/apis/pwmout.html"><strong><code>PWMOut</code></strong></a> 
เพื่อใช้ในการปรับความสว่างของวงจร <strong>LED</strong> โดยการเปลี่ยนค่า <strong>Duty Cycle</strong> 
หรือ ความกว้างของพัลส์ (<strong>Pulse Width</strong>) ให้ค่อย ๆ เพิ่มขึ้นและลดลง เช่น ตามรูปแบบของคลื่นแบบฟันเลื่อย
(<strong>Sawtooth Wave</strong>)</p>
<p>ในตัวอย่างนี้ได้เลือกใช้ชา <code>PB_0</code> / <code>A3</code> และต่อกับโมดูล <strong>LED</strong> ภายนอก หรือถ้าต้องการใช้ 
<strong>onboard LED</strong> ก็ให้เปลี่ยนเป็นขา <code>LED1</code> แทน</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

#define DELAY_MS  (20ms)

// the number of steps for changing LED brightness
const int N = 32;
const uint32_t PWM_PERIOD_US = 2000;

PwmOut pwm( PB_0 ); // choose any PWM-capable GPIO pin

void update_pwm() {
   static uint32_t index = 0;
   uint32_t level = (index &gt;= N) ? (2*N - index) : index;
   uint32_t pulsewidth = (PWM_PERIOD_US * level) / N;

   // send the current value of the pulse width to serial
   printf( &quot;%lu\n&quot;, pulsewidth );
   // update the PWM output
   pwm.pulsewidth_us( pulsewidth );
   ThisThread::sleep_for( DELAY_MS );
   index = (index+1) % (2*N);
}

int main() {
   pwm = 0.0f; // turn off LED, by setting pulsewidth to 0
   pwm.period_us( PWM_PERIOD_US ); // set PWM period

   printf( &quot;#Mbed PWMOut - LED Dimming Demo\n&quot; );
   while(1) {
      update_pwm();
   }
   return 0;
}
</code></pre>
<p>&nbsp;</p>
<p><img alt="Arduino Plotter Sawtooth Wave" src="../images/mbed_stm32_pwm_sawtooth_wave.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟใน <strong>Serial Plotter</strong> จากลำดับข้อมูลที่ได้รับมาจากบอร์ด</p>
<p>&nbsp;</p>
<p><strong>คำถาม</strong>: ถ้าแก้ไขโค้ดสำหรับฟังก์ชัน <code>update_pwm()</code> ดังต่อไปนี้ และนำไปทดลองกับฮาร์ดแวร์จริง
จะให้ผลแตกต่างไปอย่างไร ?</p>
<pre><code class="language-c++">void update_pwm() {
   static uint32_t index = 0;
   uint32_t level = (index &gt;= N) ? (2*N - index) : index;
   // convert level to pulse width
   uint32_t pulsewidth = (PWM_PERIOD_US * level) / N;
   // scale up the pulsewidth value
   pulsewidth = (pulsewidth * 8) / 5; 
   // limit the pulsewidth value (must not be greather than the period)
   pulsewidth = (pulsewidth &gt; PWM_PERIOD_US) ? PWM_PERIOD_US : pulsewidth;
   // send the current value of the pulse width to serial
   printf( &quot;%lu\n&quot;, pulsewidth );
   // update the PWM output
   pwm.pulsewidth_us( pulsewidth );
   ThisThread::sleep_for( DELAY_MS );
   index = (index+1) % (2*N);
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="dac-stm32f4">&#9655; <strong>การสร้างสัญญาณเอาต์พุตแอนะล็อกด้วย DAC ภายใน STM32F4</strong><a class="headerlink" href="#dac-stm32f4" title="Permanent link">#</a></h2>
<p>บอร์ด <strong>NUCLEO</strong> อย่างเช่น <a href="https://os.mbed.com/platforms/ST-Nucleo-F446RE/"><strong>NUCLEO-F446RE</strong></a>
มีวงจร <strong>DAC</strong> อยู่ภายใน และมีขาที่ใช้เป็นเอาต์พุตสำหรับสัญญาณแอนะล็อกได้ 2 ขา คือ <code>PA_4</code> และ <code>PA_5</code> 
(ขานี้ตรงกับ <strong>onboard LED</strong>)
สัญญาณเอาต์พุตที่ได้จะอยู่ในช่วง <strong>0.0V</strong> ถึง <strong>3.3V</strong> (Vref) </p>
<p>ตัวอย่างนี้สาธิตการสร้างสัญญาณเอาต์พุตแบบแอนะล็อกด้วยคำสั่ง 
<a href="https://os.mbed.com/docs/mbed-os/latest/apis/analogout.html"><strong><code>AnalogOut</code></strong></a>
และมีคำสั่งที่เกี่ยวข้องสำหรับการกำหนดค่าเอาต์พุต 3 รูปแบบ</p>
<ul>
<li><code>void write(float value)</code>
 เขียนค่าเป็น <code>float</code> ที่อยู่ในช่วง <code>0.0f</code> (0V) ถึง <code>1.0f</code> (3.3V)</li>
<li><code>void write_u16(unsigned short value)</code> 
  เขียนค่าเป็นเลขจำนวนเต็มขนาด 16 บิต ในช่วง <strong>0</strong> (0V) ถึง <strong>65535</strong> (3.3V)</li>
<li><code>AnalogOut&amp; operator= (float value)</code> ให้ผลเหมือนคำสั่ง  <code>write(...)</code></li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

#define PI 3.14159265358

// the number of steps for changing LED brightness
const int N = 32; 

AnalogOut aout( PA_4 ); // use PA_4 or PA_5 pin

int main() {
   aout = 0.0f;
   printf( &quot;#Mbed AnalogOut/DAC Demo\n&quot; );
   uint16_t level;
   uint32_t index = 0;
   while(1) {
     // Since we choose the argument for the sin()
     // function between 0 and PI, the value of the
     // function will between 0 and 1.0
     level = (uint16_t)( 65535 * sin(index*PI/N) );
     printf( &quot;%u\n&quot;, level );
     // update the DAC output
     aout.write_u16( level );
     ThisThread::sleep_for( 100ms );
     index = (index+1) % N;
   }
   return 0;
}
</code></pre>
<p>ถ้านำโค้ดนี้ไปทดลอง จะเห็นได้ว่า <strong>LED</strong> จะค่อย ๆ สว่างขึ้นแล้วดับลง </p>
<p><img alt="Arduino Plotter Half-Sine" src="../images/mbed_stm32_dac_led_dimming.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟใน <strong>Serial Plotter</strong> จากลำดับข้อมูลที่ได้รับมาจากบอร์ด</p>
<p><img alt="Nucleo F446RE and LED module" src="../images/mbed_nucleo_f446re_led_dimming.jpg" /></p>
<p>รูปภาพ: การต่อวงจรทดลองโดยใช้โมดูล <strong>LED</strong> ที่ขา <code>PA_4</code> ของบอร์ด <strong>NUCLEO-F446RE</strong></p>
<p>&nbsp;</p>
<p>ข้อสังเกต: ถ้าเลือกใช้งานขาไม่ถูกต้อง เมื่อโปรแกรมทำงาน จะเกิดความผิดพลาดขณะทำงาน 
(<strong>Runtime Error</strong>) และมีข้อความส่งออกมาทาง <strong>Serial</strong> ตามตัวอย่างดังนี้</p>
<pre><code>++ MbedOS Error Info ++
Error Status: 0x80010130 Code: 304 Module: 1
Error Message: pinmap not found for peripheral
Location: 0x800208F
Error Value: 0x21
...
</code></pre>
<hr />
<h2 id="adc-stm32f4">&#9655; <strong>การอ่านค่าจากวงจร ADC ภายใน STM32F4</strong><a class="headerlink" href="#adc-stm32f4" title="Permanent link">#</a></h2>
<p>ตัวอย่างนี้สาธิตการใช้คลาส 
<a href="https://os.mbed.com/docs/mbed-os/latest/apis/i-o-apis.html"><code>AnalogIn</code></a> 
เพื่ออ่านค่าจากวงจร <strong>ADC</strong> ที่มีอยู่ภายในชิปไมโครคอนโทรลเลอร์  <strong>STM32</strong> 
(เช่น ชิป <strong>STM32F4 / L4</strong>) </p>
<p>ค่าที่จะอ่านจาก <strong>ADC</strong> แบ่งได้เป็นสองกรณีคือ ค่าที่ได้จากเซนเซอร์อุณหภูมิภายในชิป
(<strong>Internal Temperature Sensor</strong>) มีค่าอยู่ในช่วง
<strong>-40 ~ +125 ℃</strong> (ความแม่นยำ <strong>±1.5 ℃</strong>) และค่าสำหรับแรงดันอ้างอิง
(<strong>Internal Reference Voltage</strong>) ซึ่งมีค่าประมาณ <strong>1.2V</strong>
แล้วนำมาแสดงเป็นข้อความออกทาง <strong>Serial / UART</strong> ด้วยคำสั่ง <code>printf(...)</code></p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

DigitalOut led( LED1 ); // onboard LED

// target board: NUCLEO F4464E
// use MBED_CONF_TARGET_DEFAULT_ADC_VREF for ADC voltage reference
AnalogIn adc_temp( ADC_TEMP );
AnalogIn adc_vref( ADC_VREF );

#define TEMP_V25       (0.76f)
#define TEMP_VSENSE    (3.3f/65536)
#define TEMP_AVG_SLOPE (0.0025f)

int main() {
  uint32_t temp, vref;
  float voltage;
  float temp_degc;
  printf( &quot;Mbed: Reading internal ADC...\n&quot; );

  while(1) {
    // read internal chip temperature
    temp = adc_temp.read_u16();
    printf( &quot;ADC Temp. = %lu\r\n&quot;, temp );

    voltage = TEMP_VSENSE*temp;
    printf(&quot;ADC Temp. = %.3f V\r\n&quot;, voltage );

    temp_degc = (voltage - TEMP_V25) / TEMP_AVG_SLOPE + 25;
    printf (&quot;ADC Temp. = %.1f deg.C\r\n&quot;, temp_degc );

    // read internal voltage reference
    vref = adc_vref.read_u16();
    printf( &quot;ADC VRef. = %lu\r\n&quot;, vref );

    voltage = (3.3f*vref)/65536;
    printf( &quot;ADC VRef. = %.3f V\r\n&quot;, voltage );

    led = !led; // toggle LED
    ThisThread::sleep_for( 1000ms );
  }
  return 0;
}
</code></pre>
<p>&nbsp;</p>
<p>ให้แก้ไขไฟล์ <code>mbed_app.json</code> ในโปรเจกต์ของ <strong>Mbed</strong> 
เพื่อให้สามารถใช้ข้อมูลแบบ <code>float</code> กับคำสั่ง <code>printf()</code> ได้
และเลือกใช้ไลบรารี <code>minimal-printf</code> แทน <code>std</code> สำหรับ <code>target.printf_lib</code>
(การเลือกใช้ไลบรารีสำหรับ <code>printf()</code> ที่แตกต่างกัน จะทำให้ขนาดของโปรแกรมที่ได้จากการคอมไพล์
มีขนาดแตกต่างกัน)</p>
<pre><code class="language-json">{
    &quot;target_overrides&quot;: {
        &quot;*&quot;: {
            &quot;platform.stdio-baud-rate&quot;: 115200,
            &quot;target.printf_lib&quot;: &quot;minimal-printf&quot;,
            &quot;platform.minimal-printf-enable-floating-point&quot;: true,
            &quot;platform.minimal-printf-set-floating-point-max-decimals&quot;: 6,
            &quot;platform.minimal-printf-enable-64-bit&quot;: false
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<p>ตัวอย่างข้อความเอาต์พุตมีดังนี้</p>
<p><img alt="Mbed OS STM32 Outputs" src="../images/mbed_stm32_adc_internal_reading.png" /></p>
<p>รูปภาพ: ข้อความเอาต์พุตจากการอ่านค่า <strong>ADC</strong> ของ <strong>STM32F4</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="dac-adc-loopback">&#9655; <strong>การทดลอง DAC / ADC Loopback</strong><a class="headerlink" href="#dac-adc-loopback" title="Permanent link">#</a></h2>
<p>ตัวอย่างนี้สาธิตการสร้างสัญญาณเอาต์พุตแบบแอนะล็อกด้วย <strong>DAC</strong> 
และอ่านค่าสัญญาณดังกล่าวด้วย <strong>ADC</strong> ของ <strong>STM32F4</strong> ในลักษณะ <strong>Loopback</strong>
แล้วนำค่าที่ได้มาแสดงรูปกราฟสัญญาณโดยส่งค่าไปยังคอมพิวเตอร์ทาง <strong>Serial</strong></p>
<p>ตามโค้ดตัวอย่างนี้ ได้เลือกใช้ขา <code>PA_1</code> / <code>A1</code> สำหรับขา <strong>ADC</strong> และขา <code>PA_4</code> / <code>A2</code>
ค่าสำหรับเอาต์พุตจะเพิ่มขึ้นจาก 0 ถึง 1023 (หรือมีความละเอียดเท่ากับ 10 บิต) แล้ววนซ้ำไปเรื่อย ๆ 
เว้นระยะห่างประมาณ 20 msec </p>
<p>เมื่อได้กำหนดค่าให้ <strong>DAC</strong> เป็นเอาต์พุตแล้ว ก็จะรอเวลา เช่น  5 ไมโครวินาที แล้วจึงอ่านค่าอินพุตจาก <strong>ADC</strong>
ตามจำนวน <code>SAMPLES</code> ที่กำหนดไว้ นำค่าที่อ่านมาบวกรวมกันแล้วจึงหาค่าเฉลี่ย 
ค่าเอาต์พุตและอินพุตในแต่ละรอบ จะถูกส่งเป็นข้อความผ่านทาง <strong>Serial</strong></p>
<pre><code>#include &quot;mbed.h&quot;

AnalogIn  ain( A1 );  // analog input
AnalogOut aout( A2 ); // analog output

#define RESOLUTION_BITS  (10)
#define SAMPLES          (4)

const int N = (1 &lt;&lt; RESOLUTION_BITS);

int main() {
  uint32_t write_value, read_value;
  while(1) {
    for ( int i=0; i &lt; N; i++ ) {
       write_value = (i &lt;&lt; (16-RESOLUTION_BITS));
       // update DAC output
       aout.write_u16( (uint16_t) write_value );
       wait_us(5);
       read_value = 0;
       // read the ADC value
       for ( int j=0; j &lt; SAMPLES; j++ ) {
         // sum up the ADC reading value
         read_value += ain.read_u16();
       }
       // use the average value
       read_value = read_value / SAMPLES;
       printf( &quot;aout:%lu,ain:%lu\r\n&quot;,
               write_value, read_value );
       ThisThread::sleep_for( 20ms );
    }
  }
  return 0;
}
</code></pre>
<p><img alt="Serial Plotter ADC / DAC values" src="../images/mbed_adc_dac_loopback.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟใน <strong>Arduino Serial Plotter</strong> 
สำหรับลำดับค่าตัวเลขของ <strong>ADC</strong> / <strong>DAC</strong> ที่ถูกส่งมาทาง <strong>Serial</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="led">&#9655; <strong>การอ่านค่าจากวงจรตัวต้านทานปรับค่าได้และปรับความสว่างของ LED</strong><a class="headerlink" href="#led" title="Permanent link">#</a></h2>
<p>ตัวอย่างนี้สาธิตการอ่านค่าแรงดันไฟฟ้าจากวงจรแบ่งแรงดัน (<strong>Potentiometer</strong>) 
โดยใช้ขาอินพุตของวงจร <strong>ADC</strong> ภายในชิป <strong>STM32F4</strong> 
และนำค่าที่ได้ซึ่งเป็นเลขจำนวนเต็ม 16 บิต ไปใช้กำหนดค่าสำหรับความกว้างของพัลส์สำหรับสัญญาณ <strong>PWM</strong> 
(มีความถี่ <strong>500Hz</strong> หรือ คาบเท่ากับ <strong>2000us</strong>)</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

const uint32_t PERIOD_US = 2000; // 2msec period

AnalogIn ain( A0 ); // use A0 pin for analog input
PwmOut   pwm( A1 ); // use A1 pin for PWM output

int main() {
  uint32_t ain_value;
  float    pwm_value;
  pwm = 0.0f;
  pwm.period_us( PERIOD_US );

  while(1) {
    // read ADC value and scale down to 12 bits
    ain_value = ain.read_u16() &gt;&gt; 4;
    // convert 12-bit value to PWM duty cycle: between 0.0f and 1.0f
    pwm_value = (1.0f*ain_value) / (1UL &lt;&lt; 12);
    // update PWM output
    pwm.write( pwm_value );
    // show current values
    printf( &quot;ain:%lu,pulsewidth:%lu\n&quot;,
            ain_value, (uint32_t)(pwm_value*PERIOD_US) );
    ThisThread::sleep_for( 20ms );
  }
  return 0;
}
</code></pre>
<p>&nbsp;</p>
<p><img alt="" src="../images/mbed_stm32_ain_pwm_plot.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟใน <strong>Arduino Serial Plotter</strong> 
สำหรับลำดับค่าตัวเลขของ <strong>ADC</strong> / <strong>PWM Output</strong> ที่ถูกส่งมาทาง <strong>Serial</strong>
ในขณะที่มีการเปลี่ยนแปลงค่าอินพุต (<code>ain</code>: 0..4095) และเอาต์พุต (<code>pulsewidth</code>: 0..1999)</p>
<p><img alt="" src="../images/mbed_stm32_linear_potentiometer_pwm_led.jpg" /></p>
<p>รูปภาพ: การต่อวงจรทดลองโดยใช้โมดูล <strong>Linear Potentiometer</strong> และโมดูล <strong>LED</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm-rgb">&#9655; <strong>การสัญญาณ PWM เพื่อปรับสีของโมดูล RGB</strong><a class="headerlink" href="#pwm-rgb" title="Permanent link">#</a></h2>
<p>ตัวอย่างโค้ดนี้สาธิตการอ่านค่าจากช่องสัญญาณแอนะล็อกอินพุตจำนวน 3 ช่อง
จากโมดูลตัวต้านทานปรับค่าได้แบบเชิงเส้น (<strong>Linear Potentiometer</strong>) 
นำมาต่อเข้าที่ขา {<code>A0</code>, <code>A1</code>, <code>A2</code>} ของบอร์ด <strong>STM32 NUCLEO</strong></p>
<p>ค่าอินพุตที่อ่านได้ ซึ่งเป็นเลขทศนิยมในช่วง <code>0.0f</code> ถึง <code>1.0f</code> จะถูกนำไปใช้สำหรับค่าเอาต์พุต
ของสัญญาณ <strong>PWM</strong> จำนวน 3 ช่องสัญญาณ โดยเลือกใช้ขา {<code>D9</code>,<code>D10</code>,<code>D11</code>}
ตามลำดับ และนำไปใช้เป็นสัญญาณควบคุมสำหรับโมดูล <strong>RGB</strong> เพื่อปรับสีของแสงที่ปรากฎ</p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

const uint32_t PERIOD_US = (2000);

AnalogIn pot_r( A0 ), pot_g( A1), pot_b( A2 );
PwmOut   pwm_r( D9 ), pwm_g( D10), pwm_b( D11 );

int main() {
  float r, g, b;
  // set the period of the three PWM signals
  pwm_r.period_us( PERIOD_US );
  pwm_g.period_us( PERIOD_US );
  pwm_b.period_us( PERIOD_US );
  while(1) {
     // read analog inputs and write PWM outputs (float values)
     pwm_r.write( r = pot_r.read() );
     pwm_g.write( g = pot_g.read() );
     pwm_b.write( b = pot_b.read() );
     // convert float values to 8-bit values for RGB
     printf( &quot;r:%u,g:%u,b:%u\n&quot;,
         (uint8_t)(r*255),
         (uint8_t)(g*255),
         (uint8_t)(b*255) );
     ThisThread::sleep_for( 100ms );
  }
  return 0;
}
</code></pre>
<p><img alt="" src="../images/mbed_stm32_3x_ain_pwm_output.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟสำหรับข้อมูลที่ได้รับมาซึ่งเป็นเลขจำนวนเต็ม 8 บิต สำหรับค่าสี <strong>RGB</strong> </p>
<p><img alt="" src="../images/mbed_stm32_rgb_led-1.jpg" /></p>
<p>รูปภาพ: การเชื่อมต่อระหว่างบอร์ด <strong>NUCLEO-F466RE</strong>
กับโมดูลตัวต้านทานปรับค่าได้และโมดูล <strong>RGB LED</strong> จำนวน 3 ชุด</p>
<p><img alt="" src="../images/mbed_stm32_rgb_led-2.jpg" /></p>
<p>รูปภาพ: การปรับสีของแสงจากโมดูล <strong>LED</strong> โดยเลื่อนตำแหน่งของโมดูลตัวต้านทานปรับค่าได้แบบเชิงเส้น</p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm-adc">&#9655; <strong>การอ่านค่าสัญญาณ PWM ด้วย ADC</strong><a class="headerlink" href="#pwm-adc" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการสร้างสัญญาณ <strong>PWM</strong> เป็นเอาต์พุตที่ขา <code>D10</code> / <code>PB_6</code> 
และมีความถี่ <strong>1000 Hz</strong> (คาบเท่ากับ <strong>1000 us</strong> หรือ <strong>1 ms</strong>) 
แล้วนำไปต่อกับวงจรตัวกรองความถี่ต่ำที่เรียกว่า <strong>Low-Pass Filter</strong> 
ประกอบด้วยตัวต้านทานและตัวเก็บประจุ เช่น <strong>4.7k&ohm;</strong> และ <strong>10uF</strong> เป็นต้น
จากนั้นจึงวัดค่าแรงดันไฟฟ้าที่ผ่านตัวกรองดังกล่าวโดยใช้ขาของ <strong>ADC</strong> เช่น ขา <code>A0</code> 
และนำไปแปลงเป็นข้อความส่งออกทาง <strong>Serial</strong></p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

using namespace std::chrono_literals;
const auto DELAY_MS = 10ms;

const uint32_t PERIOD_US = 1000; // PWM period in microseconds
const uint32_t VREF = 3300;      // Vref in mV

AnalogIn ain( A0 );  // analog input pin
PwmOut   pwm( D10 ); // PWM output pin

int main() {
   float pwm_value = 0.0f;
   float ain_value;
   bool  increasing = true;

   pwm.write( pwm_value );
   pwm.period_us( PERIOD_US );

   while (1) {
     // update PWM value
     if (increasing) { // increase the pulse width
       pwm_value += 0.01f;
       if ( pwm_value &gt; 1.0f ) {
         pwm_value = 1.0f;
         increasing = false;
       }
     }
     else { // decrease the pulse width
       pwm_value -= 0.01f;
       if ( pwm_value &lt; 0.0f ) {
         pwm_value = 0.0f;
         increasing = true;
       }
     }
     // write PWM output value
     pwm.write( pwm_value );
     wait_us( PERIOD_US );
     // read analog input
     ain_value = ain.read();
     // convert the float value of the analog input 
     // between 0.0 to 1.0 to the coresponding voltage 
     // between 0 and 3300mV
     printf( &quot;ain:%lu\n&quot;, (uint32_t)(ain_value*VREF) );
     ThisThread::sleep_for( DELAY_MS );
  }
  return 0;
}
</code></pre>
<p>&nbsp;</p>
<p><img alt="Low-Pass RC Filter" src="../images/low-pass_rc_filter.png" /></p>
<p>รูปภาพ: วงจร <strong>Low-Pass RC Filter</strong> ที่มีสัญญาณอินพุต (<strong>Vin</strong>) ของวงจรตัวกรองอยู่ด้านซ้าย
และสัญญาณเอาต์พุต (<strong>Vout</strong>) อยู่ด้านขวา  (Source: Wikipedia)</p>
<p>&nbsp;</p>
<p><img alt="Serial Output" src="../images/mbed_stm32_pwm_lowpass_filtered.png" /></p>
<p>รูปภาพ: แสดงรูปกราฟของข้อมูลที่ได้รับผ่านทาง <strong>Serial</strong>
ซึ่งเป็นตัวเลขจำนวนเต็มของแรงดันไฟฟ้า-อินพุตที่วัดได้ด้วย <strong>ADC</strong>
ในช่วง 0 ถึง 3300 mV</p>
<p><img alt="Low-pass RC filter circuit" src="../images/mbed_stm32_low_pass_rc_filter.jpg" /></p>
<p>รูปภาพ: การต่อวงจรทดลอง <strong>Low-Pass RC Filter</strong> บนเบรดบอร์ดร่วมกับบอร์ด <strong>NUCLEO-F466RE</strong>
ขา <code>D10</code> ซึ่งเป็นสัญญาณ <strong>PWM</strong> นำไปใช้เป็นสัญญาณ <strong>Vin</strong> ของวงจรตัวกรองและสัญญาณ <strong>Vout</strong> ต่อกับขา อินพุต-แอนะล็อก <code>A0</code> </p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm">&#9655; <strong>การวัดความถี่ของสัญญาณ PWM</strong><a class="headerlink" href="#pwm" title="Permanent link">#</a></h2>
<p>ในกรณีที่มีการสร้างสัญญาณ <strong>PWM</strong> เป็นเอาต์พุต และกำหนดให้ <strong>Duty Cycle</strong> เท่ากับ 50% 
ก็จะได้สัญญาณดิจิทัลแบบคลื่นสี่เหลี่ยม (<strong>Rectangular Wave</strong>) แล้วถ้านำสัญญาณเอาต์พุตนี้
ป้อนกลับไปเป็นสัญญาณอินพุตให้ไมโครคอนโทรลเลอร์ และอยากทราบว่า มีความถี่ตรงกับที่กำหนดไว้หรือไม่
เราจะวัดความถี่ของสัญญาณได้อย่างไรบ้าง ตัวอย่างโค้ดต่อไปนี้สาธิตวิธีการ </p>
<p>หลักการทำงานคือ ให้เปิดใช้งานขาอินเทอร์รัพท์ภายนอก แล้วสร้างฟังก์ชันเพื่อทำหน้าที่เป็น <strong>Callback Function</strong> 
คอยบันทึกเวลาเมื่อเกิดเหตุการณ์ขอบขาขึ้น (<strong>Rising Edges</strong>) จำนวน 2 ครั้ง ถัดกัน 
แล้วจึงหาผลต่างของเวลา ก็จะได้คาบของสัญญาณ ถ้าไม่มีการเปลี่ยนแปลงความถี่หรือคาบในช่วงดังกล่าว</p>
<p>โค้ดตัวอย่างนี้ จะสร้างสัญญาณพัลส์ที่มีความกว้างของคาบตามที่ระบุไว้ในอาร์เรย์ตามลำดับ อยู่ระหว่าง
<strong>50</strong> ถึง <strong>100000 us</strong> (ไมโครวินาที) หรือจะได้ความถี่เท่ากับ <strong>200kHz</strong> ถึง <strong>10Hz</strong>
และสำหรับการต่อวงจรทดลอง ให้นำลวดสายไฟมาต่อระหว่างขา <code>D2</code> กับ <code>D11</code> ของบอร์ด <strong>NUCLEO</strong></p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

InterruptIn pwm_in( D2  );  // PWM input pin
PwmOut      pwm_out( D11 ); // PWM output pin

#define  N  (10) // number of periods to be tested

const uint32_t PERIODS_US[] = {
   5,10,50,100,500,1000,
   5000,20000,50000,100000
};

volatile uint32_t ticker_ts[2];  // used to save timestamps
volatile uint32_t event_cnt = 0; // (rising-edge) event counter

void irq_callback() {
   uint32_t ts = us_ticker_read();
   ticker_ts[1] = ticker_ts[0];
   ticker_ts[0] = ts;
   event_cnt++;
}

void update_pwm_out(  uint32_t period_us ) {
   pwm_out.period_us( period_us );
   pwm_out.pulsewidth_us( period_us/2 ); // 50% duty cycle
}

int main() {
   uint32_t t_period;

   // disable IRQ on digital pin for PWM input
   pwm_in.disable_irq();
   // set callback function for the rising edge event
   pwm_in.rise( &amp;irq_callback );

   printf( &quot;Mbed Frequency Measurement Demo\n&quot; );

   while (1) {
     for ( uint32_t i=0; i &lt; N; i++ ) {
       // update PWM output (frequency and pulse width)
       update_pwm_out( PERIODS_US[i] );
       // clear event counter
       event_cnt = 0;
       // enable IRQ on digital pin for PWM input
       pwm_in.enable_irq();
       // wait until number of detected events &gt;= 2
       while ( event_cnt &lt; 2 ) { wait_us(1); }
       // disable IRQ on digital pin for PWM input
       pwm_in.disable_irq();
       // compute the time difference which is the PWM period 
       t_period = ticker_ts[0] - ticker_ts[1];
       // show output message
       printf( &quot;measured period [%6lu] us, freq. %.1f Hz\r\n&quot;,
               t_period, 1000000.0f/ t_period );
       ThisThread::sleep_for( 500ms );
     }
  }
  return 0;
}
</code></pre>
<p><img alt="PWM period and frequency measurement" src="../images/mbed_stm32_freq_pwm_measurement.png" /></p>
<p>รูปภาพ:  ข้อความเอาต์พุตแสดงผลการวัดคาบและความถี่ของสัญญาณ <strong>PWM</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="pwm_1">&#9655; <strong>การวัดความกว้างพัลส์ของสัญญาณ PWM</strong><a class="headerlink" href="#pwm_1" title="Permanent link">#</a></h2>
<p>จากตัวอย่างที่แล้ว ถ้าต้องการจะวัดความกว้างพัลส์ที่เกิดจากสัญญาณ <strong>PWM</strong> ก็มีหลักการทำงานคล้ายกันคือ
ต้องบันทึกจุดเวลาขอบขาขึ้นของสัญญาณ และจุดเวลาของขอบขาลงถัดไป แล้วนำมาหาผลต่างของเวลา
ก็จะได้ความกว้างของสัญญาณพัลส์ช่วงที่เป็น <strong>High</strong></p>
<pre><code class="language-c++">#include &quot;mbed.h&quot;

InterruptIn pwm_in( D2  );
PwmOut      pwm_out( D11 );

#define  N  (15)

const uint32_t PERIODS_US[] = {
   4,10,20,50,100,
   200,250,500,1000,5000,
   10000,20000,50000,100000,200000
};

volatile uint32_t ticker_ts[2] = {0};
volatile uint32_t event_cnt = 0;

// callback for rising-edge event
void irq_rise_callback() {
   ticker_ts[1] = us_ticker_read();
   event_cnt++;
}

// callback for falling-edge event
void irq_fall_callback() {
   ticker_ts[0] = us_ticker_read();
   if (event_cnt &gt; 0) {
     event_cnt++;
   }
}

void update_pwm_out( uint32_t period_us ) {
   pwm_out.period_us( period_us );
   pwm_out.pulsewidth_us( period_us&gt;&gt;1 ); // 50% duty cycle
}

int main() {
   uint32_t t_pw;

   pwm_in.disable_irq();
   pwm_in.rise( &amp;irq_rise_callback );
   pwm_in.fall( &amp;irq_fall_callback );

   printf( &quot;Mbed Pulsewidth Measurement Demo\n&quot; );
   printf( &quot;NUCLEO SystemCoreClock: %lu MHz\n&quot;,
            SystemCoreClock/1000000 );
   printf( &quot;pulsewidth: measured expected\n&quot; );

   while (1) {
     for ( uint32_t i=0; i &lt; N; i++ ) {
       // update PWM output (frequency and period)
       update_pwm_out( PERIODS_US[i] );
       // wait until the PWM input goes low.
       while (pwm_in.read() == 1) { wait_us(1); }
       // clear event counter
       event_cnt = 0;
       // enable interrupt for PWM input pin
       pwm_in.enable_irq();
       // wait until at least two events have been detected
       while ( event_cnt &lt; 2 ) { wait_us(1); }
       // disable interrupt for PWM input pin
       pwm_in.disable_irq();
       // compute the time difference which is the pulse width
       t_pw = ticker_ts[0] - ticker_ts[1];
       printf( &quot;pulsewidth: [%6lu] [%6lu] us\n&quot;,
               t_pw, PERIODS_US[i]/2 );
       ThisThread::sleep_for( 500ms );
     }
  }
  return 0;
}
</code></pre>
<p><img alt="PWM pulsewidth measurement" src="../images/mbed_stm32_pulsewidth_measurement.png" /></p>
<p>รูปภาพ:  ข้อความเอาต์พุตแสดงผลการวัดความกว้างพัลส์ของสัญญาณ <strong>PWM</strong></p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License.</em></strong></p>
<p>Created: 2021-11-23 | Last Updated: 2021-11-28</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2023 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
