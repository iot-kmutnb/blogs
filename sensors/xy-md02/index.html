<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/sensors/xy-md02/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>การใช้งานโมดูล XY-MD02 Temperature &amp; Humidity Sensor (RS485 Modbus RTU) - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#xy-md02-temperature-humidity-sensor-rs485-modbus-rtu" class="nav-link">การใช้งานโมดูล XY-MD02 Temperature &amp; Humidity Sensor (RS485 Modbus RTU)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#xy-md02" class="nav-link">&#9655; XY-MD02</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#rs485-interfacing" class="nav-link">&#9655; RS485 Interfacing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#modbus-rtu-over-rs485" class="nav-link">&#9655; Modbus RTU over RS485</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#python-coding-using-pyserial" class="nav-link">&#9655; Python Coding Using PySerial</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#python-coding-using-pyserial-minimalmodbus" class="nav-link">&#9655; Python Coding Using PySerial + MinimalModbus</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#arduino-esp32c3-with-modbusrtumaster-library" class="nav-link">&#9655; Arduino ESP32(C3) with ModbusRTUMaster Library</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="xy-md02-temperature-humidity-sensor-rs485-modbus-rtu">การใช้งานโมดูล XY-MD02 Temperature &amp; Humidity Sensor (RS485 Modbus RTU)<a class="headerlink" href="#xy-md02-temperature-humidity-sensor-rs485-modbus-rtu" title="Permanent link">#</a></h1>
<p>บทความนี้กล่าวถึงการทดลองใช้งานโมดูล <strong>XY-MD02 Sensor</strong> (ผลิตจากประเทศจีน)
ซึ่งเป็นเซนเซอร์วัดอุณหภูมิ (<strong>Temperature</strong>) และความชื้นสัมพัทธ์ (<strong>Relative Humidity</strong>)
เชื่อมต่อด้วยบัส <strong>RS485</strong> และใช้โพรโทคอล <strong>Modbus RTU</strong> ในการสื่อสารข้อมูล</p>
<p><strong>Keywords:</strong> <em>Temperature &amp; Relative Humidity Sensor</em>, 
<em>RS485</em>, <em>Modbus RTU</em>, <em>Python Programming</em></p>
<hr />
<h2 id="xy-md02">&#9655; <strong>XY-MD02</strong><a class="headerlink" href="#xy-md02" title="Permanent link">#</a></h2>
<p>ข้อมูลเชิงเทคนิคเกี่ยวกับโมดูล <strong>XY-MD02</strong></p>
<ul>
<li>ใช้แรงดันไฟเลี้ยงได้ในช่วง  <strong>5V ~ 30V (DC)</strong></li>
<li>มีไอซีลดระดับและควบคุมแรงดันให้ได้ <strong>3.3V</strong></li>
<li>มีกล่องพลาสติกยึดได้กับรางปีกนก (<strong>DIN Rail</strong>)</li>
<li>มีคอนเนกเตอร์เป็นแบบ <strong>Terminal Blocks: B-, A+, GND(-), VCC(+)</strong></li>
<li>เชื่อมต่อด้วยบัส <strong>RS485</strong> และใช้ไอซี <strong>RS485 Transceiver (3.3V)</strong>
และทำหน้าที่เป็นอุปกรณ์ <strong>RS485 Slave</strong></li>
<li>สื่อสารข้อมูลด้วยสองวิธี<ul>
<li><strong>Modbus RTU (Remote Terminal Unit) RS485 Protocol</strong></li>
<li><strong>Serial ASCII Command</strong> เช่น คำสั่ง <code>READ</code>, <code>PARAM</code> เป็นต้น</li>
</ul>
</li>
<li>อัตราการส่งข้อมูลแบบบิตอนุกรม: <strong>9600 (default)</strong> และ <strong>19200 (max.)</strong><ul>
<li>Data Bits: 8</li>
<li>Parity Bit: No</li>
<li>Stop Bit: 1</li>
</ul>
</li>
<li>ตั้งค่าหมายเลขอุปกรณ์ได้ในช่วง <strong>1 ~ 247</strong> (<strong>default: 1</strong>)</li>
<li>ใช้ไอซีของบริษัท <strong>Sensirion</strong></li>
<li><strong>Temperature Range</strong>: -40 ~ 125 °C</li>
<li><strong>Humidity Range</strong>: 0 ~ 100 %RH</li>
<li><strong><a href="https://www.sensirion.com/products/catalog/SHT20/">SHT20</a> (I2C):</strong><ul>
<li><strong>Temperature Precision</strong>: +/-0.3 ℃</li>
<li><strong>Humidity Precision</strong>: +/-3 %RH</li>
</ul>
</li>
<li><strong><a href="https://www.sensirion.com/products/catalog/SHTC3/">SHTC3</a> (I2C):</strong><ul>
<li><strong>Temperature Precision</strong>: +/-0.2 ℃</li>
<li><strong>Humidity Precision</strong>: +/-2 %RH</li>
</ul>
</li>
<li><strong><a href="https://www.sensirion.com/products/catalog/SHT40/">SHT40</a> (I2C):</strong><ul>
<li><strong>Temperature Precision</strong>: +/-0.2 ℃</li>
<li><strong>Humidity Precision</strong>: +/-2 %RH</li>
</ul>
</li>
</ul>
<p>โมดูล <strong>XY-MD02 (SHT40)</strong> มีการใช้ไอซี เช่น</p>
<ul>
<li><strong>HK32F030M MCU</strong>: <ul>
<li>Arm Cortex-M0, 32MHz, 16KB flash, 2KB / 4MB SRAM</li>
</ul>
</li>
<li><strong>SHT40</strong>:<ul>
<li>I2C with Pullup: 4.7k Ohm (on SCL and SDA line)</li>
</ul>
</li>
<li><strong>SP3485E</strong><ul>
<li>Half-Duplex RS-485 Transceiver</li>
<li>SOIC-8 </li>
</ul>
</li>
<li><strong>L5J / TPL820F33–89</strong>:<ul>
<li>3.3V LDO Voltage Regulator</li>
<li>Current Output: 180mA (max.) @3.3V</li>
<li>Wide Input Voltage Range: 3.6V to 42V</li>
<li>SOT-89–3</li>
</ul>
</li>
</ul>
<p><img alt="" src="xy-md02_module-3.jpg" /></p>
<p><img alt="" src="xy-md02_module-5.jpg" /></p>
<p>รูป: แผงวงจรภายในโมดูล <strong>XY-MD02</strong></p>
<p><img alt="" src="xy-md02_module-2.jpg" /></p>
<p>รูป:  ไอซี <strong>SHT40</strong> บนแผงวงจรของโมดูล</p>
<p>&nbsp;</p>
<hr />
<h2 id="rs485-interfacing">&#9655; <strong>RS485 Interfacing</strong><a class="headerlink" href="#rs485-interfacing" title="Permanent link">#</a></h2>
<p>ในการใช้งานโมดูล <strong>XY-MD02</strong> กับคอมพิวเตอร์ จะต้องมีอุปกรณ์ <strong>USB-to-RS485 Transceiver</strong>
แต่ถ้าจะใช้กับบอร์ดไมโครคอนโทรลเลอร์ จะต้องมีโมดูล <strong>RS485 Transceiver</strong>
ที่รับส่งข้อมูลแบบบิตอนุกรม (<strong>Serial</strong>) </p>
<p>โมดูล <strong>RS485 Transceiver</strong> แบ่งได้เป็น 2 กลุ่มตามลักษณะการใช้งานขา  <strong>I/O</strong>
สำหรับการเชื่อมต่อกับไมโครคอนโทรลเลอร์</p>
<ul>
<li>ประเภทแรกมีขา <strong>DE, /RE, DI, RO</strong><ul>
<li><strong>VCC, GND</strong> (Supply Voltage)</li>
<li><strong>A+, B-</strong> (RS485 Differential Signal Pair)</li>
<li><strong>DE</strong> (Driver Enable, Active-High)</li>
<li><strong>/RE</strong> (Receiver Enable, Active-Low)</li>
<li><strong>DI</strong> (Driver Input)</li>
<li><strong>RO</strong> (Receiver Output)</li>
</ul>
</li>
<li>ประเภทที่สองมีขา <strong>TX, RX</strong> และเนื่องจากว่า มีวงจรควบคุมการเปลี่ยนทิศทางการรับส่งข้อมูลโดยอัตโนมัติ
(<strong>Automatic Flow Control</strong>)
จึงใช้งานได้สะดวกกว่า เหมือนการสื่อสารข้อมูลกับโมดูล <strong>Serial (TTL Logic)</strong> โดยทั่วไป<ul>
<li><strong>VCC, GND</strong> (Supply Voltage)</li>
<li><strong>A+, B-</strong> (RS485 Differential Signal Pair)</li>
<li><strong>TX</strong> (Serial Out)</li>
<li><strong>RX</strong> (Serial In)</li>
</ul>
</li>
</ul>
<p>แนะนำให้ใช้งานโมดูลประเภทที่สอง เนื่องจากใช้งานได้ง่ายกว่า</p>
<p><img alt="" src="max485_module.png" /></p>
<p>รูป: ตัวอย่างโมดูล  <strong>RS485 Transceiver "HW-97" (MAX485, 5V)</strong></p>
<p><img alt="" src="rs485_serial_module-1.jpg" /></p>
<p>รูป: ตัวอย่างโมดูล  <strong>RS485 Transceiver "HW-0519" (MAX485, 5V)</strong></p>
<p><img alt="" src="rs485_serial_module-2.jpg" /></p>
<p>รูป: ตัวอย่างโมดูล  <strong>RS485 Transceiver (MAX1348, 3.3V ~ 5V)</strong></p>
<p><img alt="" src="xy-md02_module-4.jpg" /></p>
<p>รูป: การใช้แรงดันไฟเลี้ยง (<strong>5V</strong> หรือสูงกว่า)</p>
<p><img alt="" src="xy-md02_module-1.jpg" /></p>
<p>รูป: ตัวอย่างการเชื่อมต่อโมดูล <strong>XY-MD02</strong> ในระบบบัส <strong>RS485</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="modbus-rtu-over-rs485">&#9655; <strong>Modbus RTU over RS485</strong><a class="headerlink" href="#modbus-rtu-over-rs485" title="Permanent link">#</a></h2>
<p>โดยทั่วไปแล้ว การสื่อสารข้อมูลด้วยโพรโทคอล <a href="https://modbus.org/"><strong>Modbus</strong></a> มี 3 รูปแบบ</p>
<ul>
<li><a href="https://modbus.org/docs/Modbus_over_serial_line_V1_02.pdf"><strong>Modbus over Serial</strong></a><ul>
<li><strong>Modbus RTU (binary)</strong> โดยใช้ <strong>RS485</strong> เป็น <strong>Serial / Physical Layer</strong></li>
<li><strong>Modbus ASCII</strong> เหมือน <strong>Modbus RTU</strong> แต่ข้อมูลเป็น <strong>ASCI (Text-based)</strong></li>
</ul>
</li>
<li><strong>Modbus over TCP</strong> โดยใช้ระบบเครือข่ายและสื่อสารด้วย <strong>TCP/IP</strong></li>
</ul>
<p>โมดูล <strong>XY-MD02</strong> สื่อสารด้วยโพรโทคอล <strong>Modbus RTU</strong>
ซึ่งจะต้องมีการส่งเฟรมหรือชุดข้อมูลไบต์ออกไป (<strong>Request Frame</strong>)
และรับข้อมูลที่ตอบกลับมา (<strong>Response Frame</strong>)
ทั้งการส่งและการรับเฟรมข้อมูล จะต้องมีการตรวจสอบความผิดพลาดด้วย <strong>CRC</strong>
(<em>Cyclic Redundancy Check</em>) จำนวน 2 ไบต์ ที่อยู่สองไบต์ท้ายของเฟรมข้อมูล</p>
<p>คอมพิวเตอร์หรือไมโครคอนโทรลเลอร์จะทำหน้าที่เป็น <strong>Modbus Master</strong>
และอุปกรณ์เซนเซอร์ <strong>XY-MD02</strong> จะทำหน้าที่เป็น <strong>Modbus Slave</strong>
เชื่อมต่อกันด้วยระบบบัส <strong>RS485</strong></p>
<p>ตามโพรโทคอลของ <a href="https://www.modbustools.com/modbus.html"><strong>Modbus RTU</strong></a>
การเขียนหรืออ่านข้อมูลรีจิสเตอร์ แต่ละตัวมีขนาด 2 ไบต์ 
หรือ 16 บิต ( <strong>Big-endian encoding</strong>) มีการจำแนกประเภทหรือแบ่งกลุ่มซึ่งจะใช้
คำสั่ง <strong>Function Code (FC)</strong> แตกต่างกัน เช่น</p>
<ul>
<li><strong>Input Registers</strong> เป็นรีจิสเตอร์สำหรับข้อมูล (ขนาด 2 ไบต์) ที่ใช้เป็นอินพุตของโมดูลหรือมีการเปลี่ยนแปลงได้<ul>
<li>ใช้คำสั่ง <strong>FC = 0x04 (Read Input Registers)</strong> อ่านค่าจากรีจิสเตอร์หนึ่งตัว (หรือมากกว่าหนึ่งตัวแต่มีแอดเดรสต่อเนื่องกัน)</li>
</ul>
</li>
<li><strong>Holding Registers</strong> เป็นรีจิสเตอร์สำหรับข้อมูล (ขนาด 2 ไบต์) เช่น การตั้งค่าการใช้งานสำหรับโมดูล<ul>
<li>ใช้คำสั่ง <strong>FC = 0x03 (Read Multiple Holding Registers)</strong> อ่านค่าจากรีจิสเตอร์หนึ่งตัว (หรือมากกว่าหนึ่งตัวแต่มีแอดเดรสต่อเนื่องกัน)</li>
<li>ใช้คำสั่ง <strong>FC = 0x06 (Write Single Holding Register)</strong> เขียนค่าลงในรีจิสเตอร์หนึ่งตัว</li>
<li>ใช้คำสั่ง <strong>FC = 0x10 (Write Multiple Holding Registers)</strong> เขียนค่าลงในรีจิสเตอร์มากกว่าหนึ่งตัว</li>
</ul>
</li>
</ul>
<p>โมดูล <strong>XY-MD02</strong> มีรีจิสเตอร์ดังนี้</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Size (bytes)</th>
<th>Register Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Reg.</td>
<td>Temperature</td>
<td>2</td>
<td>0x0001</td>
</tr>
<tr>
<td>Input Reg.</td>
<td>Humidity</td>
<td>2</td>
<td>0x0002</td>
</tr>
<tr>
<td>Holding Reg.</td>
<td>Device Address</td>
<td>2</td>
<td>0x0101</td>
</tr>
<tr>
<td>Holding Reg.</td>
<td>Baud Rate</td>
<td>2</td>
<td>0x0102</td>
</tr>
<tr>
<td>Holding Reg.</td>
<td>Temperature Correction</td>
<td>2</td>
<td>0x0103</td>
</tr>
<tr>
<td>Holding Reg.</td>
<td>Humidity Correction</td>
<td>2</td>
<td>0x0104</td>
</tr>
</tbody>
</table>
<ul>
<li>ค่าอุณหภูมิ และ ความชื้นสัมพัทธ์ อ่านได้จากรีจิสเตอร์ตามแอดเดรส
<code>0x0001</code> และ <code>0x0002</code> ตามลำดับ ค่าตัวเลขที่อ่านได้เป็น <strong>Signed 16-bit Integer</strong>
และจะต้องนำไปหารด้วย <strong>10.0</strong> </li>
<li>รีจิสเตอร์ตามแอดเดรส  <code>0x0101</code> ใช้สำหรับการตั้งค่าหรือตรวจสอบหมายเลขอุปกรณ์</li>
<li>รีจิสเตอร์ตามแอดเดรส  <code>0x0102</code> ใช้สำหรับการตั้งค่าหรือตรวจสอบค่า <strong>Baudrate</strong></li>
<li>รีจิสเตอร์ตามแอดเดรส  <code>0x0103</code> ใช้สำหรับการตั้งค่าหรือตรวจสอบค่าชดเชยความผิดพลาดสำหรับอุณหภูมิ
(เป็นค่าที่ใช้ในการบวกหรือลบ อยู่ในช่วง <strong>-10 ~ +10 °C</strong>)</li>
<li>รีจิสเตอร์ตามแอดเดรส  <code>0x0104</code> ใช้สำหรับการตั้งค่าหรือตรวจสอบค่าชดเชยความผิดพลาดสำหรับความชื้น
(เป็นค่าที่ใช้ในการบวกหรือลบ อยู่ในช่วง <strong>-10 ~ +10 %RH</strong>)</li>
</ul>
<p>ตัวอย่างเฟรมข้อมูลสำหรับการส่งไปยังโมดูลเซนเซอร์ ตามลำดับมีดังนี้ </p>
<ul>
<li>แอดเดรสของโมดูล (<strong>Device Address</strong>) ที่ทำหน้าที่เป็น <strong>RS485 Slave</strong> (1~247): 1 ไบต์</li>
<li>รหัสสำหรับฟังก์ชัน (<strong>Function Code</strong>) เช่น <code>0x03</code> หรือ <code>0x04</code>: 1 ไบต์</li>
<li>แอดเดรสเริ่มต้นของรีจิสเตอร์ที่ต้องการอ่านข้อมูล: 2 ไบต์ (<strong>16-bit integer</strong>)</li>
<li>จำนวนรีจิสเตอร์ที่ต้องการอ่าน: 2 ไบต์ (<strong>16-bit integer</strong>)</li>
<li>ตัวเลขสำหรับการตรวจสอบความผิดพลาด (<strong>CRC</strong>): 2 ไบต์ (<strong>16-bit integer</strong>)</li>
</ul>
<p>และเฟรมข้อมูลสำหรับการตอบกลับ</p>
<ul>
<li>แอดเดรสของโมดูลที่ทำหน้าที่เป็น <strong>RS485 Slave</strong> และได้ตอบกลับมา: 1 ไบต์</li>
<li>รหัสสำหรับฟังก์ชัน: 1 ไบต์</li>
<li>จำนวนไบต์ของข้อมูลที่ตามมา: <strong>N</strong> ไบต์</li>
<li>ข้อมูลจากรีจิสเตอร์</li>
<li>ตัวเลขสำหรับการตรวจสอบความผิดพลาด: 2 ไบต์</li>
</ul>
<p>ตัวอย่างเฟรมข้อมูล</p>
<p><img alt="" src="modbus_format-1.png" /></p>
<p>รูป: ตัวอย่างเฟรมข้อมูลสำหรับการส่งออกไปโดย <strong>RS485 Master</strong> และเฟรมข้อมูลการตอบกลับจาก
<strong>RS485 Slave</strong> (อ้างอิงจากเอกสารของผู้ผลิต)</p>
<p><img alt="" src="modbus_format-2.png" /></p>
<p>รูป: ตัวอย่างการใช้คำสั่ง <code>0x04</code> สำหรับการอ่านค่าจากรีจิสเตอร์ที่เก็บค่าอุณหภูมิ (แอดเดรส: <code>0x0001</code>)
และการตอบกลับมาจากโมดูลเซนเซอร์</p>
<p><img alt="" src="modbus_format-3.png" /></p>
<p>รูป: ตัวอย่างการใช้คำสั่ง <code>0x04</code> สำหรับการอ่านค่าจากรีจิสเตอร์ที่เก็บค่าความชื้นสัมพัทธ์ (แอดเดรส: <code>0x0002</code>)
และการตอบกลับมา</p>
<p>สำหรับการใช้คำสั่งและเฟรมข้อมูลที่เกี่ยวข้อง สามารถศึกษาได้จากเอกสารคู่มือการใช้งาน (<strong>PDF files</strong>):
(<a href="xy-md02_manual-1.pdf">1</a> | <a href="xy-md02_manual-2.pdf">2</a>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="python-coding-using-pyserial">&#9655; <strong>Python Coding Using PySerial</strong><a class="headerlink" href="#python-coding-using-pyserial" title="Permanent link">#</a></h2>
<p>การเขียนโค้ดด้วย <strong>Python</strong> เพื่อเชื่อมต่อกับโมดูล <strong>XY-MD02</strong>
จะต้องใช้ไลบรารี <strong>PySerial</strong> (ติดตั้งด้วยคำสั่ง <code>pip3 install pyserial</code>)</p>
<p>โค้ดต่อไปนี้สาธิตการส่งคำสั่งเพื่ออ่านค่าจากรีจิสเตอร์-อินพุต ได้แก่ อุณหภูมิและความชื้นสัมพัทธ์ 
รวมถึงการอ่านค่าจากรีจิสเตอร์ที่เก็บค่าสำหรับการตั้งค่าใช้งานของโมดูล
การอ่านค่าจากรีจิสเตอร์ทีละตัว จะใช้ฟังก์ชัน <code>read_single_reg(...)</code></p>
<pre><code class="language-python">import time
import struct
from datetime import datetime
import serial

DEV_ADDR     = 0x01
SERIAL_PORT  = '/dev/ttyUSB0'
#SERIAL_PORT = 'COM54'
BAUDRATE     = 9600

# Calculate the CRC of a Modbus RTU response.
def calc_modbus_crc(data):
    crc = 0xFFFF
    for x in data:
        crc ^= x
        for _ in range(8):
            if crc &amp; 1:
                crc &gt;&gt;= 1
                crc ^= 0xA001
            else:
                crc &gt;&gt;= 1
    return crc

def read_single_reg( ser, dev_addr, func_code, reg_addr ):
    reg_addr_hi = (reg_addr &gt;&gt; 8) &amp; 0xff
    reg_addr_lo = reg_addr &amp; 0xff
    frame = [dev_addr, func_code, reg_addr_hi, reg_addr_lo, 0x00, 0x01]
    crc = calc_modbus_crc( frame ) 
    frame.append( crc &amp; 0xff )
    frame.append( (crc &gt;&gt; 8) &amp; 0xff )
    ser.write( bytes(frame) )
    time.sleep(0.1)
    resp_frame = ser.read(10)
    expected_crc = int.from_bytes(resp_frame[-2:], byteorder='little')
    calculated_crc = calc_modbus_crc(resp_frame[:-2])
    if calculated_crc == expected_crc:
        return resp_frame
    else:
        print( 'CRC error: ', calculated_crc, expected_crc )
        return None

# Open the serial port
ser = serial.Serial(port=SERIAL_PORT, baudrate=BAUDRATE, timeout=0.1)

holding_regs = [0x0101, 0x0102, 0x0103, 0x0104]
names = [ 'Device address: {}', 
          'Baudrate: {}',
          'Temperature Correction: {}',
          'Humudity Correction: {}' ]
values = []
for reg in holding_regs:
    resp = read_single_reg( ser, DEV_ADDR, 0x03, reg )
    if resp is not None:
        values.append( struct.unpack('&gt;h', resp[3:5])[0] )

for i,kv in enumerate(zip(names,values)):
    if i==2 or i==3:
        print ( kv[0].format(kv[1]/10.0) )
    else:
        print ( kv[0].format(kv[1]) )

input_regs = [0x0001, 0x0002]
names = [ 'Temperature: {:.1f} deg.C', 'Humidity: {:.1f} %RH' ]

try:
    while True:
        values = []
        for reg in input_regs:
            resp = read_single_reg( ser, DEV_ADDR, 0x04, reg )
            if resp is not None:
                value = struct.unpack('&gt;h', resp[3:5])[0]
                values.append( value/10.0 )
        ts = datetime.now().replace(microsecond=0)
        print( f&quot;Timestamp:&quot;, ts )
        for name, value in zip(names,values):
            print( name.format( value ) )
        print(40*'-')
        time.sleep(4.0)
except KeyboardInterrupt:
    pass
finally:
    if ser:
        ser.close()
</code></pre>
<p><img alt="" src="python_code-1.png" /></p>
<p>รูป: การเขียนโค้ดและรันโค้ดด้วย <strong>VS Code IDE</strong></p>
<p><img alt="" src="rs485_signaling.png" /></p>
<p>รูป: การวัดสัญญาณ <strong>A+</strong> และ <strong>B-</strong> ด้วยออสซิลโลสโคป</p>
<p>โค้ดตัวอย่างถัดไปสาธิต การเขียนค่าลงในรีจิสเตอร์ตามแอดเดรส <code>0x0103</code> (<strong>Temperature Correction</strong>)
โดยใช้คำสั่ง <strong>Function Code</strong> เท่ากับ <code>0x06</code> และใช้กับอุปกรณ์หมายเลข <code>0x01</code>
การเขียนค่าไปยังรีจิสเตอร์หนึ่งตัว จะใช้ฟังก์ชัน <code>write_single_reg(...)</code>
ถ้าต้องการให้มีการปรับชดเชยค่า เช่น <strong>+0.5</strong> องศาเซลเซียส จะต้องคูณด้วย 10 แล้วแปลงให้เป็นเลข <strong>16-bit signed integer</strong>
เพื่อเขียนลงในรีจิสเตอร์</p>
<pre><code class="language-python">import time
import struct
from datetime import datetime
import serial

DEV_ADDR     = 0x01
SERIAL_PORT  = '/dev/ttyUSB0'
BAUDRATE     = 9600

def calc_modbus_crc(data):
    crc = 0xFFFF
    for x in data:
        crc ^= x
        for _ in range(8):
            if crc &amp; 1:
                crc &gt;&gt;= 1
                crc ^= 0xA001
            else:
                crc &gt;&gt;= 1
    return crc

def write_single_reg( ser, dev_addr, func_code, reg_addr, value ):
    reg_addr_hi = (reg_addr &gt;&gt; 8) &amp; 0xff
    reg_addr_lo = reg_addr &amp; 0xff
    value_hi  = (value &gt;&gt; 8) &amp; 0xff
    value_lo  = value &amp; 0xff
    frame = [dev_addr, func_code, reg_addr_hi, reg_addr_lo, 
             value_hi, value_lo]
    crc = calc_modbus_crc( frame ) 
    frame.append( crc &amp; 0xff )
    frame.append( (crc &gt;&gt; 8) &amp; 0xff )
    ser.write( bytes(frame) )
    time.sleep(0.1)
    resp_frame = ser.read(10)
    expected_crc = int.from_bytes(resp_frame[-2:], byteorder='little')
    calculated_crc = calc_modbus_crc(resp_frame[:-2])
    if calculated_crc == expected_crc:
        return resp_frame
    else:
        print( 'CRC error: ', calculated_crc, expected_crc )
        return None

# Open the serial port
ser = serial.Serial(port=SERIAL_PORT, baudrate=BAUDRATE, timeout=0.1)

# Set temperature correction (TC) in deg.C, multipled by 10
TC = 0.5
resp = write_single_reg( ser, DEV_ADDR, 0x06, 0x0103, int(TC*10) )
print( resp )

if ser:
    ser.close()
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="python-coding-using-pyserial-minimalmodbus">&#9655; <strong>Python Coding Using PySerial + MinimalModbus</strong><a class="headerlink" href="#python-coding-using-pyserial-minimalmodbus" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างถัดไปสาธิตการใช้ไลบรารี <a href="https://minimalmodbus.readthedocs.io/en/stable/"><strong>MinimalModbus</strong></a>
(ติดตั้งโดยทำคำสั่ง <code>$ pip3 install minimalmodbus</code>)
เพื่ออ่านค่าอุณหภูมิและความชื้นสัมพัทธ์ จากอุปกรณ์ที่มีแอดเดรส <code>0x01</code></p>
<pre><code class="language-python">import time
import minimalmodbus

# Set the slave address
DEV_ADDR = 1
# Specify the serial port to be used
PORT_NAME = '/dev/ttyUSB0'

FUNC_CODE = 4
REG_ADDR_TEMP  = 1
REG_ADDR_HUMID = 2

# MODBUS device initialization
device = minimalmodbus.Instrument(PORT_NAME, DEV_ADDR, debug=True)

# MODBUS device connection settings
device.serial.baudrate = 9600
device.serial.bytesize = 8
device.serial.parity   = minimalmodbus.serial.PARITY_NONE
device.mode            = minimalmodbus.MODE_RTU
device.serial.stopbits = 1
device.serial.timeout  = 0.1

while True:
    try: 
        # Reg. address (1 or 2), number of decimals (1), function code (4)
        temp  = device.read_register(REG_ADDR_TEMP, 1, FUNC_CODE )
        humid = device.read_register(REG_ADDR_HUMID, 1, FUNC_CODE )
        print(40*&quot;-&quot;)
        print(&quot;Temperature:&quot;, temp)
        print(&quot;Humidity:&quot;, humid)
    except IOError:
        print(&quot;Failed to read from the device!&quot;)
    time.sleep(4.0)
</code></pre>
<p><img alt="" src="minimalmodbus_demo.png" /></p>
<p>รูป: การสาธิตการทำงานของโค้ดตัวอย่างที่ใช้ไลบรารี <strong>MinimalModbus</strong></p>
<hr />
<h2 id="arduino-esp32c3-with-modbusrtumaster-library">&#9655; <strong>Arduino ESP32(C3) with ModbusRTUMaster Library</strong><a class="headerlink" href="#arduino-esp32c3-with-modbusrtumaster-library" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างต่อไปนี้สาธิตการใช้งานไลบรารี <a href="https://github.com/CMB27/ModbusRTUMaster"><strong>ModbusRTUMaster</strong></a>
ร่วมกับบอร์ดไมโครคอนโทรลเลอร์ <strong>ESP32C3</strong> และเขียนโปรแกรมด้วย <strong>Arduino ESP32 Core (v3.0)</strong>
ในโค้ดตัวอย่างได้เลือกใช้ <a href="https://github.com/espressif/arduino-esp32/blob/master/cores/esp32/HardwareSerial.h"><code>HardwareSerial</code></a>
ระหว่าง <strong>Serial0</strong> หรือ <strong>Serial1</strong> และต้องมีการกำหนดขา <strong>Rx/Tx</strong> เพื่อนำไปเชื่อมต่อกับโมดูล
<strong>XY-017 Serial-RS485 Transceiver</strong> ซึ่งสามารถใช้แรงดันไฟเลี้ยง <strong>3.3V</strong> ได้</p>
<p>ข้อสังเกต: โมดูล <strong>XY-017</strong> มีขา <strong>TXD</strong> เป็นอินพุต และมีขา <strong>RXD</strong> เป็นเอาต์พุต</p>
<pre><code class="language-c++">#include &lt;HardwareSerial.h&gt;
#include &lt;ModbusRTUMaster.h&gt; // https://github.com/CMB27/ModbusRTUMaster

#define HW_SERIAL (0)
HardwareSerial RS485( HW_SERIAL ); // Use Hardware Serial 0 or 1
ModbusRTUMaster modbus( RS485 );

void setup() {
  Serial.begin(115200); // USB-CDC
  while(!Serial);
  Serial.flush();
  // Set Tx/Rx pins for RS485-serial
  if (HW_SERIAL==0) {
    // Default pins for Serial0: RX=GPIO20, TX=GPIO21
    RS485.setPins( 20 /*RX*/, 21 /*TX*/ );
  } else {
    // Default pins for Serial1: RX=GPIO18, TX=GPIO19
    // Use RX=10 and TX=9 for Super-Mini ESP32C3 Board.
    RS485.setPins( 10 /*RX*/, 9 /*TX*/ );
  }
  // Set baudrate for RS485-serial
  modbus.begin( 9600 );
}

void loop() {
  static uint8_t dev_addr = 1;
  uint16_t regValues[2] = {0xffff,0xffff};
  // device address, starting address of input registers, 
  // number of input registers to read
  modbus.readInputRegisters( dev_addr, 0x0001, regValues, 2 ); 
  if  ( regValues[0] != 0xffff ) {
    float temp  = ((int16_t)regValues[0])/10.0f;
    float humid = ((int16_t)regValues[1])/10.0f;
    Serial.println(String(&quot;XY-MD02 Reading, Device Address: &quot;) + dev_addr);
    Serial.println(String(&quot;- Temperature : &quot;) + temp + String(&quot; deg.C&quot;)); 
    Serial.println(String(&quot;- Humidity    : &quot;) + humid + String(&quot; %RH\n&quot;)); 
  } else {
    Serial.println(&quot;Sensor reading errors!&quot;);
  }
  Serial.flush();
  if ((dev_addr += 1) &gt; 2) {
    dev_addr = 1;
  }  
  delay(2000);
}
</code></pre>
<p><img alt="" src="esp32c3_modbus-1.png" /></p>
<p>รูป: การสาธิตการทำงานของโค้ด <strong>Arduino Sketch</strong> ที่ใช้ไลบรารี <strong>ModbusRTUMaster</strong></p>
<p><img alt="" src="xy-017_module.png" /></p>
<p>รูป: โมดูล <strong>XY-017</strong> และตัวอย่างผังวงจร</p>
<p><img alt="" src="esp32c3_xy-md02_module.jpg" /></p>
<p>รูป: ตัวอย่างการเชื่อมต่อระหว่างอุปกรณ์ ได้แก่ <strong>Super-Mini ESP32-C3</strong>, <strong>XY-017</strong>
และ <strong>XY-MD02</strong></p>
<p>ตัวอย่างการเขียนโค้ดโดยไม่ใช้ไลบรารีสำหรับการอ่านค่าจากรีจิสเตอร์ มีดังนี้</p>
<pre><code class="language-c++">#include &lt;HardwareSerial.h&gt;

#define HW_SERIAL (0)
HardwareSerial RS485( HW_SERIAL ); // Use Hardware Serial 0 or 1

void setup() {
  Serial.begin(115200); // USB-CDC
  while(!Serial);
  Serial.flush();
  RS485.begin(9600);
  // Set Tx/Rx pins for RS485-serial
  if (HW_SERIAL==0) {
    // Default pins for Serial0: RX=GPIO20, TX=GPIO21
    RS485.setPins( 20 /*RX*/, 21 /*TX*/ );
  } else {
    // Default pins for Serial1: RX=GPIO18, TX=GPIO19
    RS485.setPins( 10 /*RX*/, 9 /*TX*/ );
  }
}

// Calculate the CRC of a Modbus RTU response.
uint16_t calc_modbus_crc(const byte* data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i=0; i &lt; len; i++) {
    crc ^= data[i];
    for (int j=0; j &lt; 8; j++) {
      if (crc &amp; 1) {
        crc &gt;&gt;= 1;
        crc ^= 0xA001;
      } else {
        crc &gt;&gt;= 1;
      }
    }
  }
  return crc;
}

// Function to read a single Modbus register
int read_input_regs( byte dev_addr, byte func_code, 
    uint16_t start_reg_addr, size_t num_regs, byte *result ) 
{
    byte reg_addr_hi = (start_reg_addr &gt;&gt; 8) &amp; 0xFF;
    byte reg_addr_lo = start_reg_addr &amp; 0xFF;
    byte num_regs_hi = (num_regs &gt;&gt; 8) &amp; 0xFF;
    byte num_regs_lo = num_regs &amp; 0xFF;
    byte req_frame[8] = { dev_addr, func_code, reg_addr_hi, reg_addr_lo,
                          num_regs_hi, num_regs_lo };
    size_t req_frame_len = sizeof(req_frame);
    uint16_t crc = calc_modbus_crc(req_frame, req_frame_len-2 );
    req_frame[req_frame_len-2] = crc &amp; 0xff;
    req_frame[req_frame_len-1] = (crc &gt;&gt; 8) &amp; 0xff;
    RS485.write( req_frame, req_frame_len );
    delay(5);

    byte resp_frame[16] = {0};
    size_t resp_frame_len = RS485.readBytes( resp_frame, 16 );
    if (resp_frame_len == 0) {
      return -1; // error
    }
    byte *crc_bytes = &amp;resp_frame[resp_frame_len-2];
    uint16_t expected_crc = (crc_bytes[1] &lt;&lt; 8) | crc_bytes[0];
    uint16_t calculated_crc = calc_modbus_crc(resp_frame, resp_frame_len-2);
    if (calculated_crc == expected_crc) {
      memcpy( result, resp_frame, resp_frame_len );
      return 0; // ok
    } else {
      Serial.print(&quot;CRC error: &quot;);
      Serial.print(calculated_crc, HEX);
      Serial.print(&quot; : &quot;);
      Serial.println( expected_crc, HEX);
      return -1; // error
    }
}

void loop() {
  static uint8_t dev_addr = 1;
  byte result[16]; // frame buffer for response
  memset(result, 0x00, sizeof(byte)); 
  if ( !read_input_regs( dev_addr, 0x04, 0x0001, 2, result ) ) {
    int16_t temp  = (result[3]&lt;&lt; 8) | result[4];
    int16_t humid = (result[5]&lt;&lt; 8) | result[6];
    Serial.println(String(&quot;XY-MD02 Reading, Device Address: &quot;) + dev_addr);
    Serial.println(String(&quot;Temperature: &quot;) + temp/10.0f  + &quot; deg.C&quot;);
    Serial.println(String(&quot;Humidity:    &quot;) + humid/10.0f + &quot; %RH&quot;);
  } else {
    Serial.println(&quot;Sensor reading errors!&quot;);
  }
  Serial.flush();
  if ( (dev_addr += 1) &gt; 2 ) {
     dev_addr = 1;
  }
  Serial.println(&quot;----------------&quot;);
  delay(2000);
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="_1">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้ได้นำเสนอการใช้งานโมดูล <strong>XY-MD02 Sensor</strong> การเชื่อมต่อกับคอมพิวเตอร์ทางพอร์ต <strong>USB</strong>
รูปแบบของการส่งคำสั่งและการตอบกลับจากโมดูลโดยใช้โพรโทคอล <strong>RS485 Modbus RTUS</strong>
เพื่ออ่านค่าจากเซนเซอร์ และการตั้งค่าการทำงานของโมดูล โดยใช้ภาษา <strong>Python</strong>
และมีตัวอย่างการใช้งานร่วมกับบอร์ดไมโครคอนโทรลเลอร์ เช่น <strong>ESP32-C3</strong> และเขียนโค้ดด้วย <strong>Arduino ESP32 Core</strong>
เพื่ออ่านค่าจากโมดูล <strong>XY-MD02</strong></p>
<p><strong>บทความที่เกี่ยวข้อง</strong></p>
<ul>
<li><a href="../../electronics/rs485_modules/">การใช้งานโมดูลสื่อสาร <strong>RS485 Transceiver</strong></a></li>
</ul>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License</em></strong>.</p>
<p>Created: 2024-01-19 | Last Updated: 2024-01-26</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
