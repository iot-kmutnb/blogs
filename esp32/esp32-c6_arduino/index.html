<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/esp32/esp32-c6_arduino/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>การเขียนโปรแกรม ESP32-C6 ด้วย Arduino-ESP32 Core - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../css/extra.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/julia.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-966FQ6RN6W');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#esp32-c6-arduino-esp32-core" class="nav-link">การเขียนโปรแกรม ESP32-C6 ด้วย Arduino-ESP32 Core</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#espressif-esp32-c6" class="nav-link">&#9655; แนะนำชิป Espressif ESP32-C6</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#1" class="nav-link">&#9655; โค้ดตัวอย่างที่ 1: การตรวจสอบคุณสมบัติเกี่ยวกับฮาร์ดแวร์และซอฟต์แวร์</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#2-led" class="nav-link">&#9655; โค้ดตัวอย่างที่ 2:  การตรวจสอบสถานะลอจิกของปุ่มกดและเปลี่ยนสถานะลอจิกของ LED</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#3-led-pwm" class="nav-link">&#9655; โค้ดตัวอย่างที่ 3: การปรับความสว่างของ LED ด้วยสัญญาณ PWM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#4-i2c-master" class="nav-link">&#9655; โค้ดตัวอย่างที่ 4: การสื่อสารด้วย I2C Master</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#5-aht2x" class="nav-link">&#9655; โค้ดตัวอย่างที่ 5: การอ่านค่าจากโมดูลเซนเซอร์ AHT2x</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#6-ws2812-rgb-led" class="nav-link">&#9655; โค้ดตัวอย่างที่ 6: การกำหนดค่าสีของโมดูล WS2812 RGB LED</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#7-wifi-ntp-server" class="nav-link">&#9655; โค้ดตัวอย่างที่ 7: การเชื่อมต่อผ่าน WiFi ไปยัง NTP Server</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#8-adc" class="nav-link">&#9655; โค้ดตัวอย่างที่ 8: การอ่านค่าสัญญาณแอนะล็อกด้วย ADC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#9-adc-timer" class="nav-link">&#9655; โค้ดตัวอย่างที่ 9: การอ่านค่าสัญญาณแอนะล็อกด้วยอัตราคงที่โดยใช้ ADC และ Timer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="esp32-c6-arduino-esp32-core">การเขียนโปรแกรม ESP32-C6 ด้วย Arduino-ESP32 Core<a class="headerlink" href="#esp32-c6-arduino-esp32-core" title="Permanent link">#</a></h1>
<ul>
<li><a href="#espressif-esp32-c6">แนะนำชิป <strong>Espressif ESP32-C6</strong></a></li>
<li><a href="#1">โค้ดตัวอย่างที่ 1: การตรวจสอบคุณสมบัติเกี่ยวกับฮาร์ดแวร์และซอฟต์แวร์</a></li>
<li><a href="#2-led">โค้ดตัวอย่างที่ 2: การตรวจสอบสถานะลอจิกของปุ่มกดและเปลี่ยนสถานะลอจิกของ <strong>LED</strong></a></li>
<li><a href="#3-led-pwm">โค้ดตัวอย่างที่ 3: การปรับความสว่างของ <strong>LED</strong> ด้วยสัญญาณ <strong>PWM</strong></a></li>
<li><a href="#4-i2c-master">โค้ดตัวอย่างที่ 4: การสื่อสารด้วย <strong>I2C Master</strong></a></li>
<li><a href="#5-aht2x">โค้ดตัวอย่างที่ 5: การอ่านค่าจากโมดูลเซนเซอร์ <strong>AHT2x</strong></a></li>
<li><a href="#6-ws2812-rgb-led">โค้ดตัวอย่างที่ 6: การกำหนดค่าสีของโมดูล <strong>WS2812 RGB LED</strong></a></li>
<li><a href="#7-wifi-ntp-server">โค้ดตัวอย่างที่ 7: การเชื่อมต่อผ่าน <strong>WiFi</strong> ไปยัง <strong>NTP Server</strong></a></li>
<li><a href="#8-adc">โค้ดตัวอย่างที่ 8: การอ่านค่าสัญญาณแอนะล็อกด้วย <strong>ADC</strong></a></li>
<li><a href="#9-adc-timer">โค้ดตัวอย่างที่ 9: การอ่านค่าสัญญาณแอนะล็อกด้วยอัตราคงที่โดยใช้ <strong>ADC</strong> และ <strong>Timer</strong></a></li>
</ul>
<hr />
<h2 id="espressif-esp32-c6">&#9655; <strong>แนะนำชิป Espressif ESP32-C6</strong><a class="headerlink" href="#espressif-esp32-c6" title="Permanent link">#</a></h2>
<p><a href="https://www.espressif.com/en/products/socs/esp32-c6"><strong>ESP32-C6 Series</strong></a>
(<em>released: September 22, 2022</em>) ของบริษัท <a href="https://www.espressif.com/"><strong>Espressif Systems</strong></a> 
เป็นชิปที่มีซีพียู <a href="https://en.wikipedia.org/wiki/RISC-V"><strong>32-bit RISC-V Core</strong></a> 
และมีคุณลักษณะด้านฮาร์ดแวร์ (<a href="https://www.espressif.com/sites/default/files/documentation/esp32-c6_datasheet_en.pdf"><strong>ESP32-C6 Series Datasheet</strong></a>) เช่น</p>
<ul>
<li><strong>CPU Cores</strong>:<ul>
<li>High-performance (HP Core): 32-bit RISC-V CPU, 160 MHz</li>
<li>Low-power (LP Core): 32-bit RISC-V CPU (ultra-low power consumption), 20MHz<ul>
<li>LP Peripherals: LP IO, LP UART, LP I2C, ...</li>
</ul>
</li>
</ul>
</li>
<li><strong>Storage</strong>:<ul>
<li>L1 cache: 32 KB</li>
<li>ROM: 320 KB</li>
<li>SRAM: 512 KB (HP Core), 16KB (LP Core)</li>
<li>eFuse: 4 KBits</li>
</ul>
</li>
<li><strong>Packages (5×5 mm) / GPIOs</strong>:<ul>
<li>QFN40 / 30 GPIOs</li>
<li>QFN32 / 22 GPIOs</li>
</ul>
</li>
<li><strong>I/O Drive Strength (Default)</strong>: 20mA</li>
<li><strong>Connectivity</strong>:<ul>
<li>2.4 GHz Wi-Fi 6 (IEEE 802.11b/g/n &amp; 802.11ax)  </li>
<li>2.4 GHz Bluetooth 5 (LE) radio</li>
<li>2.4 GHz IEEE 802.15.4-2015 (ZigBee 3.0 / Thread 1.3 / Matter compliant)</li>
<li>Built-in USB Serial/JTAG Controller (no USB-OTG)</li>
</ul>
</li>
</ul>
<p><strong>เอกสารของผู้ผลิต</strong></p>
<ul>
<li><a href="https://www.espressif.com/sites/default/files/documentation/esp32-c6_datasheet_en.pdf"><strong>ESP32C6 Datasheet</strong></a></li>
<li><a href="https://www.espressif.com/sites/default/files/documentation/esp32-c6_technical_reference_manual_en.pdf"><strong>ESP32C6 Technical Reference Manual</strong></a></li>
</ul>
<p>จุดเด่นที่น่าสนใจของชิป <strong>ESP32-C6</strong> คือ การรองรับรูปแบบการสื่อสารไร้สายแบบหลายโพรโตคอล
ด้วยคลื่นความถี่ <strong>2.4GHz</strong> ได้แก่  <strong>BLE / ZigBee / Thread / Matter</strong>
ซึ่งเหมาะสำหรับการใช้งานด้าน <strong>IoT / Smart Home</strong></p>
<p>หากต้องการจะเขียนโปรแกรมสำหรับ <strong>LP RISC-V Core</strong> จะต้องใช้ <strong>ESP-IDF</strong>
และสามารถศึกษาขั้นตอนการเขียนโปรแกรมได้จาก
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c6/api-reference/system/ulp-lp-core.html">"<strong>ULP LP-Core Coprocessor Programming</strong>"</a></p>
<p><img alt="" src="esp32_c6_block_diagram.png" /></p>
<p>รูป: <strong>ESP32-C6 Block Diagram</strong></p>
<p>บทความนี้นำเสนอตัวอย่างการเขียนโค้ด <strong>Arduino Sketch</strong> และการทดลองใช้งาน
<strong>ESP32-C6</strong> ในเบื้องต้น โดยใช้ <strong>Arduino-ESP32 Core v3.0.0+</strong> (<em>Released: November 2023</em>)
ซึ่งใช้ <strong>ESP-IDF v5.1</strong> เป็นพื้นฐานในการพัฒนา และถือว่าเป็นการอัปเกรดเวอร์ชันครั้งสำคัญจาก
<strong>Arduino ESP32 Core v2.0.0</strong> (<em>Released: September 2021</em>)
และรองรับการใช้งานชิปรุ่น <strong>ESP32-C6</strong> และ <strong>ESP32-H2</strong> จากเดิมที่มีเพียง
<strong>ESP32 / ESP32-S2 / ESP32-S3</strong> และ <strong>ESP32-C3</strong> </p>
<p>ผู้ใช้สามารถดูรายละเอียดเพิ่มเติมเกี่ยวกับการพัฒนาและการเปลี่ยนแปลงเวอร์ชันของ <strong>Arduino-ESP32</strong> ในอดีตจนถึงปัจจุบันได้จาก
<a href="https://github.com/espressif/arduino-esp32/releases">https://github.com/espressif/arduino-esp32/releases</a></p>
<p>ในส่วนของซอฟต์แวร์ จะใช้งาน <strong>Arduino IDE v2.x</strong> สำหรับการเขียนโค้ด
ดังนั้นจะต้องติดตั้ง <strong>Arduino ESP32</strong> เวอร์ชันล่าสุด โดยระบุ <strong>URL</strong>
สำหรับ <strong>Arduino Board Manager</strong> ดังนี้</p>
<p><code>https://espressif.github.io/arduino-esp32/package_esp32_dev_index.json</code></p>
<p><img alt="" src="arduino_esp32_v3.png" /></p>
<p>รูป: การติดตั้ง <strong>Arduino-ESP32 Core v3.0.0+</strong> ใน <strong>Arduino IDE</strong></p>
<p>ในส่วนของฮาร์ดแวร์ บอร์ด <strong>ESP32-C6</strong> สำหรับการนำมาทดลองใช้งาน เช่น </p>
<ul>
<li><a href="https://docs.espressif.com/projects/espressif-esp-dev-kits/en/latest/esp32c6/esp32-c6-devkitm-1/user_guide.html"><strong>Espressif ESP32-C6 DevKitM-1 (with ESP32-C6-MINI-1 module)</strong></a></li>
<li><a href="https://docs.espressif.com/projects/espressif-esp-dev-kits/en/latest/esp32c6/esp32-c6-devkitc-1/user_guide.html"><strong>Espressif ESP32-C6 DevKitC-1 (with ESP32-C6-WROOM-1 module)</strong></a></li>
<li><a href="https://github.com/WeActStudio/WeActStudio.ESP32-C6-A"><strong>WeAct Studio ESP32-C6-A Development Board</strong></a></li>
<li><a href="https://www.waveshare.com/wiki/ESP32-C6-DEV-KIT-N8"><strong>Waveshare ESP32-C6-DEV-KIT-N8</strong></a></li>
</ul>
<p><img alt="" src="esp32-c6_devkit-c_pinout.png" /></p>
<p>รูป: แผนผังของบอร์ด <strong>ESP32-C6 DevKitC-1</strong> (<a href="esp32-c6_devkit-c_schematic.png"><strong>Schematic</strong></a>)</p>
<p><img alt="" src="esp32-c6_devkit-c_diagram.png" /></p>
<p>รูป: แผนผังแสดงองค์ประกอบสำคัญของบอร์ด <strong>ESP32-C6 DevKitC-1</strong></p>
<p>จากแผนผังของบอร์ด <strong>ESP32-C6 DevKitC-1 (N4/N8)</strong>
จะเห็นได้ว่า มีโมดูล <strong>ESP32-C6-WROOM-1</strong> 
และในส่วนการเชื่อมต่อกับคอมพิวเตอร์ของผู้ใช้ มีคอนเนกเตอร์ <strong>USB Type-C</strong> แบ่งเป็น 2 ส่วน คือ </p>
<ul>
<li><strong>USB</strong> (ต่อตรงสัญญาณ <strong>USB D+/D-</strong> ที่ขา <strong> GPIO13</strong> และ <strong> GPIO12</strong> ตามลำดับ) ใช้สำหรับการทำงานของ <strong>USB-to-Serial &amp; JTAG-over-USB</strong></li>
<li><strong>UART0</strong> (ต่อสัญญาณจากขา <strong>U0TXD</strong> และ <strong>U0RXD</strong>
ไปยังไอซี <strong>CP2102N: USB-to-UART Bridge</strong>)
และตรงกับขา <strong>GPIO16</strong> และ<strong> GPIO17</strong> ตามลำดับ</li>
</ul>
<p>การอัปโหลดไฟล์เฟิร์มแวร์ ผ่านทาง  <strong>USB</strong> จึงมีสองทางเลือก</p>
<ul>
<li>เชื่อมต่อผ่าน <strong>USB-to-Serial Bridge</strong> หรือ
แต่เลือกใช้วิธีนี้ ให้เลือก <strong>USB CDC On Boot</strong> เป็น <strong>Disabled</strong></li>
<li>เชื่อมต่อผ่าน <strong>Native USB Port</strong> ของ <strong>ESP32-C6</strong>
แต่เลือกใช้วิธีนี้ ให้เลือก <strong>USB CDC On Boot</strong> เป็น <strong>Enabled</strong></li>
</ul>
<p>ถ้าต้องการเข้าโหมด <strong>USB Bootloader</strong> เพื่ออัปโหลดไฟล์เฟิร์มแวร์ไปยังบอร์ด
ให้กดปุ่ม <strong>BOOT</strong> ค้างไว้ แล้วกดปุ่ม <strong>Reset</strong> แล้วปล่อย</p>
<p><img alt="" src="usb_firmware_upload.png" /></p>
<p>รูป: การเชื่อมต่อกับบอร์ดด้วย <strong>USB</strong> (Source: Espressif)</p>
<p>บอร์ดมีปุ่ม <strong>RESET</strong> (ขา <strong>CHIP_PU</strong>) และปุ่ม <strong>BOOT</strong> (ขา <strong>GPIO9</strong>)
และมีวงจร <strong>WS2812 RGB LED</strong> (ขา <strong>GPIO8</strong>)
ถ้าต้องการใช้ขาอินพุตแบบแอนะล็อก ก็มีให้เลือกใช้ 7 ช่องสัญญาณ ได้แก่
<strong>ADC1_CH0..CH6</strong> (ตรงกับขา <strong>GPIO0..GPIO6</strong> ตามลำดับ)</p>
<p>&nbsp;</p>
<p>บอร์ด <strong>WeAct Studio ESP32-C6-A</strong> มีลักษณะคล้ายกับ
<strong>ESP32-C6 DevKitC-1</strong> ของบริษัท <strong>Espressif Systems</strong></p>
<p><img alt="" src="weact_esp32c6_board_pinout.png" /></p>
<p>รูป: แผนผังแสดงองค์ประกอบสำคัญของบอร์ด <strong>WeAct Studio ESP32-C6-A</strong></p>
<p>ในเชิงเปรียบเทียบความแตกต่าง บอร์ด <strong>ESP32-C6-DEV-KIT-N8</strong> มีคอนเนกเตอร์ <strong>USB Type-C</strong>
เพียงอันเดียว แต่มีการใช้งานชิป <strong>USB Hub</strong> เพื่อเชื่อมต่อและแชร์การใช้งาน <strong>USB</strong>
ระหว่างไอซี <strong>USB-to-Serial Bridge</strong>
และขาสัญญาณ <strong>USB D+/D-</strong> ของ <strong>ESP32-C6</strong></p>
<p><img alt="" src="waveshare_esp32-c6-dev-kit-n8.png" /></p>
<p>รูป: แผนผังแสดงองค์ประกอบสำคัญของบอร์ด <strong>ESP32-C6-DEV-KIT-N8</strong></p>
<p><img alt="" src="waveshare_esp32-c6-dev-kit-n8._pinmap.png" /></p>
<p>รูป: แผนผังของบอร์ด <strong>ESP32-C6-DEV-KIT-N8</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="1">&#9655; <strong>โค้ดตัวอย่างที่ 1: การตรวจสอบคุณสมบัติเกี่ยวกับฮาร์ดแวร์และซอฟต์แวร์</strong><a class="headerlink" href="#1" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างแรก สาธิตการเขียนโค้ดโดยใช้
<strong>Arduino-ESP32 Core</strong> สำหรับบอร์ด <strong>ESP32-C6</strong> และสาธิตการใช้คำสั่งของคลาส 
<a href="https://github.com/espressif/arduino-esp32/blob/master/cores/esp32/Esp.h"><code>ESP</code></a>
เพื่อแสดงข้อมูลเกี่ยวกับฮาร์ดแวร์และซอฟต์แวร์ เช่น</p>
<ul>
<li><code>ESP.getCoreVersion()</code> ข้อความระบุเวอร์ชันของ <strong>Arduino ESP32 Core</strong></li>
<li><code>ESP.getSdkVersion()</code> ข้อความระบุเวอร์ชันของ <strong>ESP-IDF</strong></li>
<li><code>ESP.getChipModel()</code> ข้อความระบุโมเดลหรือชื่อรุ่นของ <strong>ESP32 Series</strong></li>
</ul>
<pre><code class="language-c">void showESPInfo() {  
  Serial.println( &quot;Hardware Info...&quot; );
  Serial.printf( &quot;- ESP chip model   : %s\n&quot;, ESP.getChipModel() );
  Serial.printf( &quot;- Chip revision    : %u\n&quot;, ESP.getChipRevision() );
  Serial.printf( &quot;- No. of cores     : %u\n&quot;, ESP.getChipCores() );
  Serial.printf( &quot;- Chip MAC address : %llx\n&quot;, ESP.getEfuseMac() );

  Serial.printf( &quot;- Total heap size  : %lu bytes\n&quot;, ESP.getHeapSize() );
  Serial.printf( &quot;- Free heap size   : %lu bytes\n&quot;, ESP.getFreeHeap() );
  Serial.printf( &quot;- Total PSRAM size : %lu bytes\n&quot;, ESP.getPsramSize() );
  Serial.printf( &quot;- Free PSRAM size  : %lu bytes\n&quot;, ESP.getFreePsram() );

  Serial.printf( &quot;- SPI flash size   : %lu MB\n&quot;,  ESP.getFlashChipSize()/(1024*1024) );
  Serial.printf( &quot;- SPI flash speed  : %lu MHz\n\n&quot;, ESP.getFlashChipSpeed()/(long)1e6 );

  Serial.println( &quot;Software Info...&quot; );
#if ESP_ARDUINO_VERSION &gt;= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
  Serial.printf( &quot;- Arduino ESP32 Core : v%s\n&quot;, ESP.getCoreVersion() );
#else
  Serial.printf( &quot;- Arduino ESP32 Core : v%i.%i.%i\n&quot;,
      ESP_ARDUINO_VERSION_MAJOR, ESP_ARDUINO_VERSION_MINOR, ESP_ARDUINO_VERSION_PATCH );
#endif
  Serial.printf( &quot;- Espressif ESP-IDF  : %s\n\n&quot;, ESP.getSdkVersion() );
}

void setup() {
  Serial.begin( 115200 );
  Serial.println(&quot;\n\n\n&quot;);
}

void loop() {
  showESPInfo();
  delay(5000);
}
</code></pre>
<p>ถ้าอัปโหลดเฟิร์มแวร์แล้ว มีข้อความ <code>waiting for download</code>
ได้รับจากบอร์ดผ่านทาง <strong>USB-to-Serial</strong> ให้กดปุ่มรีเซตเพื่อให้โปรแกรมเริ่มต้นทำงาน</p>
<p><img alt="" src="arduino_esp32c6-1.png" /></p>
<p>รูป: ตัวอย่างการเลือก <strong>Serial Port</strong> (เชื่อมต่อผ่าน <strong>USB-to-Serial Bridge</strong>)
สำหรับอัปโหลดไฟล์เฟิริม์แวร์ </p>
<p><img alt="" src="esp32c6_arduino_sysinfo.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุต</p>
<p>&nbsp;</p>
<hr />
<h2 id="2-led">&#9655; <strong>โค้ดตัวอย่างที่ 2:  การตรวจสอบสถานะลอจิกของปุ่มกดและเปลี่ยนสถานะลอจิกของ LED</strong><a class="headerlink" href="#2-led" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นการตรวจสอบสถานะลอจิกของปุ่มกด โดยจะใช้วงจรปุ่มกดและวงจร LED ที่นำมาต่อเพิ่มที่ขา
<strong>GPIO</strong> ของ <strong>ESP32-C6</strong></p>
<p>ในการตรวจสอบสถานะของปุ่มกด จะใช้วิธีเปิดการใช้งานอินเทอร์รัพท์ภายนอกที่ขาอินพุตสำหรับปุ่มกด
ซึ่งทำงานแบบ <strong>Active-Low</strong> เมื่อพบว่า มีการกดปุ่มแล้วปล่อย
จะเปลี่ยนสถานะลอจิกที่ขาเอาต์พุตสำหรับ <strong>LED</strong> หนึ่งครั้ง</p>
<pre><code class="language-c++">// Define the pin number for the LED.
const int LED_PIN = 10;
// Define the pin number for the button.
const int BTN_PIN = 11;

// Declare a variable to store the state of the LED.
bool led_state = 0;

void setup() {
  // Begin serial communication at a baud rate of 115200.
  Serial.begin(115200);
  // Set the LED pin as an output.
  pinMode( LED_PIN, OUTPUT );
  // // Set the button pin as an input with pull-up.
  pinMode( BTN_PIN, INPUT_PULLUP );
  // Attach an interrupt to the button pin 
  // that triggers on a rising edge.
  // Note: The ISR is implemented as an anonymous function.
  attachInterrupt( BTN_PIN, [](){
    // Use a static variable to store the time of 
    // the last state change.
    static uint32_t last_changed = 0;
    // Get the current time in msec.
    uint32_t now = millis();
    // Check if at least 10 milliseconds have passed 
    // since the last state change.
    if ( now - last_changed &gt;= 10 ) {
      // Toggle the state of the LED.
      digitalWrite( LED_PIN, led_state ^= 1 );
    }
    // Update the time of the last state change
    last_changed = now;
  }, RISING );
}

void loop() { 
}
</code></pre>
<p><img alt="" src="esp32c6_btn_led.jpg" /></p>
<p>รูป: การต่อวงจร <strong>Button</strong> และ <strong>LED</strong> บนเบรดบอร์ด </p>
<p>&nbsp;</p>
<p>ถ้าจะลองใช้ <strong>FreeRTOS</strong> เพื่อให้มีการสื่อสารจากฟังก์ชัน <strong>ISR
(Interrupt Service Routine)</strong> ไปยังการทาสก์หลัก (<strong>Main Task</strong>)
ซึ่งทำงานในฟังก์ชัน <code>loop()</code> เมื่อเกิดอินพุตจากการกดปุ่ม ก็มีแนวทางดังนี้</p>
<pre><code class="language-c++">const int LED_PIN = 10;
const int BTN_PIN = 11;

bool led_state = 0;
TaskHandle_t mainTaskHandle = NULL;

void notifyChange() {
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  // Notify the main task.
  vTaskNotifyGiveFromISR(mainTaskHandle, &amp;xHigherPriorityTaskWoken);
  if (xHigherPriorityTaskWoken == pdTRUE) {
    portYIELD_FROM_ISR();
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(BTN_PIN, INPUT_PULLUP);
  // Get the handle of the main task.
  mainTaskHandle = xTaskGetCurrentTaskHandle();
  // Attach the interrupt to the button pin
  attachInterrupt( BTN_PIN, [](){
    static uint32_t last_changed = 0;
    uint32_t now = millis();
    if ( now - last_changed &gt;= 10 ) {
      // Notify the main task.
      notifyChange();
    }
    last_changed = now;
  }, RISING);
}

void loop() {
  // A static variable used to count the button clicks.
  static uint32_t clicks = 0;
  // Wait for task notification from the ISR with timeout.
  if ( ulTaskNotifyTake(pdTRUE, pdMS_TO_TICKS(10))==pdTRUE) {
    // Toggle the LED state.
    digitalWrite(LED_PIN, led_state ^= 1);
    Serial.printf(&quot;LED state: %d, clicks: %lu\n&quot;, 
                  led_state, ++clicks);
  }
}
</code></pre>
<p>&nbsp;</p>
<p>การสื่อสารระหว่าง <strong>ISR</strong> และทาสก์หลัก ยังมีวิธีอื่นอีกเมื่อใช้งาน <strong>FreeRTOS</strong>
เช่น การใช้ <strong>Queue</strong> ตามตัวอย่างต่อไปนี้</p>
<pre><code class="language-c++">const int LED_PIN = 10;
const int BTN_PIN = 11;

bool led_state = 0;
TaskHandle_t mainTaskHandle = NULL;
QueueHandle_t eventQueue;

void notifyChange() {
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  // Notify the main task
  xQueueSendToBackFromISR(eventQueue, &amp;led_state,
                          &amp;xHigherPriorityTaskWoken);
  if (xHigherPriorityTaskWoken == pdTRUE) {
    portYIELD_FROM_ISR();
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(BTN_PIN, INPUT_PULLUP);
  // Get the handle of the main task.
  mainTaskHandle = xTaskGetCurrentTaskHandle();
  // Create an event queue with a capacity of 1.
  eventQueue = xQueueCreate(1, sizeof(bool));
  // Attach the interrupt to the button pin.
  attachInterrupt( BTN_PIN, []() {
    static uint32_t last_changed = 0;
    uint32_t now = millis();
    if ( now - last_changed &gt;= 10 ) {
      // Notify the main task.
      notifyChange();
    }
    last_changed = now;
  }, RISING);
}

void loop() {
  // A static variable used to count the button clicks.
  static uint32_t clicks = 0;
  // Wait for an event in the event queue (with a timeout).
  bool event;
  if (xQueueReceive(eventQueue,&amp;event,pdMS_TO_TICKS(10))==pdTRUE){
    // Toggle the LED state.
    digitalWrite(LED_PIN, event ^= 1);
    Serial.printf(&quot;LED state: %d, clicks: %lu\n&quot;, 
                  event, ++clicks);
  }  
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="3-led-pwm">&#9655; <strong>โค้ดตัวอย่างที่ 3: การปรับความสว่างของ LED ด้วยสัญญาณ PWM</strong><a class="headerlink" href="#3-led-pwm" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปสาธิตการใช้คำสั่งเพื่อปรับความสว่างของ <strong>LED</strong> โดยการสร้างสัญญาณ <strong>PWM</strong>
ที่สามารถปรับค่า <strong>Duty Cycle</strong> ของสัญญาณได้ และใช้วงจร <strong>LEDC / Timer</strong> 
ภายในชิป <strong>ESP32C6</strong> เพื่อสร้างสัญญาณดังกล่าว คำสั่งที่เกี่ยวข้องได้แก่</p>
<ul>
<li><code>analogWriteResolution(uint8_t pin, uint8_t resolution)</code></li>
<li><code>analogWriteFrequency(uint8_t pin, uint32_t freq)</code></li>
<li><code>analogWrite(uint8_t pin, int value)</code></li>
</ul>
<p>ในโค้ดตัวอย่างนี้ ได้กำหนดค่าความถี่ของสัญญาณ <strong>PWM</strong> ไว้เท่ากับ 1000Hz
และความละเอียดในการกำหนดค่าให้สัญญาณ <strong>PWM</strong> ไว้ที่ 8 บิต (สูงสุด)</p>
<pre><code class="language-c++">const uint8_t LED_PIN  = 10;
const uint8_t PWM_BITS = 8;
const uint32_t PWM_MAX_VALUE = ((1&lt;&lt;PWM_BITS)-1);
const uint32_t PWM_FREQ = 1000;

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;PWM LED Dimming&quot;);
  pinMode(LED_PIN, OUTPUT);
  analogWriteResolution( LED_PIN, PWM_BITS );
  analogWriteFrequency( LED_PIN, PWM_FREQ /*Hz*/ );
  analogWrite( LED_PIN, 0 );
}

void loop() {
  int value;
  for (int i=0; i &lt; (2*PWM_MAX_VALUE+1); i++){
    value = (i &gt;= PWM_MAX_VALUE) ? (2*PWM_MAX_VALUE-i) : i;
    // Write the new PWM value.
    analogWrite( LED_PIN, value );
    Serial.printf( &quot;PWM:%d\n&quot;, value );
    delay(8);
  }
}
</code></pre>
<p>การสร้างสัญญาณ <strong>PWM</strong> ถ้าไม่ใช้คำสั่ง <code>analogWrite()</code> ตามรูปแบบของ <strong>Arduino API</strong>
ก็มีคำสั่งอื่นให้ใช้งานได้เช่นกัน คำสั่งที่เกี่ยวข้องได้แก่</p>
<ul>
<li><code>ledcAttach(uint8_t pin, uint32_t freq, uint8_t resolution)</code></li>
<li><code>ledcWrite(uint8_t pin, uint32_t duty)</code></li>
<li><code>ledcRead(uint8_t pin)</code></li>
</ul>
<p>ในโค้ดตัวอย่างนี้ ได้กำหนดค่าความถี่ของสัญญาณ <strong>PWM</strong> ไว้เท่ากับ 1000Hz
และความละเอียดในการกำหนดค่าให้สัญญาณ <strong>PWM</strong> ไว้ที่ 10 บิต </p>
<pre><code class="language-c++">const uint8_t LED_PIN  = 10;
const uint8_t PWM_BITS = 10;
const uint32_t PWM_MAX_VALUE = ((1&lt;&lt;PWM_BITS)-1);
const uint32_t PWM_FREQ = 1000;

void initLEDC(void) {
  if (!ledcAttach(LED_PIN, PWM_FREQ, PWM_BITS)) {
    Serial.println( &quot;LEDC initialization failed!&quot; );
  } else {
    ledcWrite( LED_PIN, 0 ); 
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;PWM LED Dimming&quot;);
  pinMode(LED_PIN, OUTPUT);
  initLEDC();
}

void loop() {
  int value;
  for ( int i=0; i &lt; (2*PWM_MAX_VALUE+1); i++ ) {
    value = (i &gt;= PWM_MAX_VALUE) ? (2*PWM_MAX_VALUE-i) : i;
    // Write the new PWM value.
    ledcWrite( LED_PIN, value ); 
    delay(2);
    Serial.printf( &quot;PWM:%d (%d) \n&quot;, value, 
                   (int)ledcRead(LED_PIN) );
  }
}
</code></pre>
<p>&nbsp;</p>
<p>ถ้าต้องการลองใช้คำสั่งของ <strong>ESP-IDF v5.1</strong> ในกลุ่มคำสั่ง
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-reference/peripherals/ledc.html"><strong>LEDC API</strong></a> เช่น</p>
<ul>
<li><code>ledc_timer_config( ... )</code> ตั้งค่าสำหรับวงจรตัวนับเพื่อใช้งานกับ <strong>LEDC</strong> ความละเอียดในการนับ (จำนวนบิต) ความถี่ และแหล่งที่มาของสัญญาณ <strong>Clock</strong></li>
<li><code>ledc_channel_config( ... )</code> ตั้งค่าเลือกช่องสัญญาณของวงจร <strong>LEDC</strong></li>
<li><code>ledc_fade_func_install( ... )</code> เปิดการใช้งานโหมด <strong>Duty Cycle Fading</strong> เพื่อให้ปรับเพิ่มหรือลดค่า <strong>Duty Cycle</strong> ได้แบบอัตโนมัติ</li>
<li><code>ledc_cb_register( ... )</code> กำหนดฟังก์ชัน <strong>Callback</strong> เมื่อจบการทำงานของ <strong>Fading Function</strong></li>
<li><code>ledc_set_fade_with_time( ... )</code> กำหนดระยะเวลาในการทำงานของ <strong>Fading Function</strong></li>
<li><code>ledc_fade_start( ... )</code> เริ่มต้นการทำงานของ <strong>Fading Function</strong></li>
<li><code>ledc_set_duty( ... )</code> กำหนดค่า <strong>PWM Duty Cycle</strong> </li>
<li><code>ledc_update_duty( ... )</code> อัปเดตสัญญาณ <strong>PWM</strong> </li>
<li><code>ledc_get_duty( ... )</code> อ่านค่าของ  <strong>PWM Duty Cycle</strong> </li>
</ul>
<p>ก็มีตัวอย่างดังนี้</p>
<pre><code class="language-c++">#include &quot;driver/ledc.h&quot;
#include &quot;hal/ledc_types.h&quot;

#define LEDC_GPIO      (10)
#define LEDC_TIMER     (LEDC_TIMER_1)
#define LEDC_MODE      (LEDC_LOW_SPEED_MODE)
#define LEDC_CHANNEL   (LEDC_CHANNEL_2)

#define PWM_BITS       (LEDC_TIMER_10_BIT)
#define PWM_MAX_VALUE  ((1&lt;&lt;PWM_BITS)-1)
#define PWM_FREQ       (1000)

// This callback function will be called 
// when fade operation has ended.
static IRAM_ATTR bool cb_ledc_fade_end_event(
  const ledc_cb_param_t *param, void *user_arg )
{
  if (param-&gt;event == LEDC_FADE_END_EVT) {
    // Handle the event if necessary...
  }
  return false;
}

ledc_channel_config_t ledc_channel;
ledc_channel_config_t *ledc = NULL;

void initLEDC(void) {
  ledc_timer_config_t _ledc_timer = {
     .speed_mode = LEDC_MODE,     // low-speed timer mode 
     .duty_resolution = PWM_BITS, // resolution of PWM duty
     .timer_num = LEDC_TIMER,     // timer index
     .freq_hz = 1000,             // PWM frequency in Hz
     .clk_cfg = LEDC_AUTO_CLK,    // Auto select the source clk
  };
  // Set configuration of timer0 for high speed channels
  ledc_timer_config(&amp;_ledc_timer);

  ledc_channel_config_t _ledc_channel = {
    .gpio_num   = LEDC_GPIO,
    .speed_mode = LEDC_MODE,
    .channel    = LEDC_CHANNEL,
    .intr_type  = LEDC_INTR_FADE_END,
    .timer_sel  = LEDC_TIMER,
    .duty       = 0,
    .hpoint     = 0,
    .flags = { .output_invert = 1 },
  };

  ledc_channel = _ledc_channel;
  ledc_channel_config(&amp;ledc_channel);
  ledc = &amp;ledc_channel;

  // Initialize the LEDC fade service.
  ledc_fade_func_install(0);
  ledc_cbs_t callbacks = {
    .fade_cb = cb_ledc_fade_end_event
  };
  ledc_cb_register( ledc-&gt;speed_mode, ledc-&gt;channel, 
                    &amp;callbacks, (void *)NULL );
}

void setup() {
  Serial.begin(115200);
  initLEDC();
}

void demo1() {
  Serial.printf(&quot;LEDC: fade up to %d.\n&quot;, PWM_MAX_VALUE );
  ledc_set_fade_with_time(
    ledc-&gt;speed_mode, ledc-&gt;channel, PWM_MAX_VALUE, 2000 
  );
  ledc_fade_start(
    ledc-&gt;speed_mode, ledc-&gt;channel, LEDC_FADE_NO_WAIT
  );

  Serial.printf(&quot;LEDC: fade down to 0.\n&quot;);
  ledc_set_fade_with_time(
    ledc-&gt;speed_mode, ledc-&gt;channel, 0, 2000
  );
  ledc_fade_start(
    ledc-&gt;speed_mode, ledc-&gt;channel, LEDC_FADE_NO_WAIT
  );
}

void demo2(){
  int value;
  Serial.printf(&quot;LEDC: set the duty cycle.\n&quot; );
  for ( int i=0; i &lt; (2*PWM_MAX_VALUE+1); i++ ) {
    value = (i &gt;= PWM_MAX_VALUE) ? (2*PWM_MAX_VALUE-i) : i;
    ledc_set_duty(ledc-&gt;speed_mode, ledc-&gt;channel, value);
    ledc_update_duty(ledc-&gt;speed_mode, ledc-&gt;channel);
    delay(2);
    value = ledc_get_duty(ledc-&gt;speed_mode, ledc-&gt;channel);
    Serial.printf( &quot;PWM:%d\n&quot;, value );
  }
}

void loop() {
  demo1(); delay(2000);
  demo2(); delay(2000);
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="4-i2c-master">&#9655; <strong>โค้ดตัวอย่างที่ 4: การสื่อสารด้วย I2C Master</strong><a class="headerlink" href="#4-i2c-master" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไป สาธิตการใช้งาน <strong>I2C</strong> ของ <strong>ESP32-C6</strong> ในโหมด <strong>I2C Master</strong>
โดยเลือกใช้ขา <strong>GPIO6</strong> และ <strong>GPIO7</strong> สำหรับสัญญาณ <strong>I2C SDA</strong> และ <strong>I2C SCL</strong> ตามลำดับ
อุปกรณ์ที่นำมาต่อใช้งานคือ โมดูลเซนเซอร์  <strong>AHT2x (Temperature &amp; Humdity Sensor)</strong>
ซึ่งมีหมายเลขแอดเดรส <code>0x38</code> โค้ดตัวอย่างสาธิตการตรวจสอบอุปกรณ์ที่เชื่อมต่อกับบัส <strong>I2C</strong> </p>
<pre><code class="language-c++">#include &quot;Wire.h&quot;

#define I2C_SDA_PIN   (6)
#define I2C_SCL_PIN   (7)
#define INTERVAL_MSEC (4000)

void i2c_scan();

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;\n\n\n&quot;);
  // Initialize the I2C bus as master.
  Wire.begin( I2C_SDA_PIN, I2C_SCL_PIN );
}

void loop() {
  static uint32_t ts = 0;
  uint32_t now = millis();
  if ( now - ts &gt;= INTERVAL_MSEC ) {    
    ts = now;
    i2c_scan(); // Scan I2C slave devices.
  }
}

#define LINE_SEP  &quot;------------------&quot;

void i2c_scan() {
  char sbuf[32];
  int n_devices = 0;
  Serial.println( &quot;Scanning I2C bus...&quot; );
  Serial.print( &quot;   &quot; );
  for ( uint8_t col=0; col &lt; 16; col++ ) {
    sprintf( sbuf, &quot;%3x&quot;, col );
    Serial.print( sbuf );
  }
  Serial.println( &quot;&quot; );
  uint8_t addr=0;
  for( uint8_t row=0; row &lt; 8; row++ ) {
    sprintf( sbuf, &quot;%02x:&quot;, row &lt;&lt; 4 );
    Serial.print( sbuf );
    for ( uint8_t col=0; col &lt; 16; col++ ) {
      if ( row==0 &amp;&amp; addr&lt;=1 ) {
        Serial.print(&quot;   &quot;);
      } else {
        Wire.beginTransmission( addr );
        if ( Wire.endTransmission() &gt; 0 ) {
          Serial.print( &quot; --&quot; );
        } else {
          sprintf( sbuf, &quot; %2x&quot;, addr );
          Serial.print( sbuf );
          n_devices++;
        }
      }
      addr++;
    }
    Serial.println( &quot;&quot; );
  } // end for
  Serial.println( LINE_SEP LINE_SEP LINE_SEP );
  Serial.flush();
}
</code></pre>
<p><img alt="" src="esp32c6_i2c_scan.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุต</p>
<p>ถ้าจะลองใช้คำสั่งตามรูปแบบของ <strong>ESP-IDF</strong> สำหรับ <strong>I2C Driver</strong>
ให้ศึกษาได้จาก <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c6/api-reference/peripherals/i2c.html"><strong>ESP32-C6 Peripherals API for I2C</strong></a></p>
<p>&nbsp;</p>
<hr />
<h2 id="5-aht2x">&#9655; <strong>โค้ดตัวอย่างที่ 5: การอ่านค่าจากโมดูลเซนเซอร์ AHT2x</strong><a class="headerlink" href="#5-aht2x" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างถัดไปสาธิตการติดตั้งและใช้งานไลบรารี เพื่ออ่านค่าจากโมดูล <strong>AHT2x</strong> ที่เชื่อมต่อด้วยบัส <strong>I2C</strong>
โดยได้เลือกใช้ไลบรารี <a href="https://github.com/adafruit/Adafruit_AHTX0"><code>Adafruit_AHTX0</code></a>
ของบริษัท <strong>Adafruit</strong></p>
<pre><code class="language-c++">#include &lt;Adafruit_AHTX0.h&gt;

#define I2C_SDA_PIN   (6)
#define I2C_SCL_PIN   (7)
#define INTERVAL_MSEC (2000)

// Create an instance of the Adafruit_AHTX0 class.
Adafruit_AHTX0 aht;

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;\n\n\n&quot;);
  // Initialize the I2C bus as a master.
  Wire.begin( I2C_SDA_PIN, I2C_SCL_PIN, 400000 /*speed*/ );
  Serial.println( &quot;Adafruit AHT10/AHT20 library demo!&quot; );
  if (!aht.begin()) {
    Serial.println(&quot;AHT2x initialization failed...&quot;);
    while (1) delay(10);
  }
  Serial.println(&quot;Start reading the AHT2x sensor...&quot;);
}

void loop() {
  static uint32_t ts;
  uint32_t now = millis();
  if ( now - ts &gt;= INTERVAL_MSEC ) {    
    ts = now;
    sensors_event_t humidity, temp;
    if ( aht.getEvent(&amp;humidity, &amp;temp) ) {
      Serial.printf( &quot;T: %.1f deg.C, H: %.1f %%RH\n&quot;, 
                (float)temp.temperature,
                (float)humidity.relative_humidity );
    } else { // error
      Serial.printf( &quot;AHT2x reading error!\n&quot; );
    }
  }
}
</code></pre>
<p><img alt="" src="esp32c6_aht2x_adafruit.png" /></p>
<p>รูป: ตัวอย่างการติดตั้งไลบรารี  <code>Adafruit_AHTX0</code></p>
<p><img alt="" src="esp32c6_aht2x_output.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุต</p>
<p><img alt="" src="esp32c6_aht2x.jpg" /></p>
<p>รูป: ตัวอย่างการต่อวงจรเพื่อใช้งานโมดูล <strong>AHT21</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="6-ws2812-rgb-led">&#9655; <strong>โค้ดตัวอย่างที่ 6: การกำหนดค่าสีของโมดูล WS2812 RGB LED</strong><a class="headerlink" href="#6-ws2812-rgb-led" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปสาธิตการเขียนโค้ดเพื่อกำหนดค่าสีให้กับ <strong>WS2812 RGB LED</strong> (จำนวน 1 ดวง)
ที่ต่อกับขา <strong>GPIO8</strong> และมีการใช้งานปุ่มกด <strong>BOOT</strong> (ขา <strong>GPIO9</strong>)
เพื่อเปลี่ยนสีของ <strong>RGB</strong> ตามค่าสี (24 บิต) ที่ได้มีการกำหนดไว้ในอาร์เรย์</p>
<p>การกำหนดค่าสี 24 บิต ต่อหนึ่งพิกเซล จะต้องมีการสร้างสัญญาณพัลส์ โดยใช้วงจร <strong>RMT</strong>
และความกว้างของพัลส์ช่วงที่เป็น <strong>High</strong> และ <strong>Low</strong> จะเป็นตัวกำหนดค่าบิตเป็น
'0' หรือ '1' ตามพารามิเตอร์เชิงเวลาของบิตต่อไปนี้</p>
<ul>
<li>T0H = '0' bit high time</li>
<li>T0L = '0' bit low time</li>
<li>T1H = '1' bit high time</li>
<li>T1L = '1' bit low time</li>
</ul>
<p>โมเดล <strong>WS2812</strong> และ <strong>WS2812B</strong> มีค่าพารามิเตอร์เชิงเวลาแตกต่างกัน
(และมีค่าความคลาดเคลื่อนได้ในช่วงที่กำหนดไว้ตามเอกสารของผู้ผลิต)</p>
<ul>
<li><strong>WS2812</strong> (1.25us bit time, 800Kbps)<ul>
<li>'0' bit: T0H = 0.35us, T1L = 0.8us</li>
<li>'1' bit: T1H = 0.70us, T1L = 0.6us</li>
</ul>
</li>
<li><strong>WS2812b</strong>: (1.25us bit time, 800Kbps)<ul>
<li>'0' bit: T0H = 0.40us, T0L = 0.85us</li>
<li>'1' bit: T1H = 0.80us, T1L = 0.45us</li>
</ul>
</li>
</ul>
<p>คำสั่งที่เกี่ยวข้องกับการใช้งานวงจร <strong>RMT</strong> สำหรับการสร้างสัญญาณเอาต์พุตให้กับ <strong>WS2812</strong> ได้แก่</p>
<ul>
<li><code>rmtInit()</code></li>
<li><code>rmtWrite()</code></li>
</ul>
<pre><code class="language-c++">const int BTN_PIN = 9;    // onboard BOOT button 
const int WS2812_PIN = 8; // onboard RGB LED (single pixel)

const uint32_t NUM_RGB_BITS = 24;  // 24 bits per RGB LED
rmt_data_t led_data[NUM_RGB_BITS];

const uint32_t COLORS [] = {
   0x00001f, // Greeen
   0x001f00, // Red
   0x1f0000, // Blue
   0x000000  // OFF
};
const uint32_t NUM_COLORS = sizeof(COLORS)/sizeof(uint32_t);

// FreeRTOS task handle
TaskHandle_t buttonTask;

void setColor( uint32_t color ) {
  for (uint32_t i=0; i &lt; 24; i++) {
    if ( (color &gt;&gt; (24-i-1)) &amp; 1 ) {
      led_data[i].level0 = 1; // T1H
      led_data[i].duration0 = 8;
      led_data[i].level1 = 0; // T1L
      led_data[i].duration1 = 4;
    } else {
      led_data[i].level0 = 1; // T0H
      led_data[i].duration0 = 4;
      led_data[i].level1 = 0; // T0L
      led_data[i].duration1 = 8;
    }
  }
  rmtWrite(WS2812_PIN, led_data, NUM_RGB_BITS, RMT_WAIT_FOR_EVER);
}

// Function to handle button press
void buttonAction(void *pvParameters) {
  (void)pvParameters;
  uint32_t index = NUM_COLORS-1;
  while (1) {
    // Wait for task notification.
    ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
    index = (index+1) %  NUM_COLORS;
    Serial.printf( &quot;Button pressed! (#%lu)\n&quot;, index );
    setColor( COLORS[index] );
  }
}

void setup() {
  Serial.begin( 115200 );
  Serial.println( &quot;ESP32-C6 FreeRTOS Demo...&quot; );
  pinMode( BTN_PIN, INPUT_PULLUP );

  // Initialize the RMT TX driver.
  if (!rmtInit(WS2812_PIN, RMT_TX_MODE, RMT_MEM_NUM_BLOCKS_1, 10000000)) {
    Serial.println(&quot;RMT TX initialization failed\n&quot;);
  }
  setColor(0x7f7f7f);
  delay(500);
  setColor(0);

  // Attach an external interrupt to the button pin.
  attachInterrupt( digitalPinToInterrupt(BTN_PIN), [] {
    static uint32_t last_action = 0;
    uint32_t now = millis();
    if ( now - last_action &gt;= 10 &amp;&amp; digitalRead(BTN_PIN)==HIGH ) {
      last_action = now;
      // Send a task notification to the button task.
      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
      vTaskNotifyGiveFromISR( buttonTask, &amp;xHigherPriorityTaskWoken );
      if (xHigherPriorityTaskWoken==pdTRUE) {
        portYIELD_FROM_ISR();
      }
    }
  }, RISING);

  // Create the button task.
  xTaskCreate(
     buttonAction,   // Task function
     &quot;ButtonTask&quot;,   // Task name
     2048,           // Stack size (words)
     NULL,           // Task input parameter
     1,              // Task priority
     &amp;buttonTask     // Task handle
  );
}

void loop() {
}
</code></pre>
<p>ดูตัวอย่างการเขียนโค้ดเพื่อใช้งาน <strong>RMT</strong> ได้จาก</p>
<p><a href="https://github.com/espressif/arduino-esp32/tree/master/libraries/ESP32/examples/RMT"><code>https://github.com/espressif/arduino-esp32/.../libraries/ESP32/examples/RMT/</code></a></p>
<p>&nbsp;</p>
<hr />
<h2 id="7-wifi-ntp-server">&#9655; <strong>โค้ดตัวอย่างที่ 7: การเชื่อมต่อผ่าน WiFi ไปยัง NTP Server</strong><a class="headerlink" href="#7-wifi-ntp-server" title="Permanent link">#</a></h2>
<p>ตัวอย่างถัดไปเป็นการเขียนโค้ดเพื่อเชื่อมต่อผ่าน <strong>WiFi</strong> เพื่อให้ <strong>ESP32C6</strong>
ปรับเวลาของระบบ <strong>RTC</strong> ให้ตรงกับเวลาของ  <strong>NTP Server</strong>
โดยได้ทดลองใช้ไลบรารีที่มีชื่อว่า <a href="https://github.com/arduino-libraries/NTPClient"><code>NTPClient.h</code></a></p>
<pre><code class="language-c++">#include &lt;WiFi.h&gt;
#include &lt;WiFiUdp.h&gt;
#include &lt;NTPClient.h&gt; // &quot;NTPClient by Fabrice Weinberg&quot;
#include &quot;Secret.h&quot;

const char *DAYS_OF_WEEK[7]={
   &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, 
   &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;
};
const char *MONTHS[12]={
  &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, 
  &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;
};

// NTP Servers:
const char* NTP_SERVER = &quot;th.pool.ntp.org&quot;;
const int   NTP_PORT = 123;

WiFiUDP wifiUDP; // Use a UDP client  to connect to the NTP server.
NTPClient timeClient( wifiUDP, NTP_SERVER, NTP_PORT );

void connectWifi() {
  WiFi.disconnect();
  WiFi.mode(WIFI_OFF);
  delay(10);
  WiFi.mode(WIFI_STA);
  WiFi.setTxPower(WIFI_POWER_19_5dBm);
  // Connect to Wi-Fi
  WiFi.begin(WIFI_SSID, WIFI_PASSWD);
  Serial.println(&quot;Connecting to WiFi...&quot;);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(500);
  }
  Serial.println(&quot;\nConnected to WiFi&quot;);
}

void setup() {
  Serial.begin(115200);
  connectWifi();

  // Connect to the NTP Server.
  timeClient.begin();
  // synchronize with the NTP server to update the date and time.
  if (timeClient.update()) { // OK
    // Time synchronization successful
    Serial.println(&quot;Time synchronized: &quot; + timeClient.getFormattedTime());
    timeClient.setTimeOffset( 7*60*60 /*sec*/ ); // UTC+7 (Bangkok)
    Serial.println( timeClient.getFormattedTime() );
  } 
  else {
    // Time synchronization failed.
    Serial.println(&quot;Cannot synchronize with NTP!&quot;);
  }
}

void showDateTime() {
  //Serial.println( timeClient.getFormattedTime() );
  time_t epochTime = timeClient.getEpochTime();
  Serial.printf( &quot;Epoch time since Jan 1, 1970: %llu sec\n&quot;, epochTime );

  struct tm timeInfo;
  localtime_r(&amp;epochTime, &amp;timeInfo);
  // Extract the month and year
  int dayOfMonth = timeInfo.tm_mday; // Day of the month (1-31)
  int month = timeInfo.tm_mon ;      // Month (0-11)
  int year  = timeInfo.tm_year + 1900; // Year (years since 1900)
  // The week day (0 to 6) starting on Sunday
  int wday  = timeClient.getDay(); 
  String dateString;
  dateString += DAYS_OF_WEEK[wday];
  dateString += &quot; &quot;;
  dateString += String(MONTHS[month]);
  dateString += &quot; &quot;;
  dateString +=  String(dayOfMonth);
  dateString += &quot;, &quot;;
  dateString += String(year);
  dateString += &quot; &quot;;
  Serial.print( dateString );
  int hh = timeClient.getHours(); // (0 to 23) in 24 hour format
  int mm = timeClient.getMinutes(); // (0 to 59)
  int ss = timeClient.getSeconds(); // (0 t0 59)
  Serial.printf(&quot;%02d:%02d:%02d\n\n&quot;, hh, mm, ss );
}

void loop() {
  static uint32_t ts = 0;
  uint32_t now = millis();
  if (now - ts &gt;= 1000) {
    ts = now;
    showDateTime();
  }
}
</code></pre>
<p>การตั้งค่าชื่อ <strong>SSID</strong> และรหัสผ่าน จะอยู่ในไฟล์ <code>Secret.h</code></p>
<p><strong>File:</strong> <code>Secret.h</code></p>
<pre><code class="language-c++">const char* WIFI_SSID   = &quot;YOUR_WIFI_SSID&quot;;
const char* WIFI_PASSWD = &quot;YOUR_WIFI_PASSWORD&quot;;
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="8-adc">&#9655; <strong>โค้ดตัวอย่างที่ 8: การอ่านค่าสัญญาณแอนะล็อกด้วย ADC</strong><a class="headerlink" href="#8-adc" title="Permanent link">#</a></h2>
<p>คำสั่งที่เกี่ยวข้องกับ <strong>ADC</strong> (ดูได้จาก <a href="https://github.com/espressif/arduino-esp32/blob/master/cores/esp32/esp32-hal-adc.h"><code>esp32-hal-adc.h</code></a>) เช่น</p>
<ul>
<li><code>analogReadResolution( ... )</code> กำหนดความละเอียดของข้อมูล (จำนวนบิต) ที่ได้จาก <strong>ADC</strong></li>
<li><code>analogSetPinAttenuation( ... )</code> กำหนดอัตราการลดทอนสัญญาณอินพุตของแต่ละช่องอินพุต</li>
<li><code>analogReadMilliVolts( ... )</code> อ่านค่าจาก <strong>ADC</strong> ซึ่งจะได้ค่าตัวเลขในหน่วยเป็นมิลลิโวลต์</li>
</ul>
<pre><code class="language-c++">const int ADC_PIN = 4;  // ADC1_CH4 / GPIO4 pin

// Initialize the ADC input channel.
void initADC() { 
  // Set ADC resolution to 12 bits
  analogReadResolution( 12 );
  // Set attenuation level to 11 dB.
  analogSetPinAttenuation( ADC_PIN, ADC_11db ); 
}

void setup() {
  Serial.begin(115200);
  initADC(); // Initialize the ADC.
 }

void loop() {
  uint16_t value = (uint16_t)analogReadMilliVolts( ADC_PIN );
  Serial.printf(&quot;S:%u,MIN:0,MAX:3300\n&quot;, value );
  delay(100);
}
</code></pre>
<p><img alt="" src="esp32c6_adc_plot.png" /></p>
<p>รูป: ตัวอย่างการแสดงข้อมูลที่ได้รับใน <strong>Arduino Serial Plotter</strong>
เมื่ออ่านค่าสัญญาณแอนะล็อกจากโมดูลเซนเซอร์แสง</p>
<p>&nbsp;</p>
<hr />
<h2 id="9-adc-timer">&#9655; <strong>โค้ดตัวอย่างที่ 9: การอ่านค่าสัญญาณแอนะล็อกด้วยอัตราคงที่โดยใช้ ADC และ Timer</strong><a class="headerlink" href="#9-adc-timer" title="Permanent link">#</a></h2>
<p>ตัวอย่างโค้ดถัดไปเป็นการเขียนโค้ดเพื่ออ่านค่าสัญญาณอินพุตแบบแอนะล็อก โดยใช้หนึ่งช่องสัญญาณอินพุต
ของวงจร <strong>ADC (Analog-to-Digital Converter)</strong> ภายในชิป <strong>ESP32C6</strong>
(เลือกใช้ขา <strong>ADC1_CH4 / GPIO4</strong>) </p>
<p>การอ่านค่าอินพุต จะใช้วงจร <strong>Hardware Timer</strong> เป็นตัวกำหนดอัตราการอ่านให้คงที่ โดยกำหนดไว้
<strong>10000Hz</strong> ค่าที่อ่านได้ในแต่ละครั้งจะได้ค่าเป็นเลขจำนวนเต็มหน่วยเป็นมิลลิโวลต์
ไม่เกิน <strong>3300mV</strong> และจะบันทึกข้อมูลลงในอาร์เรย์ขนาด 1024  เมื่อได้ข้อมูลครบแล้ว จะส่งข้อมูลออกทาง
<strong>Serial</strong> (ตั้งค่า <strong>Baudrate 921600</strong>) เป็นข้อความ
หนึ่งค่าตัวเลขต่อหนึ่งบรรทัด ไปยังคอมพิวเตอร์ แล้วเริ่มต้นขั้นตอนซ้ำใหม่ในรอบถัดไป</p>
<pre><code class="language-c++">const int ADC_PIN = 4;   // ADC1_CH4 / GPIO4 pin

bool sampling = true;
uint32_t sample_index = 0;

const uint32_t Fs = 10000; // Sampling frequency (Hz)
const uint32_t N  = 1024;  // Number of samples
uint32_t sample_count = 0;
uint16_t samples[N];

TaskHandle_t mainTaskHandle = NULL;

void notifyTask() {
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  // Notify the main task.
  vTaskNotifyGiveFromISR(mainTaskHandle, &amp;xHigherPriorityTaskWoken);
  if (xHigherPriorityTaskWoken == pdTRUE) {
    portYIELD_FROM_ISR();
  }
}

//----------------------------------------------------------------
// Callback function of the hardware timer.
void IRAM_ATTR timer_callback() {
  if (!sampling)
      return;
  // Read the ADC input channel.
  uint16_t value = (uint16_t)analogReadMilliVolts( ADC_PIN );
  samples[sample_count++] = value;
  if ( sample_count == N ) {
    sampling = false;  // Pause the ADC reading.
    sample_count = 0;  // Reset the sample count.
    notifyTask();      // Notify the main task.
  }
}

// Initialize the ADC input channel.
void initADC() { 
  // Set ADC resolution to 12 bits
  analogReadResolution( 12 );
  // Set attenuation level to 11 dB.
  analogSetPinAttenuation( ADC_PIN, ADC_11db ); 
}

// Initialize the hardware timer.
void initTimer( uint32_t hw_timer_unit=0 ) {
  static hw_timer_t *timer = NULL;
  timer = timerBegin( 1000000UL ); // 1MHz (1us tick)
  timerWrite(timer, 0);
  // Attach the callback function (ISR) to the timer
  timerAttachInterrupt( timer, &amp;timer_callback );
  timerAlarm(timer, (1000000UL/Fs) /*interval*/,
             true /*reload*/, 0 /*reload value*/);
  timerRestart(timer);
}

void setup() {
  Serial.begin(921600);
  Serial.setTxBufferSize(256);
  Serial.flush();
  // Get the handle of the main task.
  mainTaskHandle = xTaskGetCurrentTaskHandle();  
  initADC();   // Initialize the ADC.
  initTimer(); // Initialize the hardware timer.
}

void loop() {
  if ( ulTaskNotifyTake(pdTRUE,pdMS_TO_TICKS(5))==pdTRUE) {
    for ( uint32_t i=0; i &lt; N; i++ ) {
      // Send the sample as a string to serial.
      Serial.printf(&quot;S:%u,MIN:0,MAX:3300\n&quot;, samples[i]);
    }
    Serial.flush();
    sampling = true;
  }
}
</code></pre>
<p>สัญญาณอินพุตแบบแอนะล็อก อาจได้จากเครื่องกำเนิดสัญญาณ (<strong>Function Generator</strong>)
หรือโมดูลเซนเซอร์ที่ให้เอาต์พุตเป็นสัญญาณแอนะล็อก เช่น โมดูลไมโครโฟนขยายเสียง <strong>MAX4466</strong> หรือ <strong>MAX9814</strong> </p>
<p><img alt="" src="esp32c6_adc_serial_plotter.png" /></p>
<p>รูป: ตัวอย่างการแสดงข้อมูลที่ได้รับใน <strong>Arduino Serial Plotter</strong>
เมื่ออ่านค่าสัญญาณแอนะล็อกจากโมดูลไมโครโฟนขยายเสียง</p>
<p>&nbsp;</p>
<hr />
<h2 id="_1">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้ได้นำเสนอการใช้งานบอร์ดไมโครคอนโทรลเลอร์ <strong>ESP32-C6</strong>
และตัวอย่างการเขียนโค้ดด้วย <strong>Arduino Sketch</strong> และใช้
<strong>Arduino-ESP32 Core v3.0.0</strong> เพื่อทดสอบการทำงานของฮาร์ดแวร์และซอฟต์แวร์ในเบื้องต้น</p>
<p><strong>บทความที่เกี่ยวข้อง</strong></p>
<ul>
<li><a href="../esp32-c6_esp-idf/">การเขียนโปรแกรม <strong>ESP32-C6 / ESP-IDF (WSL2 Ubuntu)</strong></a></li>
</ul>
<p>&nbsp;</p>
<hr />
<p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>
<p>Created: 2023-11-18 | Last Updated: 2023-11-20</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2023 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
