<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/due/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>การใช้งานบอร์ด Arduino Due Rev.3 - IoT Engineering Education</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../css/extra.css" rel="stylesheet">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/julia.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-966FQ6RN6W');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#arduino-due-rev3" class="nav-link">การใช้งานบอร์ด Arduino Due Rev.3</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#arduino-due-rev3_1" class="nav-link">&#9655; แนะนำบอร์ด Arduino Due Rev.3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#arduino-ide" class="nav-link">&#9655; การเขียนโปรแกรมด้วย Arduino IDE</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#led-push-button-external-interrupt" class="nav-link">&#9655; การใช้งาน LED + Push Button + External Interrupt</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#digital-io-8x-led-bar" class="nav-link">&#9655; การใช้งานขา Digital I/O: 8x LED Bar</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pwm" class="nav-link">&#9655; การสร้างสัญญาณ PWM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#adc-dac" class="nav-link">&#9655; การใช้งาน ADC และ DAC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#i2c" class="nav-link">&#9655; การใช้งาน I2C</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hardware-timer" class="nav-link">&#9655; การใช้ Hardware Timer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hardware-timer-dac-adc" class="nav-link">&#9655; การใช้งาน Hardware Timer + DAC + ADC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#nativeusb-port-programming-port" class="nav-link">&#9655; การใช้งาน NativeUSB Port และ Programming Port</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#freertos" class="nav-link">&#9655; การเขียนโปรแกรมด้วย FreeRTOS</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#freertos-demo-led-blink" class="nav-link">&#9655; FreeRTOS Demo: LED Blink</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#freertos-demo-push-button-interrupt-task-notification" class="nav-link">&#9655; FreeRTOS Demo: Push Button + Interrupt + Task Notification</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">&#9655; กล่าวสรุป</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="arduino-due-rev3">การใช้งานบอร์ด Arduino Due Rev.3<a class="headerlink" href="#arduino-due-rev3" title="Permanent link">#</a></h1>
<hr />
<h2 id="arduino-due-rev3_1">&#9655; <strong>แนะนำบอร์ด Arduino Due Rev.3</strong><a class="headerlink" href="#arduino-due-rev3_1" title="Permanent link">#</a></h2>
<p>บอร์ด <a href="https://docs.arduino.cc/hardware/due"><strong>Arduino Due Rev.3</strong></a>
และการเรียนรู้การเขียนโปรแกรมไมโครคอนโทรลเลอร์ 32 บิต</p>
<ul>
<li>บอร์ด <strong>Due</strong> เริ่มมีการใช้งานตั้งแต่ปีค.ศ. 2012 แต่ยังมีการจำหน่ายโดย <strong>Arduino.cc</strong> </li>
<li>บอร์ด <strong>Due</strong> ใช้ตัวประมวลผลขนาด 32 บิต (<strong>ARM Cortex-M3</strong>)
ความเร็วสูงสุด <strong>84 MHz</strong> แต่ไม่มี <strong>FPU</strong> (<em>Floating-point Unit</em>)</li>
<li>ชิปทำงานด้วยแรงดันไฟเลี้ยง <strong>3.3V (I/O Voltage)</strong> </li>
<li>ภายในมีหน่วยความจำ <strong>Flash</strong> สำหรับ <strong>Program Memory</strong> ขนาด 512 KB (2 x 256 KB) 
และ <strong>SRAM</strong> สำหรับ <strong>Data Memory</strong> ขนาด 96 KB</li>
<li>มีวงจรในส่วนที่เรียกว่า <strong>Memory Protection Unit (MPU)</strong> 
เหมาะสำหรับการทำงานที่ใช้ระบบปฏิบัติการเวลาจริง (<strong>RTOS</strong>) เช่น <strong>FreeRTOS (open source)</strong> </li>
<li>ชิปมีขา <strong>I/O</strong> จำนวนมาก (ตัวถังแบบ <strong>144-pin LQFP</strong>) และบอร์ดมีขนาด หรือ  <strong>Form Factor</strong> เท่ากับ <strong>Arduino Mega 2560</strong></li>
<li>มีวงจรภายใน (<strong>On-chip Peripherals</strong>) ต่าง ๆ หลายชนิดที่มักพบเห็นได้ในไมโครคอนโทรลเลอร์ประเภท </li>
<li>ภายในชิปมี <strong>BootROM</strong> ขนาด <strong>16KB</strong> รองรับการเชื่อมต่อด้วย <strong>UART</strong> และ <strong>USB</strong></li>
<li>อัปโหลดโปรแกรมได้ โดยใช้ <strong>JTAG/SWD</strong> หรือ ผ่าน 
<strong>USB / Serial (SAM-BA bootloader / BOSSA)</strong></li>
<li>สามารถเขียนโปรแกรมได้ในภาษา <strong>C/C++</strong> โดยใช้โปรแกรมอย่างเช่น <strong>Arduino IDE (open source)</strong> 
 หรือ <strong>Microchip Studio IDE</strong> หรือซอฟต์แวร์อื่น ๆ (ใช้ร่วมกับ <strong>GCC-ARM Toolchain</strong>)</li>
<li>บอร์ด <strong>Due</strong> มีคอนเนกเตอร์แบบ <strong>MicroUSB</strong> จำนวน 2 ชุด จำแนกเป็น<ul>
<li><strong>USB1</strong> (อยู่ใกล้ปุ่มรีเซต): <strong>Native USB Port</strong> สำหรับการใช้งาน <strong>USB-CDC</strong> (ใช้ค่า <strong>Baudrate</strong> ได้สูงถึง 2,000,000) หรือ <strong>USB HID</strong> หรือ 
<a href="https://www.arduino.cc/reference/en/libraries/usbhost/"><strong>USB Host</strong></a></li>
<li><strong>USB2</strong>: <strong>Programming Port</strong> ซึ่งเชื่อมต่อผ่านชิปไมโครคอนโทรลเลอร์ <strong>ATmega32U2</strong>
ซึ่งทำหน้าที่เป็น <strong>USB-to-Serial Bridge</strong> ให้กับชิป <strong>ATSAM3x8e</strong></li>
</ul>
</li>
<li>มีวงจร <strong>Crystal Oscillator</strong> ความถี่ <strong>12MHz</strong> และ <strong>32.768kHz</strong></li>
<li>ปุ่ม <strong>Erase</strong> เมื่อกดปุ่มแล้ว หน่วยความจำแฟลชของ <strong>ATSAM3X8E</strong> จะถูกลบทั้งหมด
(จะถูกเขียนทับด้วยข้อมูลที่มีค่า <strong>0xFF</strong> ในทุกแอดเดรสของหน่วยความจำ)</li>
<li>ถ้ามีการเชื่อมต่อผ่าน <strong>Serial</strong> ด้วย <strong>Baudrate</strong> เท่ากับ <strong>1200</strong>
เฟิร์มแวร์ <strong>Atmel SAM-BA Bootloader</strong> จะทำงานอัตโนมัติ 
และลบข้อมูลหน่วยความจำแฟลช  (ให้ผลเหมือนการปุ่ม <strong>Erase</strong>) ก่อนการอัปโหลด <strong>Arduino Sketch</strong> ทุกครั้ง</li>
<li>ใช้ไฟเลี้ยงจากพอร์ต <strong>USB (5V)</strong> และมี <strong>Polyfuse</strong> ขนาด <strong>500mA</strong> ป้องกันการใช้กระแสเกิน</li>
<li>ขา <strong>VIN</strong> รับแรงดันอินพุต <strong>DC</strong> ได้ในช่วง <strong>7-12V</strong></li>
<li>ขา <strong>3.3V</strong> จ่ายกระแสสูงสุดได้ <strong>800 mA</strong> (ใช้ไอซีควบคุมแรงดัน <strong>NCP1117ST-3.3V</strong>)</li>
<li>ขา <strong>5V</strong> จ่ายกระแสสูงสุดได้ <strong>800 mA</strong> (ใช้ไอซีควบคุมแรงดัน <strong>LM2732 Switching Regulator</strong>)</li>
<li>สามารถเลือกใช้บอร์ด <strong>Arduino Due (Clone)</strong> ที่มีการผลิตจากจีน มีราคาถูกกว่า</li>
</ul>
<p><strong>คำเตือน:</strong></p>
<ul>
<li>ในการใช้งาน <strong>DAC0</strong> และ <strong>DAC1</strong> เพื่อสร้างสัญญาณแอนะล็อก-เอาต์พุต 
แนะนำให้ต่อตัวต้านทานอนุกรม มีค่าอย่างน้อย <strong>1.2k</strong> โอห์ม ที่ขาดังกล่าว ก่อนนำไปใช้เป็นเอาต์พุต
เพื่อป้องกันการจ่ายกระแสเกิน ซึ่งจะทำให้วงจรภาคเอาต์พุตของ <strong>DAC</strong> ภายในชิป <strong>SAM3X8E</strong> ชำรุดเสียหายได้</li>
<li>ขา <strong>DAC0</strong> และ <strong>DAC1</strong> เมื่อใช้เป็นขาแอนะล็อก-เอาต์พุต
จะมีแรงดันไฟฟ้าอยู่ในช่วง  <strong>0.55V</strong> ถึง <strong>2.75V</strong> เท่านั้น (ไม่ใช่ <strong>Rail-to-Rail</strong>
ระหว่าง <strong>0V</strong> กับ <strong>3.3V</strong>) ถ้าคำนวณความละเอียด (<strong>12-bit DAC</strong>) ก็จะได้
 <script type="math/tex">(2.75V-0.55V)/2^{12}</script> จะได้ประมาณ <script type="math/tex">0.5372 mV</script>
</li>
<li>ขา <strong>Digital I/O</strong> ของ <strong>ATSAM3X8E</strong> จะใช้กับกระแสได้น้อยกว่า บอร์ด <strong>Arduino Uno</strong>
เช่น กระแส  <strong>Sink / Source</strong> (สูงสุด) ของแต่ละขา มีระดับไม่เท่ากัน 
ให้ศึกษารายละเอียดได้จากตารางในหน้าเว็บ <a href="https://docs.arduino.cc/hacking/hardware/PinMappingSAM3X">"<strong>SAM3X-Arduino Pin Mapping</strong>"</a></li>
<li>บอร์ดรุ่นใหม่ จะมีแผ่น <strong>PCB</strong> เป็นสีเขียว แต่ถ้าเป็นรุ่นเก่า จะเป็นสีน้ำเงิน</li>
</ul>
<p><img alt="" src="due_green_pcb.png" /></p>
<p>รูป: บอร์ด <strong>Arduino Due R3</strong> (Source: arduino.cc)</p>
<p><img alt="" src="due_boards.jpg" /></p>
<p>รูป: บอร์ด <strong>Arduino Due (Clone)</strong></p>
<p><img alt="" src="due_pinout.png" /> </p>
<p>รูป: แผนผังแสดงตำแหน่งขา (บางส่วน) หรือดูจากไฟล์ <a href="docs/pinout-due_latest.pdf"><strong>PinOut</strong></a>
ของบอร์ด <strong>Arduino Due R3</strong> (Source: Arduino.cc)</p>
<p><a href="due_schematic_large.png"><img alt="" src="due_schematic.png" /></a></p>
<p>รูป: ผังวงจร <a href="docs/arduino-due-schematic.pdf"><strong>Schematic</strong></a></p>
<p>แม้ว่าบอร์ด  <strong>Arduino Due Rev.3</strong> เป็นบอร์ดไมโครคอนโทรลเลอร์ที่มีมานานแล้ว อย่างน้อย 10 ปีขึ้นไป
(หรืออาจจะเรียกได้ว่าเป็น <strong>Legacy MCU Board</strong>) และอาจจะไม่ได้รับความสนใจมากนัก 
เนื่องจากในปัจจุบันมีชิปและบอร์ดไมโครคอนโทรลเลอร์ออกมาให้เลือกอีกจำนวนมาก
จุดเด่นของบอร์ด <strong>Due</strong> เช่น จำนวนขา <strong>I/O</strong> และ ขนาดหน่วยความจำ <strong>SRAM</strong> และ <strong>Flash</strong>
เป็นต้น</p>
<p>ข้อมูลเชิงเทคนิคเกี่ยวกับ <strong>Atmel SAM3X8E MCU</strong></p>
<ul>
<li><strong>CPU</strong>: 32-bit ARM Cortex-M3 CPU @84MHz</li>
<li><strong>IC Package</strong>: 144-lead LQFP</li>
<li><strong>On-chip SRAM</strong>: 96 KB</li>
<li><strong>On-chip Flash</strong>: 512 KB (2 x 256 KB)</li>
<li><strong>Core Voltage</strong>: 1.62V ~ 1.95V</li>
<li><strong>I/O Voltage</strong>: 3.3V (not 5V tolerant !!!)</li>
<li><strong>I/O</strong>: 103 I/O lines</li>
<li><strong>On-chip Peripherals</strong><ul>
<li>4x UART (Hardware Serials)</li>
<li>2x TWI (Two-Wire Interface) / I2C Controllers</li>
<li>6x SPI (Serial Peripheral Interface) Controllers</li>
<li>1x SSC (Synchronous Serial Controller) / I2S Controller</li>
<li>9x 32-bit Timer/Counter (TC) Units</li>
<li>16-bit PWM (Pulse Width Modulation) Outputs (8 channels: PWMHx &amp; PWMLx)</li>
<li>1x Static Memory Controller (SMC)</li>
<li>1x NAND Flash Controller (NFC)</li>
<li>1x SDRAM Controller (SDRAMC)</li>
<li>1x High Speed Multimedia Card Interface (HSMCI)</li>
<li>1x Fast Flash Programming Interface (FFPI)</li>
<li>6x 32-bit Parallel I/O (PIO) Controllers</li>
<li>1x 12-bit 1Msps ADC (16 channels)</li>
<li>1x 12-bit 1Mbps DAC (2 channels)</li>
<li>1x 10/100 Ethernet MAC</li>
<li>1x USB 2.0 OTG (Host / Device)</li>
<li>2x CAN (Controller Area Network) Controllers</li>
<li>1x TNRG (True Random Number Generator)</li>
</ul>
</li>
<li><strong>Programming &amp; Debug Support</strong>: JTAG / SWD</li>
</ul>
<hr />
<h2 id="arduino-ide">&#9655; <strong>การเขียนโปรแกรมด้วย Arduino IDE</strong><a class="headerlink" href="#arduino-ide" title="Permanent link">#</a></h2>
<p>การเขียนโปรแกรม <strong>Arduino Sketch</strong> ด้วยซอฟต์แวร์ <strong>Arduino IDE 2.x</strong>
จะต้องมีการติดตั้ง <a href="https://github.com/arduino/ArduinoCore-sam"><code>ArduinoCore-sam</code></a>
(<strong>Arduino Code for SAM / Arm Cortex-M3</strong>) เวอร์ชันล่าสุด <strong>v1.16.12</strong></p>
<p><img alt="" src="arduino_core_sam_install.png" /></p>
<p>รูป: การติดตั้ง <strong>Boards Manager - Arduino SAM Boards (32-bit Arm Cortex-M3)</strong></p>
<p><img alt="" src="arduino_sam.png" /></p>
<p>รูป: การตั้งค่าใน <strong>Arduino IDE v2.x</strong> สำหรับการใช้บอร์ด <strong>Arduino Due</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="led-push-button-external-interrupt">&#9655; <strong>การใช้งาน LED + Push Button + External Interrupt</strong><a class="headerlink" href="#led-push-button-external-interrupt" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการใช้งานขา <strong>GPIO</strong> เป็นขาดิจิทัล-อินพุต และมีการเปิดใช้งาน
<strong>External Interrupt</strong> และ <strong>Internal Pullup</strong>
เมื่อนำไปต่อกับปุ่มกด <strong>Push Button</strong> (ต่อวงจรปุ่มกดบนเบรดบอร์ด)
และมีการกดปุ่มแล้วปล่อยในแต่ละครั้ง จะทำให้เกิดอินเทอร์รัพท์ที่ขาดังกล่าว</p>
<p>เมื่อเกิดเหตุการณ์กดปุ่มแล้วปล่อย (การเปลี่ยนสถานะลอจิกในลักษณะ "ขอบขาขึ้น" หรือ <strong>RISING</strong>)
ก็จะทำให้ฟังก์ชัน <strong>ISR</strong> ทำงาน และมีหน้าที่สลับสถานะลอจิกที่ขาเอาต์พุตหนึ่งครั้ง
(ขาตรงกับ <strong>LED</strong> บนบอร์ด)</p>
<p>ข้อสังเกต: การเลือกใช้ขา <strong>GPIO</strong> สำหรับ  <strong>External Interrupt</strong> เลือกใช้ขาดิจิทัลใดก็ได้</p>
<pre><code class="language-c++">const int BTN_PIN = 33; // Button input pin
const int LED_PIN = LED_BUILTIN; // Onboard LED pin

volatile bool ledState = LOW; 
volatile uint32_t ts_last_update = 0;

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(BTN_PIN, INPUT_PULLUP); 
  attachInterrupt( digitalPinToInterrupt(BTN_PIN), [](){
    uint32_t ts_now = millis();
    if ( ts_now - ts_last_update &gt;= 20 ) {
       ts_last_update = ts_now;
       ledState = !ledState; // Toggle the LED state.
       digitalWrite(LED_PIN, ledState); // Update the LED.
    }
  }, RISING); 
}

void loop() {
  static uint32_t state = LOW;
  if (ledState != state) { // Detect state change.
     state = ledState;
     String str = &quot;LED: &quot;;
     str += state;
     Serial.println(str.c_str());
  }
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="digital-io-8x-led-bar">&#9655; <strong>การใช้งานขา Digital I/O: 8x LED Bar</strong><a class="headerlink" href="#digital-io-8x-led-bar" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการใช้งานขา <strong>Digital I/O</strong> จำนวน 8 ขา 
และใช้เพื่อกำหนดสถานะลอจิกของ <strong>LED Bar</strong> จำนวน 8 ดวง (ทำงานแบบ <strong>Active-High</strong>)
<strong>LED</strong> จะมีเพียงหนึ่งดวงที่อยู่ในสถานะ <strong>ON</strong> และจะเลื่อนไปตำแหน่งถัดไป แล้วย้อนไปมาตามลำดับ</p>
<pre><code class="language-c++">const int LED_PINS[] = {53,51,49,47,45,43,41,39};
const int NUM_LEDS = sizeof(LED_PINS)/sizeof(int);
const int INTERVAL_MS = 25;

void setup() {
   for (int i=0; i &lt; NUM_LEDS; i++) {
     pinMode( LED_PINS[i], OUTPUT );
     digitalWrite( LED_PINS[i], LOW );
   }
}

void loop() {
  static int index = 2*NUM_LEDS-1;
  static uint32_t ts_saved = 0;  
  uint32_t ts_now = millis();
  if ( ts_now - ts_saved &gt;= INTERVAL_MS ) {
    ts_saved = ts_now;    
    index = (index+1) % (2*NUM_LEDS);
    for (int i=0; i &lt; NUM_LEDS; i++) {
      int j;
      if ( index &gt;= NUM_LEDS ) {
        j = (2*NUM_LEDS-1)-index;
      } else {
        j = index;
      }
      digitalWrite( LED_PINS[i], (i==j) ? HIGH : LOW );
    }
  }
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="pwm">&#9655; <strong>การสร้างสัญญาณ PWM</strong><a class="headerlink" href="#pwm" title="Permanent link">#</a></h2>
<p>บอร์ด <strong>Arduino Due R3</strong> มีขา <strong>D2 ~ D13</strong> ให้ใช้งานเป็นขา <strong>PWM Output</strong> ได้
(สร้างสัญญาณโดยใช้วงจรภายใน เช่น <strong>Timer Counter</strong> หรือ <strong>PWM controller</strong>)
โค้ดตัวอย่างนี้สาธิตการใช้คำสั่ง <code>analogWrite()</code> เพื่อสร้างสัญญาณ <strong>PWM</strong>
จำนวน 3 ช่องสัญญาณ (เลือกใช้ขา <strong>D8</strong>, <strong>D9</strong> และ <strong>D10</strong>)
แล้วนำไปใช้กับโมดูล <strong>RGB LED (active-low, common-anode)</strong></p>
<pre><code class="language-c++">#define ACTIVE_LOW

#ifdef ACTIVE_LOW
#define PWM_DC(x)  (255-(x))
#else
#define PWM_DC(x)  (x)
#endif

const int RGB_PINS[] = {8,10,9}; // R,G,B pins
const int DELAY_MS   = 500; // delay time in msec.

const uint32_t COLORS[] = { 
   0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 
   0xff00ff, 0x00ffff, 0xffffff, 0x000000 
};

const uint8_t NUM_COLORS = sizeof(COLORS)/sizeof(uint32_t);

void setup() {
  for (int i=0; i &lt; 3; i++) {
    pinMode( RGB_PINS[i], OUTPUT );
    analogWrite( RGB_PINS[i], PWM_DC(0) );
  }  
}

void loop() {
  // A static local variable used to keep the current color index.
  static int index = 0;
  uint32_t color = COLORS[ index ];
  for ( int i=2; i &gt;= 0; i-- ) {
    analogWrite( RGB_PINS[i], PWM_DC(color &amp; 0xff) );  
    color &gt;&gt;= 8;  
  }  
  delay( DELAY_MS );
  index = (index+1) % NUM_COLORS;
}
</code></pre>
<p><img alt="" src="due_rgb_led.jpg" /></p>
<p>รูป: ตัวอย่างการต่อวงจรทดลองใช้โมดูล <strong>RGB LED</strong> (โมดูลมีตัวต้านทานจำกัดกระแสสำหรับ <strong>LED</strong>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="adc-dac">&#9655; <strong>การใช้งาน ADC และ DAC</strong><a class="headerlink" href="#adc-dac" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการสร้างสัญญาณเอาต์พุตแบบแอนะล็อกโดยใช้วงจร <strong>DAC</strong> ภายในชิป
และวัดแรงดันไฟฟ้าจากสัญญาณเอาต์พุตดังกล่าวโดยใช้วงจร <strong>ADC</strong> ภายในชิปเดียวกัน</p>
<p>ในตัวอย่างนี้ได้เลือกใช้ขา <strong>DAC1</strong> เป็นขาเอาต์พุต และนำไปต่อผ่านตัวต้านทานแบบอนุกรมที่มีค่าอย่างน้อย
<strong>1k</strong> โอห์ม (!!! เพื่อป้องกันการจ่ายกระแสเกินและอาจทำให้วงจร <strong>DAC</strong> เสียหายได้ !!!)
แล้วนำไปใช้เป็นสัญญาณอินพุต โดยต่อเข้าที่ขา <strong>A1</strong>
ค่าตัวเลขสำหรับนำไปใช้กับ <strong>DAC</strong> จะอยู่ในช่วง <strong>0</strong> ถึง <strong>4095</strong> (12 บิต)
นอกจากนั้นแล้วยังมีการส่งข้อความเพื่อแสดงค่าตัวเลขสำหรับ <strong>DAC</strong> และค่าที่อ่านได้ <strong>ADC</strong> 
โดยมีการแปลงค่าแล้วให้มีหน่วยเป็น <strong>mV (milli-volts)</strong> เมื่อใช้แรงดันอ้างอิง <strong>VREF=3.3V</strong>
แล้วแสดงข้อมูลที่ได้ในรูปแบบของกราฟด้วย <strong>Arduino Serial Plotter</strong></p>
<pre><code class="language-c++">const int ADC_PIN = A1;   // Select an analog input pin
const int DAC_PIN = DAC1; // Select an analog output pin
// 12-bit resolution for both ADC &amp; ADC
const uint32_t BIT_RESOLUTION = 12;
// Max value (2^12 - 1)
const uint32_t MAX_VALUE = (1&lt;&lt;BIT_RESOLUTION )-1; 

void setup() {
  Serial.begin(115200);
  analogWriteResolution(BIT_RESOLUTION );
  analogReadResolution(BIT_RESOLUTION );
  analogWrite(DAC_PIN, MAX_VALUE/2 );
}

const uint32_t N = 8; // Number of voltage levels - 1
const uint32_t VREF = 3300;

void loop() {
  for (uint32_t i=0; i &lt;= N; i++ ) {
     uint32_t dac_value = i*MAX_VALUE/N;
     analogWrite( DAC_PIN, dac_value );
     delay(5);
     uint32_t adc_value = analogRead(ADC_PIN);
     String str;
     str = &quot;DAC[mV]:&quot;;
     str += dac_value*VREF/MAX_VALUE;
     str += &quot;,ADC[mV]:&quot;;
     str += adc_value*VREF/MAX_VALUE;
     Serial.println( str.c_str() );
  }
}
</code></pre>
<p><img alt="" src="dac_output-1.png" /></p>
<p>รูป: กราฟแสดงค่า <strong>ADC</strong> และ <strong>DAC</strong> (ค่าสูงสุดที่วัดได้ประมาณ <strong>2750 mV</strong>)</p>
<p><img alt="" src="dac_output-2.png" /></p>
<p>รูป: กราฟแสดงค่า <strong>ADC</strong> และ <strong>DAC</strong> (ค่าต่ำสุดที่วัดได้ประมาณ <strong>535 mV</strong>)</p>
<p><img alt="" src="dac_output-3.png" /></p>
<p>รูป: กราฟแสดงค่า <strong>ADC</strong> และ <strong>DAC</strong> (ค่ากลางที่วัดได้ประมาณ <strong>1650 mV</strong>
ซึ่งเป็นตำแหน่งที่จุดตัดของกราฟของทั้งสองเส้น)</p>
<p>&nbsp;</p>
<hr />
<h2 id="i2c">&#9655; <strong>การใช้งาน I2C</strong><a class="headerlink" href="#i2c" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการใช้งานบัส <strong>I2C</strong> โดยให้บอร์ด <strong>Arduino Due</strong> 
ทำงานในโหมด <strong>I2C Master</strong> และตรวจสอบดูว่า มีอุปกรณ์ที่ทำหน้าที่เป็น <strong>I2C Slave</strong>
เชื่อมต่ออยู่หรือไม่ ถ้าพบก็ให้แสดงหมายเลขอุปกรณ์ (<strong>I2C Device Address</strong>)</p>
<p>บอร์ด <strong>Arduino Due</strong> มีพอร์ต <strong>I2C</strong> ให้ใช้งานอยู่ 2 พอร์ต คือ</p>
<ul>
<li><code>Wire</code>: ขาหมายเลข <strong>20 (SDA)</strong> และ <strong>21 (SCL)</strong></li>
<li><code>Wire1</code> : ขาที่มีชื่อ <strong>SDA1</strong> และ <strong>SCL1</strong> เขียนกำกับไว้บนบอร์ด </li>
</ul>
<pre><code class="language-c++">#include &lt;Wire.h&gt;

// Wire  : 20 (SDA), 21 (SCL) pins
// Wire1 : SDA1, SCL1 pins
#define MyWire Wire

#define SEP_LINE &quot;==============================&quot;

void i2c_scan() {
  char sbuf[5];
  int n_devices = 0;
  Serial.println( &quot;Scanning I2C bus...&quot; );
  Serial.print( &quot;  &quot; );
  for ( uint8_t col=0; col &lt; 16; col++ ) {
    snprintf( sbuf, 4, &quot;%3x&quot;, col );
    Serial.print( sbuf );
  }
  Serial.println( &quot;&quot; );

  uint8_t addr=0;
  for( uint8_t row=0; row &lt; 8; row++ ) {
    snprintf( sbuf, 3, &quot;%02X&quot;, (row &lt;&lt; 4) );
    Serial.print( sbuf );
    for ( uint8_t col=0; col &lt; 16; col++ ) {
      if ( row==0 &amp;&amp; addr&lt;=1 ) {
        Serial.print(&quot;   &quot;);
      } else {
        MyWire.beginTransmission( addr );
        if ( MyWire.endTransmission()&gt;0 ) {
          Serial.print( &quot; --&quot; );
        } else {
          snprintf( sbuf, 4, &quot; %02x&quot;, addr );
          Serial.print( sbuf );
          n_devices++;
        }
      }
      Serial.flush();
      addr++;
    }
    Serial.println( &quot;&quot; );
  }
  Serial.println( SEP_LINE SEP_LINE &quot;\n&quot; );
  Serial.flush();
}

void setup() {
  Serial.begin(115200);
  MyWire.begin();
  MyWire.setClock( 1000000 ); // real speed: ~930kHz
}

void loop() {
  i2c_scan();
  delay(5000);
}
</code></pre>
<p><img alt="" src="due_i2c_scan.png" /></p>
<p>รูป: ตัวอย่างข้อความเอาต์พุตที่ได้รับใน <strong>Arduino Serial Monitor</strong></p>
<p>จากตัวอย่างข้อความจะเห็นได้ว่า มีการตรวจพบอุปกรณ์ที่ได้นำมาต่อเพิ่มกับบอร์ด <strong>Due</strong>
(ได้แก่ <code>0x60</code> และ <code>0x69</code>)</p>
<p><img alt="" src="due_i2c_scan_waveform.png" /></p>
<p>รูป: การวัดสัญญาณ <strong>SCK</strong> ในระหว่างที่มีการทำงานของบัส <strong>I2C</strong>
(ได้ทดลองตั้งค่าความถี่ของ <strong>SCK</strong> ของ <strong>I2C</strong> ไว้ที่ <strong>1,000,000 Hz</strong>)</p>
<p>&nbsp;</p>
<hr />
<h2 id="hardware-timer">&#9655; <strong>การใช้ Hardware Timer</strong><a class="headerlink" href="#hardware-timer" title="Permanent link">#</a></h2>
<p>ชิป <strong>ATSAM3X8E</strong> มีวงจรตัวนับตามเวลา <strong>Timer / Counter</strong> ให้เลือกใช้ได้
(<code>Timer0</code> ~ <code>Timer8</code>) ในโค้ดนี้ได้มีการเลือกใช้ <code>Timer3</code> เป็นตัวอย่าง
และสามารถเขียนโค้ดเพื่อใช้งานวงจร <strong>Timer</strong> โดยใช้ไลบรารีที่มีชื่อว่า
<a href="https://github.com/ivanseidel/DueTimer"><code>DueTimer</code></a></p>
<pre><code class="language-c++">// https://github.com/ivanseidel/DueTimer
#include &lt;DueTimer.h&gt; // Includes the DueTimer library.

const int LED_PIN = 13;
bool led_state = false;
uint32_t count = 0;

void setup(){
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  delay(1000);

  Timer3.attachInterrupt( [](){ // Timer3 callback
     // Toggle the LED
     digitalWrite(LED_PIN, led_state ^= 1 ); 
     if ( ++count &gt;= 10 ) {
        Timer3.stop(); // Stop the timer.
     }
  } );
  Timer3.start(500000 /*usec*/); // Calls every 500ms
}

void loop() {
  // empty
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="hardware-timer-dac-adc">&#9655; <strong>การใช้งาน Hardware Timer + DAC + ADC</strong><a class="headerlink" href="#hardware-timer-dac-adc" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้สาธิตการใช้งานวงจร <strong>Hardware Timer</strong> ได้แก่ <strong>Timer3</strong>
และ <strong>Timer4</strong> และมีการสร้างฟังก์ชัน <strong>Callback</strong> เพื่อใช้กับวงจรตัวนับดังกล่าว
และให้ทำงานตามช่วงเวลาที่กำหนดไว้ด้วยอัตราคงที่</p>
<p><strong>Timer3</strong> จะเรียกฟังก์ชัน <strong>Callback</strong> ที่เกี่ยวข้อง เพื่อสร้างสัญญาณเอาต์พุตด้วย
<strong>DAC</strong>  โดยใช้ข้อมูลในอาร์เรย์ที่ได้มีการคำนวณไว้ตามฟังก์ชันรูปคลื่นไซน์หนึ่งคาบ
มีการกำหนดช่วงเวลาไว้ในการอัปเดตค่าเอาต์พุตในแต่ละครั้ง เช่น 10, 100, 1000 ไมโครวินาที</p>
<p><strong>Timer4</strong> จะเรียกฟังก์ชัน <strong>Callback</strong> ที่เกี่ยวข้อง เพื่อทำหน้าที่อ่านสัญญาณแอนะล็อกด้วย <strong>ADC</strong>
จากวงจร <strong>DAC</strong> แล้วส่งเป็นข้อความผ่านทางพอร์ต <strong>USB</strong> (<strong>Native USB Port</strong>) ไปยังคอมพิวเตอร์
และนำไปแสดงรูปกราฟ</p>
<pre><code class="language-c++">#include &lt;DueTimer.h&gt; // Includes the DueTimer library.

const int ADC_PIN = A1;   // Select an analog input pin
const int DAC_PIN = DAC1; // Select an analog output pin

// 12-bit resolution for both ADC &amp; ADC
const uint32_t BIT_RESOLUTION = 12;
// Max value (2^12 - 1)
const uint32_t MAX_VALUE = (1&lt;&lt;BIT_RESOLUTION )-1; 

const uint32_t DAC_INTERVAL_US = 10; // try 10, 100, or 1000

// An array used to store pre-calculated sine-wave values.
const uint32_t N = 20;
uint16_t SINE_TABLE[N] = {0}; 
uint32_t dac_sample_index = 0;

// An array used to store ADC values.
const uint32_t M = 4*N;
uint16_t ADC_BUF[M] = {0};
uint32_t adc_sample_index = 0;
volatile bool done = false;

void setup() {
  SerialUSB.begin(2000000); // Use the Native USB port
  while (!SerialUSB);
  delay(200);

  analogWriteResolution(BIT_RESOLUTION);
  analogReadResolution(BIT_RESOLUTION);
  analogWrite(DAC_PIN, MAX_VALUE/2 );

  for ( int i=0; i &lt; N; i++ ) {
    SINE_TABLE[i] = MAX_VALUE/2 + (MAX_VALUE/2)*sin(2*PI*i/N);
  }

  Timer3.attachInterrupt( [](){ // Timer3 callback
    analogWrite( DAC_PIN, SINE_TABLE[dac_sample_index] );
    dac_sample_index = (dac_sample_index+1) % N;
  } );
  Timer3.start( DAC_INTERVAL_US ); // period: use 10 or 100 or 1000 usec

  // Add a passive low-pass RC filter
  // R=10k + C=0.1uF for 50Hz output
  // R=10k + C=0.01uF for 500Hz output
  // R=1.5k + C=0.01uF for 5kHz output

  Timer4.attachInterrupt( [](){ // Timer4 callback
    if (!done) {
      uint32_t value = analogRead( ADC_PIN );
      ADC_BUF[adc_sample_index] = value;
      adc_sample_index = (adc_sample_index+1) % M;
      if (adc_sample_index == 0) {
        done = true;
      }
    }
  } );
  Timer4.start( DAC_INTERVAL_US/2 );
}

void loop() {
  if (done) {
    for (int i=0; i &lt; M; i++) {
      SerialUSB.print(&quot;ADC:&quot;);
      SerialUSB.println ( ADC_BUF[i] );
    }
    delay(100);
    done = false;
  }
}
</code></pre>
<p><img alt="" src="arduino_due_native_usb_port.png" /></p>
<p>รูป: การตั้งค่าและเลือกใช้งาน <strong>Native USB Port</strong> ของบอร์ด <strong>Arduino Due</strong></p>
<p><img alt="" src="arduino_due_serial_plotter.png" /></p>
<p>รูป: ตัวอย่างการแสดงรูปกราฟจากข้อมูลที่ได้รับจากบอร์ด <strong>Arduino Due</strong>
ซึ่งจะเห็นได้ว่า มีลักษณะเป็นรูปคลื่นไซน์</p>
<p>หากลองนำสัญญาณเอาต์พุตจาก <strong>DAC</strong> ไปผ่านวงจรตัวกรองฟาสซีฟ ซึ่งทำหน้าที่กรองความถี่ต่ำผ่าน
โดยใช้ตัวตัวต้านทานและตัวเก็บประจุ (<strong>Low-Pass RC Filter</strong>) ก็มีตัวอย่างดังนี้
เช่น </p>
<ul>
<li>เลือกใช้ <strong>R=10k</strong> กับ <strong>0.1uF</strong> สำหรับเอาต์พุตที่มีความถี่ <strong>50Hz</strong></li>
<li>เลือกใช้ <strong>R=1.5k</strong> กับ <strong>0.01uF</strong> สำหรับเอาต์พุตที่มีความถี่ <strong>5kHz</strong></li>
</ul>
<p>การเลือกใช้ค่า <strong>R</strong> และ <strong>C</strong> จะส่งผลต่อสัญญาณที่ได้จากวงจรกรองความถี่ โดยมีแอมพลิจูดลดลง
และมีความต่างเฟส (เลื่อนเวลาไป) เมื่อเปรียบเทียบจากสัญญาณเดิม</p>
<p><img alt="" src="sine_50hz_10k_100nF.png" /></p>
<p>รูป: การวัดสัญญาณเอาต์พุตด้วยเครื่องออสซิลโลสโคป (<strong>Sine Wave, 50Hz</strong>)</p>
<p><img alt="" src="sine_5khz_1.5k_10nF.png" /></p>
<p>รูป: การวัดสัญญาณเอาต์พุตด้วยเครื่องออสซิลโลสโคป (<strong>Sine Wave, 5kHz</strong>)</p>
<p>สัญญาณช่อง <strong>CH1</strong> คือ สัญญาณที่ได้จาก <strong>DAC</strong> และสัญญาณช่อง <strong>CH2</strong>
เป็นสัญญาณที่ผ่านตัวกรองความถี่ <strong>Low-pass RC</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="nativeusb-port-programming-port">&#9655; <strong>การใช้งาน NativeUSB Port และ Programming Port</strong><a class="headerlink" href="#nativeusb-port-programming-port" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างถัดไปสาธิตการใช้งาน <strong>NativeUSB Port</strong> (<code>SerialUSB</code>)
และ <strong>Programming Port</strong> (<code>Serial</code>) และเมื่อมีการส่งข้อความผ่านทางพอร์ตหนึ่ง
ก็จะส่งต่อไปยังอีกพอร์ต และเกิดขึ้นได้ทั้งสองทิศทาง</p>
<p>ในการทดลองนี้จะต้องมีการใช้งานสาย <strong>MicroUSB</strong> จำนวน 2 เส้น และเปิดใช้งาน 
<strong>Serial Monitor</strong> แยกกันระหว่างสองพอร์ตอนุกรม เพื่อใช้ในการส่งและรับข้อความ</p>
<pre><code class="language-c++">void setup() {
  SerialUSB.begin(115200);
  while(!SerialUSB);
  Serial.begin(115200);
  SerialUSB.println(&quot;NativeUSB port&quot;);
  Serial.println(&quot;Programming port&quot;);
}

const uint32_t BUF_SIZE = 32;

void loop() {
  static byte buf[ BUF_SIZE ];
  uint32_t n;
  n = Serial.available();
  if (n &gt; 0) {
     if (n &gt;= BUF_SIZE) { n = BUF_SIZE; }
     uint32_t num_read = Serial.readBytes(buf, n);
     if (num_read &gt; 0) {
       SerialUSB.write(buf, num_read);
     }
  }
  n = SerialUSB.available();
  if (n &gt; 0) {
     if (n &gt;= BUF_SIZE) { n = BUF_SIZE; }
     uint32_t num_read = SerialUSB.readBytes(buf, n);
     if (num_read &gt; 0) {
       Serial.write(buf, num_read);
     }
  }
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="freertos">&#9655; <strong>การเขียนโปรแกรมด้วย FreeRTOS</strong><a class="headerlink" href="#freertos" title="Permanent link">#</a></h2>
<p>การเขียนโปรแกรมด้วย <strong>FreeRTOS</strong> จะต้องติดตั้งไลบรารีสำหรับ <strong>Arduino</strong>
ที่ได้มีการนำ <strong>FreeRTOS</strong> มาปรับใช้กับชิป <strong>ATSAM3X8E / Arduino Due</strong>
แนะนำให้ลองใช้ไลบรารี <a href="https://github.com/bdmihai/DueFreeRTOS/"><code>DueFreeRTOS</code></a>
ซึ่งใช้ <strong>FreeRTOS v10.1.1</strong> เป็นพื้นฐานในการทำงาน และผู้พัฒนาได้เผยแพร่ในเดือนกุมภาพันธ์ ค.ศ. 2019</p>
<p>ขั้นตอนการติดตั้งไลบรารี <code>DueFreeRTOS</code> ใน <strong>Arduino IDE</strong></p>
<ol>
<li>ดาวน์โหลดไลบรารีมาเป็นไฟล์ <strong>.ZIP</strong></li>
<li>เมื่อเปิดใช้งาน <strong>Arduino IDE</strong> ให้ไปทำคำสั่งจากเมนู 
<strong>Sketch &gt; Include Library &gt; Add .ZIP Library</strong>
เพื่อเลือกไฟล์ <strong>.ZIP</strong> ที่ได้ดาวน์โหลดมา แล้วติดตั้งไลบรารีให้พร้อมใช้งาน</li>
</ol>
<p><img alt="" src="duefreertos_lib.png" /></p>
<p>รูป: การดาวน์โหลดไลบรารี <code>DueFreeRTOS</code> ให้เป็นไฟล์ <strong>.ZIP</strong></p>
<p>ข้อสังเกต: ถ้าจะใช้ <strong>Arduino - FreeRTOS</strong> สำหรับบอร์ดไมโครคอนโทรลเลอร์
ตระกูล <strong>Atmel SAMD</strong> เช่น <strong>SAMD21</strong> หรือ <strong>SAMD51</strong> แนะนำให้ใช้ไลบรารี</p>
<ul>
<li><a href="https://github.com/BriscoeTech/Arduino-FreeRTOS-SAMD21"><code>Arduino-FreeRTOS-SAMD21</code></a></li>
<li><a href="https://github.com/BriscoeTech/Arduino-FreeRTOS-SAMD51"><code>Arduino-FreeRTOS-SAMD51</code></a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 id="freertos-demo-led-blink">&#9655; <strong>FreeRTOS Demo: LED Blink</strong><a class="headerlink" href="#freertos-demo-led-blink" title="Permanent link">#</a></h2>
<p>ตัวอย่างการเขียน <strong>Arduino Sketch</strong> เพื่อทดลองใช้ <strong>FreeRTOS</strong> ในเบื้องต้น มีดังนี้
ในโค้ดตัวอย่าง มีการสร้างทาสก์ (<strong>Task</strong>) เพื่อทำหน้าที่คอยสลับสถานะลอจิกของ <strong>LED</strong> บนบอร์ด
ทุก ๆ 500 มิลลิวินาที</p>
<pre><code class="language-c++">#include &lt;FreeRTOS.h&gt; // Includes the DueFreeRTOS library.
// see: https://github.com/bdmihai/DueFreeRTOS/
#include &lt;task.h&gt;

void blinkLED(void *pvParameters) {
  (void)(pvParameters); // Task parameters not used
  int state = 0;
  pinMode( LED_BUILTIN, OUTPUT );  
  while(1) {
    digitalWrite( LED_BUILTIN, state ^= 1 );
    Serial.print(&quot;LED State: &quot;);
    Serial.println( state );
    vTaskDelay( pdMS_TO_TICKS(500) );
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println(&quot;Arduino DUE (ATSAM3x8e) - FreeRTOS Demo...&quot;);

  String str;
  str = &quot;FreeRTOS Tick period: &quot;;
  str += portTICK_PERIOD_MS;
  str += &quot; msec&quot;;
  Serial.println( str.c_str() );

  xTaskCreate( blinkLED   /* task entry function */, 
               &quot;BlinkLED&quot; /* task name */, 
               128        /* task stack size */,
               NULL       /* task paramters */,
               1          /* task priority */, 
               NULL       /* task handle */ );
  // Start the FreeRTOS scheduler and enter the kernel loop.
  vTaskStartScheduler(); // This is a blocking call.
  Serial.println(&quot;Failed to start FreeRTOS scheduler&quot;);
  while(1);
}

void loop() {
  // empty
}
</code></pre>
<p>&nbsp;</p>
<p>ถ้าต้องการเปลี่ยนจากการใช้คำสั่ง <code>vTaskDelay(...)</code> เป็นคำสั่ง <code>vTaskDelayUntil(...)</code>
ก็มีตัวอย่างการเขียนโค้ดสำหรับฟังก์ชัน <code>blinkLED(...)</code> ดังนี้</p>
<pre><code class="language-c++">void blinkLED(void *pvParameters) {
  (void)(pvParameters); // Task parameters not used
  int state = 0;
  pinMode(LED_BUILTIN, OUTPUT);

  // Initialize the last wake time.
  TickType_t xLastWakeTime = xTaskGetTickCount();
  // Set the interval time in msec.
  const TickType_t interval_ms = pdMS_TO_TICKS(500); 

  while (1) {
    digitalWrite(LED_BUILTIN, state ^= 1);
    Serial.print(&quot;LED State: &quot;);
    Serial.println(state);
    // Use vTaskDelayUntil to maintain a consistent delay period.
    vTaskDelayUntil(&amp;xLastWakeTime, interval_ms);
  }
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="freertos-demo-push-button-interrupt-task-notification">&#9655; <strong>FreeRTOS Demo: Push Button + Interrupt + Task Notification</strong><a class="headerlink" href="#freertos-demo-push-button-interrupt-task-notification" title="Permanent link">#</a></h2>
<p>โค้ดตัวอย่างนี้ สาธิตการใช้อินเทอร์รัพท์ และฟังก์ชัน <strong>ISR</strong> เพื่อตรวจสอบการกดปุ่ม
และสื่อสารกับอีกทาสก์หนึ่ง เมื่อเกิดเหตุการณ์จากการกดปุ่มแล้วปล่อย ฟังก์ชัน
<code>buttonAction(...)</code> ที่เกี่ยวข้องกับทาสก์จะทำงานเมื่อได้รับการแจ้งเหตุการณ์ที่เกิดขึ้นจากฟังก์ชัน
<code>buttonISR()</code> และตรวจสอบดูว่า
ค่าลอจิกที่ขาอินพุตจากปุ่มกด อยู่ในสถานะลอจิก <strong>LOW</strong> ต่อเนื่องและคงที่ในช่วงเวลาหนึ่งหรือไม่
เพื่อเป็นการแก้ปัญหาการกระเด้งของปุ่มกด</p>
<pre><code class="language-c++">#include &lt;FreeRTOS.h&gt; // Includes the DueFreeRTOS library.
// see: https://github.com/bdmihai/DueFreeRTOS/
#include &lt;task.h&gt;

const int BTN_PIN = 33;
const int LED_PIN = 13; 

// FreeRTOS task handle
TaskHandle_t buttonTask;

// Function to handle button press
void buttonAction(void *pvParameters) {
  (void)pvParameters;
  bool led_state  = 0;
  uint32_t clicks = 0;
  vTaskDelay( pdMS_TO_TICKS(1) );
  while (1) {
    // Wait for task notification.
    ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
    uint8_t value = 0xff;
    for (int i=0; i &lt; 8; i++) {
      value = (value &lt;&lt; 1) | digitalRead( BTN_PIN );
      if (value == 0x80) {
        digitalWrite( LED_PIN, led_state ^= 1 ); // Toggle the LED.
        Serial.print( &quot;Button pressed! #&quot;);
        Serial.println( ++clicks );
        Serial.flush();
        break;
      }
      vTaskDelay( pdMS_TO_TICKS(5) );
    }
  }
}

void buttonISR() {
  // Send a task notification to the button task.
  if ( !digitalRead(BTN_PIN) ) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    vTaskNotifyGiveFromISR( buttonTask, &amp;xHigherPriorityTaskWoken );
    if (xHigherPriorityTaskWoken == pdTRUE) {
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
  }
}

void setup() {
  Serial.begin( 115200 );
  Serial.println( &quot;Due FreeRTOS Demo...&quot; );
  Serial.flush();

  pinMode( BTN_PIN, INPUT_PULLUP );
  pinMode( LED_PIN, OUTPUT );
  digitalWrite( LED_PIN, LOW );

  // attach the buttonISR() function as the ISR to the button pin. 
  attachInterrupt(digitalPinToInterrupt(BTN_PIN), buttonISR, FALLING );

  // Create the button task.
  xTaskCreate(
      buttonAction,   // Task function
      &quot;ButtonTask&quot;,   // Task name
      256,            // Stack size (words)
      NULL,           // Task input parameter
      1,              // Task priority
      &amp;buttonTask     // Task handle
  );

  vTaskStartScheduler(); // This is a blocking call.
  Serial.println(&quot;Failed to start FreeRTOS scheduler&quot;);
  while(1);
}

void loop() {
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="_1">&#9655; <strong>กล่าวสรุป</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<p>บทความนี้ได้นำเสนอการใช้งานบอร์ด <strong>Arduino Due R3</strong> ในเบื้องต้น
พร้อมตัวอย่างการเขียนโค้ดด้วย <strong>Arduino Sketch</strong> และการใช้ <strong>FreeRTOS</strong> ในเบื้องต้น</p>
<p><strong>เอกสารที่เกี่ยวข้อง</strong></p>
<ul>
<li><a href="docs/arduino_due_programming_2019-12-26.pdf">การเขียนโค้ดภาษา <strong>C/C++</strong> สำหรับไมโครคอนโทรลเลอร์ <strong>ATSAM3X8E</strong> 
โดยใช้บอร์ด <strong>Arduino Due R3</strong> (<strong>Last Update</strong>: 2019-12-26)</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>
<p>Created: 2023-09-24 | Last Updated: 2023-09-27</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2024 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
