<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="RSP">
        <link rel="canonical" href="https://iot-kmutnb.github.io/blogs/zephyr/zephyr_cli_west/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>แนะนำการใช้งาน Zephyr RTOS แบบ CLI - IoT Engineering Education</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/arduino.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/json.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/vhdl.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/verilog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/text.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/plaintext.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/julia.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-966FQ6RN6W"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-966FQ6RN6W");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">IoT Engineering Education</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#zephyr-rtos-cli" class="nav-link">แนะนำการใช้งาน Zephyr RTOS แบบ CLI</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#zephyr-ubuntu-linux" class="nav-link">&#9655; การติดตั้งซอฟต์แวร์ Zephyr สำหรับ Ubuntu / Linux</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#_1" class="nav-link">ขั้นตอนการดำเนินการมีดังนี้</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#zephyr-raspberry-pi-pico" class="nav-link">&#9655; การทดลองใช้ Zephyr ร่วมกับบอร์ด Raspberry Pi Pico</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bbc-microbit-v2-heart-symbol-blinking" class="nav-link">&#9655; BBC Micro:bit V2 - Heart Symbol Blinking</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bbc-microbit-v2-ibeacon-advertising" class="nav-link">&#9655; BBC Micro:bit V2 - iBeacon Advertising</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bbc-microbit-v2-ble-button-service" class="nav-link">&#9655; BBC Micro:bit V2 - BLE Button Service</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="zephyr-rtos-cli">แนะนำการใช้งาน Zephyr RTOS แบบ CLI<a class="headerlink" href="#zephyr-rtos-cli" title="Permanent link">#</a></h1>
<p><strong>Keywords</strong>: <em>Zephyr RTOS</em>, <em>Zephyr West Tool</em>, <em>Zephyr SDK</em>, <em>Micro:bit v2</em>, <em>Raspberry Pi Pico</em></p>
<p>บทความนี้นำเสนอขั้นตอนการติดตั้งซอฟต์แวร์ <strong>Zephyr</strong> สำหรับ <strong>Ubuntu 24.04 LTS</strong>
หรืออาจใช้กับ <strong>WSL 2 Ubuntu</strong> บนระบบปฏิบัติการ <strong>Windows</strong> ได้เช่นกัน
ในขั้นตอนต่อไปนี้ เป็นการติดตั้งและใช้งาน <strong>Zephyr RTOS v4.3.0</strong> และ <strong>Zephyr SDK v0.17.4</strong></p>
<ul>
<li><a href="#zephyr-ubuntu-linux"><strong>การติดตั้งซอฟต์แวร์ Zephyr สำหรับ Ubuntu / Linux</strong></a></li>
<li><a href="#zephyr-raspberry-pi-pico"><strong>การทดลองใช้ Zephyr ร่วมกับบอร์ด Raspberry Pi Pico</strong></a></li>
<li><a href="#bbc-microbit-v2-heart-symbol-blinking"><strong>BBC Micro:bit V2 - Heart Symbol Blinking</strong></a></li>
<li><a href="#bbc-microbit-v2-ibeacon-advertising"><strong>BBC Micro:bit V2 - iBeacon Advertising</strong></a></li>
<li><a href="#bbc-microbit-v2-ble-button-service"><strong>BBC Micro:bit V2 - BLE Button Service</strong></a></li>
</ul>
<hr />
<h2 id="zephyr-ubuntu-linux">&#9655; <strong>การติดตั้งซอฟต์แวร์ Zephyr สำหรับ Ubuntu / Linux</strong><a class="headerlink" href="#zephyr-ubuntu-linux" title="Permanent link">#</a></h2>
<p>แม้ว่าในปัจจุบัน การเขียนโค้ดสำหรับไมโครคอนโทรลเลอร์โดยใช้ <a href="https://www.zephyrproject.org/"><strong>Zephyr RTOS</strong></a> จะมีตัวเลือก เช่น
การใช้ <strong>Zephyr IDE</strong> ซึ่งเป็น <strong>Extension Pack</strong> สำหรับ <strong>VS Code IDE</strong> แต่การใช้งานซอฟต์แวร์
<strong>Zephyr RTOS</strong> แบบ <strong>CLI</strong> (<em>Command Line Interface</em>) 
โดยใช้คำสั่ง <a href="https://github.com/zephyrproject-rtos/west"><code>west</code></a> (<strong>Python-based meta-tool</strong>) ก็ถือว่าเป็นวิธีที่สะดวกเช่นกัน </p>
<h3 id="_1"><strong>ขั้นตอนการดำเนินการมีดังนี้</strong><a class="headerlink" href="#_1" title="Permanent link">#</a></h3>
<ol>
<li>ติดตั้งเครื่องมือสำหรับการสร้างโปรแกรม (<strong>build tools</strong>) ไลบรารี และ <strong>Python dependencies</strong>
เช่น <code>git</code>, <code>cmake</code>, <code>ninja-build</code>, <code>python3-dev</code> เป็นต้น</li>
<li>สร้างไดเรกทอรีสำหรับโปรเจกต์ <strong>Zephyr</strong> โดยใช้ชื่อว่า <code>~/zephyrproject</code> เพื่อเก็บโค้ด
และ <strong>Zephyr Workspace</strong></li>
<li>เข้าไปยังไดเรกทอรีโปรเจกต์ <code>~/zephyrproject</code> </li>
<li>สร้างและเปิดใช้งาน <strong>Python virtual environment</strong> เพื่อแยกสภาพแวดล้อมของ <strong>Python</strong> โดยไม่กระทบระบบหลัก และจะต้องเปิดใช้งานด้วยคำสั่ง <code>source .venv/bin/activate</code></li>
<li>ติดตั้งโปรแกรม <strong>West</strong> และตรวจสอบเวอร์ชัน (ลองใช้เวอร์ชัน: v1.5.0)</li>
<li>เริ่มต้นสร้าง <strong>Zephyr Workspace</strong> (ใช้คำสั่ง <code>west init -m &lt;repo_url&gt;</code>) 
โดยระบุ <strong>Zephyr repository</strong> และคำสั่ง <code>west update</code> เพื่อดาวน์โหลดไฟล์จาก <strong>GitHub</strong>
ได้แก่โมดูลต่าง ๆ (<strong>Dependencies</strong>) สำหรับ <strong>Zephyr</strong> (ขั้นตอนนี้ใช้เวลาหลายนาที และขึ้นอยู่กับความเร็วอินเทอร์เน็ต)</li>
<li>ทำคำสั่ง <code>west zephyr-export</code> เพื่อกำหนดตัวแปร เช่น <code>ZEPHYR_BASE</code></li>
<li>ติดตั้ง <strong>Python dependencies</strong> สำหรับ <strong>build script</strong></li>
<li>ติดตั้ง <strong>Zephyr SDK</strong> และ <strong>toolchains</strong> ที่เกี่ยวข้อง
โดยเจาะจงสถาปัตยกรรมที่ต้องการ เช่น <code>x86_64</code>, <code>ARM</code>, <code>RISC-V</code>, <code>ESP32</code> เป็นต้น</li>
</ol>
<pre><code class="language-text"># 1) Install required packages for Zephyr development .
#    (build tools, Python, libraries, etc.)
$ sudo apt install --no-install-recommends git cmake ninja-build gperf \
  ccache dfu-util device-tree-compiler wget \
  python3-dev python3-venv python3-pip python3-setuptools python3-tk \
  xz-utils file make gcc libsdl2-dev libmagic1 \
  gcc-multilib g++-multilib

# 2) Create a working directory for Zephyr projects.
$ mkdir ~/zephyrproject

# 3) Change into the Zephyr project directory.
$ cd ~/zephyrproject

# 4) Create a Python virtual environment inside the directory
#    and activate the virtual environment.
$ python3 -m venv .venv &amp;&amp; source .venv/bin/activate

# 5) Install West, the Zephyr meta-tool, using pip and
#    verify the installed version of West.
$ pip3 install west
$ west --version
# Expected example: West version: v1.5.0

# 6) Initialize a Zephyr workspace and specify the repository URL.
$ west init -m https://github.com/zephyrproject-rtos/zephyr 

# 7) Fetch all modules specified by the Zephyr manifest.
$ west update

# 8) Set environment variables for Zephyr (e.g., ZEPHYR_BASE)
$ west zephyr-export

# 9) Change into the main Zephyr source directory
#    and install Python dependencies required by Zephyr build scripts.
$ cd ~/zephyrproject/zephyr
$ pip3 install -r scripts/requirements.txt

# Check SDK version used by the Zephyr project
# zephyrproject/zephyr/SDK_VERSION =&gt; version 0.17.4

# 10) Install Zephyr SDK toolchains

# Option 1: Install Zephyr SDK toolchains for selected architectures.
$ west sdk install --toolchains x86_64-zephyr-elf \
   arm-zephyr-eabi aarch64-zephyr-elf riscv64-zephyr-elf
$ west sdk install --toolchains xtensa-espressif_esp32_zephyr-elf \
   xtensa-espressif_esp32s3_zephyr-elf

# Option 2: Manual download and installation of Zephyr SDK
$ ZEPHYR_SDK_URL=https://github.com/zephyrproject-rtos/sdk-ng/releases/download
$ ZEPHYR_SDK_URL=${ZEPHYR_SDK_URL}/v0.17.0/zephyr-sdk-0.17.0_linux-x86_64.tar.xz
$ wget $ZEPHYR_SDK_URL
$ tar xvf zephyr-sdk-0.17.0_linux-x86_64.tar.xz
$ zephyr-sdk-0.17.0/setup.sh
</code></pre>
<p><img alt="" src="zephyr_ubuntu-1.jpg" /></p>
<p><img alt="" src="zephyr_ubuntu-2.jpg" /></p>
<p>รูป: ตัวอย่างการทำขั้นตอนการติดตั้งซอฟต์แวร์สำหรับ <strong>Zephyr</strong> แบบ <strong>CLI</strong></p>
<p>&nbsp;</p>
<hr />
<h2 id="zephyr-raspberry-pi-pico">&#9655; <strong>การทดลองใช้ Zephyr ร่วมกับบอร์ด Raspberry Pi Pico</strong><a class="headerlink" href="#zephyr-raspberry-pi-pico" title="Permanent link">#</a></h2>
<p>เมื่อได้ติดตั้งโปรแกรมต่าง ๆ ที่จำเป็นแล้ว ลองคอมไพล์โค้ดของโปรเจกต์ตัวอย่างที่มีอยู่ในไดเรกทอรี
<code>~/zephyrproject/zephyr/samples</code> โดยเลือกใช้บอร์ด เช่น
<strong>Raspberry Pi Pico (RP2040) / Pico 2 (RP2350A)</strong></p>
<ul>
<li><code>west build --pristine</code> หรือ <code>west build -p</code> ใน <strong>Zephyr</strong>
หมายถึงการ ล้างการคอมไพล์เดิมทั้งหมดก่อนแล้วจึงเริ่มสร้างใหม่ตั้งแต่ต้น (<strong>Clean Build</strong>)</li>
<li><code>west -p auto</code> ให้ <strong>Zephyr</strong> ตัดสินเองว่าควรล้าง <strong>build</strong> เก่าหรือไม่</li>
</ul>
<pre><code class="language-text"># List all supported Zephyr boards (and filter results for pico)
$ west boards | grep rpi_pico
# Expected output:
# rpi_pico
# rpi_pico2

# Build the Zephyr &quot;blinky&quot; sample for the Raspberry Pico 2 board
# (-p: pristine build, -b: specify target board)
$ west build -p -b rpi_pico2/rp2350a/m33 samples/basic/blinky

# Build the Zephyr &quot;blinky&quot; sample for the Raspberry Pico board
# (-p: pristine build, -b: specify target board)
$ west build -p -b rpi_pico samples/basic/blinky

# Copy the compiled .UF2 file to the RPi Pico USB drive
# This will automatically flash the firmware to the board.

# For Ubuntu:
$ cp build/zephyr/zephyr.uf2 /media/$USER/RPI_RP2/

# For WSL2 Ubuntu:
# Create a mount point directory for drive D: inside WSL2
$ sudo mkdir -p /mnt/d

# Mount the Windows D: drive to the created directory (/mnt/d)
# -t drvfs tells WSL to use the Windows file system driver
$ sudo mount -t drvfs D: /mnt/d

# Copy the generated Zephyr .uf2 firmware file to the drive
# to flash it to the Micro:bit board via drag-and-drop
$ cp build/zephyr/zephyr.uf2 /mnt/d/
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="bbc-microbit-v2-heart-symbol-blinking">&#9655; <strong>BBC Micro:bit V2 - Heart Symbol Blinking</strong><a class="headerlink" href="#bbc-microbit-v2-heart-symbol-blinking" title="Permanent link">#</a></h2>
<p>สร้างโปรเจกต์ใหม่ <code>~/zephyrproject/microbit_v2_heart_blink</code> (<strong>Heart Symbol Blinking Demo</strong>)</p>
<pre><code class="language-text">$ cd ~/zephyrproject/
$ mkdir -p microbit_v2_heart_blink
</code></pre>
<p>สร้างไฟล์ใหม่ตามโครงสร้างต่อไปนี้</p>
<pre><code class="language-text">./microbit_v2_heart_blink/
├── CMakeLists.txt
├── prj.conf
└── src
    └── main.c
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_heart_blink/CMakeLists.txt</code></p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(microbit_v2_heart_blink)

target_sources(app PRIVATE src/main.c)
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_heart_blink/prj.conf</code></p>
<pre><code class="language-yaml"># Configuration file for micro:bit v2 LED matrix display

# -- UART and Console Configuration
# Enable UART console for serial communication
CONFIG_UART_CONSOLE=y
# Redirect stdout to console for printk() output
CONFIG_STDOUT_CONSOLE=y

# -- GPIO Configuration
# Enable GPIO driver (required for LED matrix pins)
CONFIG_GPIO=y
# Enable Nordic nRFx GPIO driver for nRF52833
CONFIG_GPIO_NRFX=y

# -- LED Configuration
# Disable generic LED driver (not needed for matrix)
CONFIG_LED=n

# -- Input Configuration
# Enable input subsystem (may be used by display driver)
CONFIG_INPUT=y

# -- Display Configuration
# Enable display subsystem
CONFIG_DISPLAY=y
# Enable micro:bit specific 5x5 LED matrix driver
CONFIG_MICROBIT_DISPLAY=y

# -- Thread and Stack Configuration
# Set main thread stack size to 1KB
CONFIG_MAIN_STACK_SIZE=1024 
# Enable thread names for debugging
CONFIG_THREAD_NAME=y

# -- Timing Configuration
# Enable timing functions for accurate delays
CONFIG_TIMING_FUNCTIONS=y

# -- C Library Configuration
# Disable Newlib C library
CONFIG_NEWLIB_LIBC=n
# Use Picolibc (smaller, more efficient for embedded)
CONFIG_PICOLIBC=y
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_heart_blink/src/main.c</code></p>
<pre><code class="language-c">// Blinking Heart Display on micro:bit v2

#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/device.h&gt;
#include &lt;zephyr/drivers/gpio.h&gt;
#include &lt;zephyr/display/mb_display.h&gt;

/* Define the heart pattern for 5x5 LED matrix
 * 1 = LED on, 0 = LED off
 */
static const struct mb_image heart = MB_IMAGE(
    { 0, 1, 0, 1, 0 },
    { 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1 },
    { 0, 1, 1, 1, 0 },
    { 0, 0, 1, 0, 0 }
);

// Blank image for blink effect
static const struct mb_image blank = MB_IMAGE(
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 }
);

int main(void)
{
    struct mb_display *disp;

    printk(&quot;micro:bit v2 Heart Blink Starting...\n&quot;);

    /* Get the mb_display structure */
    disp = mb_display_get();

    if (disp == NULL) {
        printk(&quot;Failed to get display\n&quot;);
        return -1;
    }

    printk(&quot;Display ready!\n&quot;);

    while (1) {
        /* Show heart */
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;heart, 1);
        k_sleep(K_MSEC(500));

        /* Show blank (heart off) */
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;blank, 1);
        k_sleep(K_MSEC(500));
    }
    return 0;
}
</code></pre>
<p>ตัวอย่างการทำคำสั่งในขั้นตอน <strong>Build</strong> สำหรับบอร์ด <strong>Micro:bit V2</strong> มีดังนี้</p>
<pre><code class="language-text"># Build the firmware file for Micro:bit V2
$ west build -p auto -b bbc_microbit_v2 ./microbit_v2_heart_blink 
</code></pre>
<p>คำสั่งสำหรับอัปโหลดไฟล์ <strong>Firmware</strong> ในกรณีที่ใช้ <strong>Ubuntu</strong></p>
<pre><code class="language-text"># For Ubuntu: Method 1
$ cp build/zephyr/zephyr.bin /media/$USER/MICROBIT/

# For Ubuntu: Method 2
$ pip3 install pyocd
$ west flash --runner pyocd
</code></pre>
<p>คำสั่งสำหรับอัปโหลดไฟล์ <strong>Firmware</strong> ในกรณีที่ใช้ <strong>WSL 2 Ubuntu</strong></p>
<pre><code class="language-text"># For WSL 2 Ubuntu (safer method)
$ powershell.exe -Command \
  'Copy-Item -Path &quot;build/zephyr/zephyr.bin&quot; -Destination &quot;D:\&quot;'
</code></pre>
<p><img alt="" src="west_microbit_v2_build.jpg" /></p>
<p>รูป: ตัวอย่างการทำคำสั่งในขั้นตอน <strong>Build</strong> (<strong>WSL 2 Ubuntu</strong>) สำหรับ <strong>Micro:bit V2</strong></p>
<p><img alt="" src="pyocd_flash.jpg" /></p>
<p>รูป: ตัวอย่างการทำคำสั่ง <strong>pyocd</strong> (<strong>Ubuntu)</strong></p>
<p>คำสั่ง <code>west flash --runner pyocd</code> จะเรียกใช้ <code>pyocd</code> เพื่อทำหน้าที่อัปโหลดไฟล์ไปยังบอร์ด
<strong>Micro:bit</strong></p>
<p><img alt="" src="microbit_heart_symbol.jpg" /></p>
<p>รูป: บอร์ด <strong>Micro:bit v2</strong> แสดงสัญลักษณ์รูปหัวใจ (<strong>Heart Symbol</strong>)</p>
<p>โค้ดตัวอย่างถัดไป มีการเปลี่ยนแปลงดังนี้</p>
<ol>
<li>ทำให้แสดงสัญลักษณ์ <strong>Heart</strong> กระพริบ โดยใช้ <strong>Timer</strong> ของ <strong>Zephyr RTOS</strong></li>
<li>มีการตรวจสอบปุ่มกด <strong>A</strong> และ <strong>B</strong> หากมีการกดปุ่ม ให้หยุดกระพริบชั่วคราว
กดอีกครั้ง ทำให้กระพริบต่อ แต่ถ้ากดปุ่มทั้งสองพร้อมกัน ให้แสดงสัญลักษณ์ทันที</li>
</ol>
<pre><code class="language-c">#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/device.h&gt;
#include &lt;zephyr/drivers/gpio.h&gt;
#include &lt;zephyr/display/mb_display.h&gt;
#include &lt;zephyr/sys/printk.h&gt;
#include &lt;stdbool.h&gt;

// --- Heart and blank patterns
static const struct mb_image heart = MB_IMAGE(
    {0, 1, 0, 1, 0},
    {1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1},
    {0, 1, 1, 1, 0},
    {0, 0, 1, 0, 0}
);

static const struct mb_image blank = MB_IMAGE(
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0}
);

// Display instance
static struct mb_display *disp;

// Timer for blinking heart
static struct k_timer heart_timer;

// State variables
static volatile bool show_heart = true;
static volatile bool paused = false;

// Debounce variables
#define DEBOUNCE_MS 200

static int64_t last_btn_a = 0;
static int64_t last_btn_b = 0;

// Timer handler: toggle heart/blank
static void heart_timer_handler(struct k_timer *timer)
{
    if (paused) return;

    if (show_heart) {
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;heart, 1);
    } else {
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;blank, 1);
    }
    show_heart = !show_heart;
}

// GPIO buttons
static const struct gpio_dt_spec btn_a = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);
static const struct gpio_dt_spec btn_b = GPIO_DT_SPEC_GET(DT_ALIAS(sw1), gpios);
static struct gpio_callback cb_a;
static struct gpio_callback cb_b;

// Button handler: toggle pause/resume or show heart
static void button_pressed(const struct device *dev,
                           struct gpio_callback *cb,
                           uint32_t pins)
{
    // Get current time
    int64_t now = k_uptime_get();

    // Check for button A callback
    if (cb == &amp;cb_a) {
        if (now - last_btn_a &lt; DEBOUNCE_MS) return;
        last_btn_a = now;
    }
    // Check for button B callback
    if (cb == &amp;cb_b) {
        if (now - last_btn_b &lt; DEBOUNCE_MS) return;
        last_btn_b = now;
    }

    bool a_pressed = gpio_pin_get_dt(&amp;btn_a);
    bool b_pressed = gpio_pin_get_dt(&amp;btn_b);

    // If both buttons A and B are pressed: show heart immediately
    if (a_pressed &amp;&amp; b_pressed) {
        paused = true;          // pause blinking
        show_heart = true;      // ensure heart is on
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;heart, 1);
        printk(&quot;Buttons A+B pressed\n&quot;);
        return;
    }

    // Single button toggles pause/resume
    const char *button_name = NULL;
    if (a_pressed) button_name = &quot;A&quot;;
    else if (b_pressed) button_name = &quot;B&quot;;
    else return;

    paused = !paused;
    if (paused) {
        mb_display_image(disp, MB_DISPLAY_MODE_DEFAULT,
                               SYS_FOREVER_MS, &amp;blank, 1);
        printk(&quot;Button %s pressed =&gt; Blinking paused\n&quot;, button_name);
    } else {
        printk(&quot;Button %s pressed =&gt; Blinking resumed\n&quot;, button_name);
    }
}

int main(void)
{
    printk(&quot;Micro:bit v2 Heart Blink\n&quot;);

    disp = mb_display_get();
    if (!disp) {
        printk(&quot;Failed to get display\n&quot;);
        return -1;
    }

    // Initialize buttons
    if (!device_is_ready(btn_a.port) || !device_is_ready(btn_b.port)) {
        printk(&quot;Button GPIO not ready\n&quot;);
        return -1;
    }

    gpio_pin_configure_dt(&amp;btn_a, GPIO_INPUT);
    gpio_pin_configure_dt(&amp;btn_b, GPIO_INPUT);

    gpio_pin_interrupt_configure_dt(&amp;btn_a, GPIO_INT_EDGE_TO_ACTIVE);
    gpio_pin_interrupt_configure_dt(&amp;btn_b, GPIO_INT_EDGE_TO_ACTIVE);

    gpio_init_callback(&amp;cb_a, button_pressed, BIT(btn_a.pin));
    gpio_add_callback(btn_a.port, &amp;cb_a);

    gpio_init_callback(&amp;cb_b, button_pressed, BIT(btn_b.pin));
    gpio_add_callback(btn_b.port, &amp;cb_b);

    // Initialize timer: interval = 100ms
    k_timer_init(&amp;heart_timer, heart_timer_handler, NULL);
    k_timer_start(&amp;heart_timer, K_MSEC(0), K_MSEC(100));

    // Main loop free for other tasks
    while (1) {
        k_sleep(K_MSEC(1000));
    }
    return 0;
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="bbc-microbit-v2-ibeacon-advertising">&#9655; <strong>BBC Micro:bit V2 - iBeacon Advertising</strong><a class="headerlink" href="#bbc-microbit-v2-ibeacon-advertising" title="Permanent link">#</a></h2>
<p>สร้างโปรเจกต์ใหม่ <code>~/zephyrproject/microbit_v2_beacon</code> (<strong>iBeacon Advertising Demo</strong>)
เพื่อสาธิตการส่งสัญญาณ <strong>Beacon</strong> โดยมีชื่ออุปกรณ์ที่ตรวจสอบและมองเห็นได้เป็น <strong>"BBC microbit v2"</strong></p>
<pre><code class="language-text">$ cd ~/zephyrproject/
$ mkdir -p microbit_v2_beacon
</code></pre>
<p>สร้างไฟล์ใหม่ตามโครงสร้างต่อไปนี้</p>
<pre><code class="language-text">./microbit_v2_beacon/
├── CMakeLists.txt
├── prj.conf
└── src
    └── main.c
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/CMakeLists.txt</code></p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(microbit_v2_beacon)

target_sources(app PRIVATE src/main.c)
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/prj.conf</code></p>
<pre><code class="language-yaml"># Enable console and printk
CONFIG_PRINTK=y
CONFIG_CONSOLE=y
CONFIG_UART_CONSOLE=y

# Enable Bluetooth
CONFIG_BT=y
CONFIG_BT_PERIPHERAL=y
CONFIG_BT_BROADCASTER=y
CONFIG_BT_EXT_ADV=y

# Optional: enable main thread logging
CONFIG_LOG=y
CONFIG_LOG_DEFAULT_LEVEL=3
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/src/main.c</code></p>
<pre><code class="language-c">#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/bluetooth/bluetooth.h&gt;
#include &lt;zephyr/bluetooth/hci.h&gt;
#include &lt;zephyr/sys/byteorder.h&gt;
#include &lt;zephyr/sys/printk.h&gt;

#define DEVICE_NAME &quot;BBC microbit v2&quot;
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

// iBeacon UUID: 2D7A9F0C-E0E8-4CC9-A71B-A21DB2D034A1
#define IBEACON_UUID 0x2D, 0x7A, 0x9F, 0x0C, \
                     0xE0, 0xE8, \
                     0x4C, 0xC9, \
                     0xA7, 0x1B, \
                     0xA2, 0x1D, 0xB2, 0xD0, 0x34, 0xA1

#define IBEACON_MAJOR 1
#define IBEACON_MINOR 1
#define IBEACON_RSSI 0xC8 // approx. -56 dBm (Measured power at 1m)

// iBeacon Advertisement Data
// Format: Length, Type, Company ID (Little Endian), 
//         iBeacon Type, UUID, Major, Minor, TX Power
static uint8_t ibeacon_data[] = {
   0x02, 0x01, 0x06,     // Flags: LE General Discoverable, BR/EDR Not Supported
   0x1A, 0xFF,           // Length 26, Manufacturer Specific Data
   0x4C, 0x00,           // Company ID: Apple (0x004C in little endian)
   0x02,                 // iBeacon type
   0x15,                 // iBeacon data length (21 bytes)
   IBEACON_UUID,         // Proximity UUID (16 bytes)
   (IBEACON_MAJOR &gt;&gt; 8) &amp; 0xFF, 
   IBEACON_MAJOR &amp; 0xFF, // Major (2 bytes, big endian)
   (IBEACON_MINOR &gt;&gt; 8) &amp; 0xFF, 
   IBEACON_MINOR &amp; 0xFF, // Minor (2 bytes, big endian)
   IBEACON_RSSI          // Measured Power (1 byte)
};

// Scan Response Data - Contains the device name
static const struct bt_data scan_rsp[] = {
    BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};

// Advertisement Data - Contains iBeacon payload
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR),
    BT_DATA(BT_DATA_MANUFACTURER_DATA,
    &amp;ibeacon_data[5], sizeof(ibeacon_data) - 5),
};

int main(void)
{
    int err;
    struct bt_le_adv_param adv_param;

    printk(&quot;Starting iBeacon for micro:bit v2\n&quot;);

    // Initialize Bluetooth
    err = bt_enable(NULL);
    if (err) {
        printk(&quot;Bluetooth init failed (err %d)\n&quot;, err);
        return err;
    }
    printk(&quot;Bluetooth initialized\n&quot;);

    // Configure advertising parameters
    // ADV_SCAN_IND: Scannable undirected advertising (non-connectable)

    uint16_t ADV_INT_100MS = (uint16_t)(100.0 / 0.625); // 160
    adv_param = *BT_LE_ADV_PARAM(
        BT_LE_ADV_OPT_USE_IDENTITY,
        ADV_INT_100MS,    // 100ms min interval
        ADV_INT_100MS,    // 100ms max interval   
        NULL              // No directed advertising
    );

    // Start advertising with scan response
    err = bt_le_adv_start(&amp;adv_param, ad, ARRAY_SIZE(ad), 
                          scan_rsp, ARRAY_SIZE(scan_rsp));
    if (err) {
        printk(&quot;Advertising failed to start (err %d)\n&quot;, err);
        return err;
    }
    printk(&quot;iBeacon started successfully\n&quot;);
    printk(&quot;Device name in scan response: %s\n&quot;, DEVICE_NAME);
    printk(&quot;UUID: 2D7A9F0C-E0E8-4CC9-A71B-A21DB2D034A1\n&quot;);
    printk(&quot;Major: %d, Minor: %d\n&quot;, IBEACON_MAJOR, IBEACON_MINOR);

    while (1) {
        k_sleep(K_SECONDS(1));
    }
    return 0;
}
</code></pre>
<p>&nbsp;</p>
<hr />
<h2 id="bbc-microbit-v2-ble-button-service">&#9655; <strong>BBC Micro:bit V2 - BLE Button Service</strong><a class="headerlink" href="#bbc-microbit-v2-ble-button-service" title="Permanent link">#</a></h2>
<p>สร้างโปรเจกต์ใหม่ <code>~/zephyrproject/microbit_v2_ble_buttons</code> (<strong>BLE Button Service</strong>)
เพื่อสาธิตการตรวจสอบสถานะการกดปุ่มบนบอร์ด <strong>"BBC microbit v2"</strong> และเชื่อมต่อกับ <strong>Web App</strong>
โดยใช้ <strong>Chrome Web Browser</strong> ด้วยวิธี <strong>Web Bluetooth</strong></p>
<pre><code class="language-text">$ cd ~/zephyrproject/
$ mkdir -p microbit_v2_ble_buttons
</code></pre>
<p>สร้างไฟล์ใหม่ตามโครงสร้างต่อไปนี้</p>
<pre><code class="language-text">./microbit_v2_ble_buttons/
├── CMakeLists.txt
├── prj.conf
└── src
    └── main.c
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/CMakeLists.txt</code></p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.20.0)

# Set the Zephyr project
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(microbit_v2_ble_buttons)

# Add source files
target_sources(app PRIVATE src/main.c)
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/prj.conf</code></p>
<pre><code class="language-yaml"># Enable BLE stack
CONFIG_BT=y
CONFIG_BT_PERIPHERAL=y
CONFIG_BT_DEVICE_NAME=&quot;Micro:bit Button&quot;
CONFIG_BT_DEVICE_APPEARANCE=0
CONFIG_BT_GATT_SERVICE_CHANGED=y
CONFIG_BT_GATT_CLIENT=n
CONFIG_BT_MAX_CONN=1
CONFIG_BT_GATT_DYNAMIC_DB=n

# Enable GPIO (buttons)
CONFIG_GPIO=y

# Enable logging and UART
CONFIG_LOG=y
CONFIG_SERIAL=y
CONFIG_CONSOLE=y
CONFIG_PRINTK=y
CONFIG_STDOUT_CONSOLE=y

# Zephyr Kernel
CONFIG_MAIN_STACK_SIZE=1024
CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=1024
</code></pre>
<p><strong>File:</strong> <code>./microbit_v2_beacon/src/main.c</code></p>
<pre><code class="language-c">#include &lt;zephyr/kernel.h&gt;
#include &lt;zephyr/device.h&gt;
#include &lt;zephyr/devicetree.h&gt;
#include &lt;zephyr/drivers/gpio.h&gt;
#include &lt;zephyr/bluetooth/bluetooth.h&gt;
#include &lt;zephyr/bluetooth/conn.h&gt;
#include &lt;zephyr/bluetooth/gatt.h&gt;
#include &lt;zephyr/logging/log.h&gt;

LOG_MODULE_REGISTER(main, LOG_LEVEL_INF);

/* GPIO setup for Button A and B */
#define BUTTON_A_NODE DT_ALIAS(sw0)
#define BUTTON_B_NODE DT_ALIAS(sw1)

static const struct gpio_dt_spec button_a 
                    = GPIO_DT_SPEC_GET(BUTTON_A_NODE, gpios);
static const struct gpio_dt_spec button_b 
                    = GPIO_DT_SPEC_GET(BUTTON_B_NODE, gpios);

/* Connection tracking */
static struct bt_conn *current_conn = NULL;
static bool notify_enabled = false;

/* GATT Characteristic for Button State */
static uint8_t button_value = 0;

/* Custom UUIDs */
#define BT_UUID_BUTTON_SERVICE_VAL \
    BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef0)
#define BT_UUID_BUTTON_CHAR_VAL \
    BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef1)

static struct bt_uuid_128 button_service_uuid 
              = BT_UUID_INIT_128(BT_UUID_BUTTON_SERVICE_VAL);
static struct bt_uuid_128 button_char_uuid
              = BT_UUID_INIT_128(BT_UUID_BUTTON_CHAR_VAL);

/* GATT Callbacks */
static ssize_t read_button_state(
    struct bt_conn *conn,
    const struct bt_gatt_attr *attr,
    void *buf, uint16_t len, uint16_t offset)
{
    const uint8_t *value = attr-&gt;user_data;
    return bt_gatt_attr_read(conn, attr, buf, len, offset, 
                             value, sizeof(*value));
}

static void button_ccc_cfg_changed(
    const struct bt_gatt_attr *attr, uint16_t value)
{
    notify_enabled = (value == BT_GATT_CCC_NOTIFY);
    LOG_INF(&quot;Notifications %s&quot;, notify_enabled ? &quot;enabled&quot; : &quot;disabled&quot;);
}

/* GATT Service Definition */
BT_GATT_SERVICE_DEFINE(button_svc,
    BT_GATT_PRIMARY_SERVICE(&amp;button_service_uuid),
    BT_GATT_CHARACTERISTIC(&amp;button_char_uuid.uuid,
                           BT_GATT_CHRC_READ | BT_GATT_CHRC_NOTIFY,
                           BT_GATT_PERM_READ,
                           read_button_state, NULL, &amp;button_value),
    BT_GATT_CCC(button_ccc_cfg_changed,
                BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
);

/* Advertising data (global for reuse) */
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA_BYTES(BT_DATA_UUID128_ALL,
                  0xf0,0xde,0xbc,0x9a,0x78,0x56,0x34,0x12,
                  0x78,0x56,0x34,0x12,0x78,0x56,0x34,0x12),
};

static const struct bt_data sd[] = {
    BT_DATA(BT_DATA_NAME_COMPLETE, CONFIG_BT_DEVICE_NAME,
            sizeof(CONFIG_BT_DEVICE_NAME) - 1),
};

/* Forward declaration for delayed advertising restart */
static void adv_restart_work(struct k_work *work);
K_WORK_DELAYABLE_DEFINE(adv_restart, adv_restart_work);

/* Advertising restart handler */
static void adv_restart_work(struct k_work *work)
{
    int err = bt_le_adv_start(BT_LE_ADV_CONN_FAST_2, ad, ARRAY_SIZE(ad), 
                              sd, ARRAY_SIZE(sd));
    if (err) {
        LOG_ERR(&quot;Retry advertising failed (err %d)&quot;, err);
        k_work_schedule(&amp;adv_restart, K_SECONDS(2));  // retry again later
    } else {
        LOG_INF(&quot;Advertising restarted after delay&quot;);
    }
}

/* Connection Callbacks */
static void connected(struct bt_conn *conn, uint8_t err)
{
    char addr[BT_ADDR_LE_STR_LEN];
    if (err) {
        LOG_ERR(&quot;Connection failed (err %u)&quot;, err);
        return;
    }
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    LOG_INF(&quot;Connected: %s&quot;, addr);
    current_conn = bt_conn_ref(conn);
    /* Stop advertising while connected */
    bt_le_adv_stop();
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
    char addr[BT_ADDR_LE_STR_LEN];
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    LOG_INF(&quot;Disconnected: %s (reason %u)&quot;, addr, reason);
    if (current_conn) {
        bt_conn_unref(current_conn);
        current_conn = NULL;
    }
    notify_enabled = false;

    /* Try to restart advertising immediately, else schedule retry */
    int err = bt_le_adv_start(BT_LE_ADV_CONN_FAST_2, ad, ARRAY_SIZE(ad), 
                              sd, ARRAY_SIZE(sd));
    if (err) {
        LOG_ERR(&quot;Failed to restart adv (err %d). Retry in 2s&quot;, err);
        k_work_schedule(&amp;adv_restart, K_SECONDS(2));
    } else {
        LOG_INF(&quot;Advertising restarted&quot;);
    }
}

BT_CONN_CB_DEFINE(conn_callbacks) = {
    .connected = connected,
    .disconnected = disconnected,
};

/* Polling Thread for buttons */
K_THREAD_STACK_DEFINE(button_thread_stack, 1024);
struct k_thread button_thread_data;

void button_poll_thread(void *p1, void *p2, void *p3)
{
    uint8_t last_value = 0;
    while (1) {
        bool a_pressed = gpio_pin_get_dt(&amp;button_a);
        bool b_pressed = gpio_pin_get_dt(&amp;button_b);
        uint8_t new_value = 0;

        if (a_pressed &amp;&amp; b_pressed) {
            new_value = 3; // A + B pressed
        } else if (a_pressed) {
            new_value = 1; // A pressed
        } else if (b_pressed) {
            new_value = 2; // B pressed
        }

        if (new_value != last_value) {
            button_value = new_value;
            last_value = new_value;

            if (current_conn &amp;&amp; notify_enabled) {
                int err = bt_gatt_notify(current_conn, 
                                         &amp;button_svc.attrs[2],
                                         &amp;button_value, 
                                         sizeof(button_value));
                if (err) {
                    LOG_ERR(&quot;Notify failed (err %d)&quot;, err);
                }
            }

            const char *msg = &quot;&quot;;
            switch (new_value) {
                case 0: msg = &quot;No button pressed&quot;; break;
                case 1: msg = &quot;Button A pressed&quot;; break;
                case 2: msg = &quot;Button B pressed&quot;; break;
                case 3: msg = &quot;A + B pressed&quot;; break;
            }
            LOG_INF(&quot;%s&quot;, msg);
            printk(&quot;%s\n&quot;, msg);
        }

        k_msleep(25);  // Poll every 25 ms
    }
}

int main(void)
{
    int err;
    LOG_INF(&quot;Starting Micro:bit v2 BLE Button Service&quot;);
    if (!gpio_is_ready_dt(&amp;button_a) || !gpio_is_ready_dt(&amp;button_b)) {
        LOG_ERR(&quot;Button GPIOs not ready&quot;);
        return -ENODEV;
    }

    err = gpio_pin_configure_dt(&amp;button_a, GPIO_INPUT);
    if (err) return err;

    err = gpio_pin_configure_dt(&amp;button_b, GPIO_INPUT);
    if (err) return err;

    /* Initialize Bluetooth */
    err = bt_enable(NULL);
    if (err) {
        LOG_ERR(&quot;Bluetooth init failed (err %d)&quot;, err);
        return err;
    }

    LOG_INF(&quot;Bluetooth initialized&quot;);

    /* Start initial advertising */
    err = bt_le_adv_start(BT_LE_ADV_CONN_FAST_2, ad, ARRAY_SIZE(ad),
                          sd, ARRAY_SIZE(sd));
    if (err) {
        LOG_ERR(&quot;Advertising failed to start (err %d)&quot;, err);
        return err;
    }

    LOG_INF(&quot;Advertising started. Waiting for connection...&quot;);

    /* Start polling thread */
    k_thread_create(&amp;button_thread_data, button_thread_stack,
                    K_THREAD_STACK_SIZEOF(button_thread_stack),
                    button_poll_thread, NULL, NULL, NULL,
                    5, 0, K_NO_WAIT);
    return 0;
}
</code></pre>
<p>&nbsp;</p>
<p>ตัวอย่าง <strong>Web App</strong> สำหรับทดสอบการเชื่อมต่อกับอุปกรณ์ <strong>Micro:bit v2</strong>
(ชื่ออุปกรณ์ <code>Micro:bit Button</code>)
เพื่อตรวจสอบการกดปุ่มบนบอร์ด และแสดงสถานะบนหน้าเว็บ โดยใช้ <strong>Chrome Web Browser</strong></p>
<p><strong>File:</strong> <code>index.html</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h3&gt;Micro:bit v2 BLE Button Service&lt;/h3&gt;
&lt;button id=&quot;connect&quot;&gt;Connect&lt;/button&gt;
&lt;pre id=&quot;log&quot;&gt;&lt;/pre&gt;

&lt;script&gt;
const log = document.getElementById(&quot;log&quot;);
const btn = document.getElementById(&quot;connect&quot;);

let device, server, buttonChar, connected = false;
const SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
const CHAR_UUID    = '12345678-1234-5678-1234-56789abcdef1';

function logLine(msg) {
  log.textContent += msg + &quot;\n&quot;;
  log.scrollTop = log.scrollHeight;
}

async function connectDevice(dev = null) {
  try {
    log.textContent = &quot;&quot;;
    device = dev || await navigator.bluetooth.requestDevice({
      filters: [{ name: 'Micro:bit Button' }],
      optionalServices: [SERVICE_UUID],
    });

    device.addEventListener('gattserverdisconnected', tryReconnect);
    server = await device.gatt.connect();

    const service = await server.getPrimaryService(SERVICE_UUID);
    buttonChar = await service.getCharacteristic(CHAR_UUID);

    const v = await buttonChar.readValue();
    logLine(&quot;Initial Button State: &quot; + v.getUint8(0));

    await buttonChar.startNotifications();
    buttonChar.addEventListener('characteristicvaluechanged', e =&gt; {
      const val = e.target.value.getUint8(0);
      const msg = [&quot;Released&quot;, &quot;Button A&quot;, &quot;Button B&quot;, &quot;A+B&quot;][val] || val;
      logLine(&quot;Pressed: &quot; + msg);
    });

    logLine(&quot;Connected to Micro:bit&quot;);
    btn.textContent = &quot;Disconnect&quot;;
    connected = true;
  } catch (err) {
    console.log( err );
    btn.textContent = &quot;Connect&quot;;
  }
}

async function disconnectDevice() {
  if (device?.gatt?.connected) {
    device.gatt.disconnect();
    logLine(&quot;Device disconnected&quot;);
    connected = false;
  }
  btn.textContent = &quot;Connect&quot;;
}

async function tryReconnect() {
  logLine(&quot;Device disconnected — trying to reconnect...&quot;);
  btn.textContent = &quot;Reconnecting...&quot;;
  try {
    if (device &amp;&amp; device.gatt.connected === false) {
      await connectDevice(device);
    }
  } catch {
    logLine(&quot;Reconnect failed. Please press Connect.&quot;);
    btn.textContent = &quot;Connect&quot;;
  }
}

btn.onclick = async () =&gt; {
  if (device?.gatt?.connected) await disconnectDevice();
  else await connectDevice();
};

// Auto-reconnect to known devices after reload
if (navigator.bluetooth.getDevices) {
  navigator.bluetooth.getDevices().then(devices =&gt; {
    const d = devices.find(d =&gt; d.name === &quot;Micro:bit Button&quot;);
    if (d) {
      logLine(&quot;Reconnecting to saved device...&quot;);
      connectDevice(d);
    }
  });
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img alt="" src="ble_buttons-1.jpg" /></p>
<p>รูป: การเชื่อมต่อกับอุปกรณ์ <strong>Micro:bit v2</strong> โดยใช้ <strong>BLE</strong></p>
<p><img alt="" src="ble_buttons-2.jpg" /></p>
<p>รูป: การแสดงสถานะของปุ่มกดบนบอร์ด  <strong>Micro:bit v2</strong> บนหน้าเว็บ เมื่อมีการเชื่อมต่อได้สำเร็จแล้ว</p>
<p>&nbsp;</p>
<hr />
<p><em>This work is licensed under a</em> <strong><em>Creative Commons Attribution-ShareAlike 4.0 International License.</em></strong></p>
<p>Created: 2025-10-29 | Last Updated: 2025-10-31</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2021-2025 IoT Engineering Education, Bangkok/Thailand</a></p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
